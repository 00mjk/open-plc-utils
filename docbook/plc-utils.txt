Qualcomm Atheros Powerline Toolkit

Qualcomm Atheros, Ocala FL USA

Edited by

Charles Maier

Andrew Barnes <andrew.barnes@qca.qualcomm.com>
Marc Bertola <marc.bertola@qca.qualcomm.com>
Nate Houghton <nathan.houghton@qca.qualcomm.com>
Bill Wike <bill.wike@qca.qualcomm.com>
Alejandro Vasquez <alejandro.vasquez@qca.qualcomm.com>

plc-utils-2.1.2

Abstract

This document is the manual for the Qualcomm Atheros Powerline Toolkit. New
users should read the first chapter before starting using the toolkit because
it will answer many questions about toolkit installation, structure, content
and application. New users may want to add this page and toolkit.html to their
browser favorites for later reference.

HomePlug® AV is a registered trademark of the HomePlug Powerline Aliance.
Linux™ is a trademark of Linus Tovalds. Windows® is a registered trademark of
Microsoft Corporation. INT6000™, INT6300™, INT6400™, AR6410™, QCA7000™, AR7400™
and AR7420™ are powerline products from Qualcomm Atheros.

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

Table of Contents

1. Overview

    Introduction
    Background
    Toolkit Distribution
    Toolkit Installation on Linux

        Toolkit Installation on GNU/Linux™
        Toolkit Documentation on GNU/Linux
        Toolkit Removal on GNU/Linux™

    Toolkit Installation on Mac OS X
    Toolkit Installation on Windows XP™

        Obtaining the Toolkit
        Installing the Toolkit
        Setting the PATH variable
        Removing the Toolkit

    Toolkit Installation on Windows 7™

        Obtaining the Toolkit
        Installing the Toolkit
        Setting the PATH variable
        Removing the Toolkit

    Toolkit Programs

        INT6400 Device Management
        INT6400 Device Monitoring
        AR7400 Device Management
        AR7400 Device Monitoring
        AR7420 Device Configuration
        Parameter File Management
        Firmware File Management
        Ethernet Traffic
        Passwords and Keys
        MDIO Programming
        Serial Programming

    Toolkit Folders
    Packages
    Toolkit Support

2. Hardware

    Introduction
    Device Form Factors
    Device Communications
    Device Configurations

        Local Host to Local Device
        Local Host to Remote Device
        Local Host to Remote Host

    Powerline Workstations

        Host Hardware
        Host Software
        Network Configuration
        Isolated Power-strip

    Send-to-self Patch

3. Software

    Introduction
    Security Considerations
    Platform Options

        GNU/Linux
        GNU/Linux with Libpcap
        GNU/Linux with BPF
        Mac OS X™ with BPF
        Windows XP™ with Winpcap

    GNU Makefiles on Linux
    Stand-alone Compiling on GNU/Linux
    Cross-Compiling on GNU/Linux
    Compilation with Visual Studio .NET 2003
    Microsoft Solution Files
    Header Files
    Compiler Constants

        Platform Constants
        Ethernet Constants

    LibPcap, WinPcap and BPF
    Structure Packing
    Endian-ness
    Packet Basics
    Frame Encoding

4. Firmware

    Introduction
    Firmware Components

        Bootloader
        Softloader
        Memory Configuration Parameters
        Runtime Firmware (MAC Software)
        Parameter Information Block (PIB)

    Architecture Overview
    Firmware Boot Process
    Boot from Host Configuration
    Things to Remember
    Every Little Bit Hurts
    Liar! Liar! Pants on Fire!
    But wait! There's more ...
    Upgrade Device (INT6000/INT6300/INT6400)
    Update Local Host (INT6000/INT6300/INT6400)
    Boot from Host (INT6000)
    Boot from Host (INT6300)
    Boot from Host (INT6400)
    Boot from Host (AR7400)
    Boot from Host (AR7420)
    Flash Memory (AR6410/AR7420)

5. Procedures

    Introduction
    Select an Interface on Linux
    Select an Interface on Windows
    Identify a Device
    Browse the Network
    Forming a Network
    Configuring a Device
    Upgrading Firmware and PIB
    Upgrading PIB Only
    Starting a Device
    Testing a Device
    Programming NVRAM
    Pairing UART Devices post PTS
    Trouble-shooting Problems

6. Scripting

    Introduction
    Linux Script Basics
    Host Independence
    Checking Device Connection
    Random Device Identity
    Actual Device Identity
    Editing a PIB
    Initialize a Device
    Update a Device
    Generating Powerline Traffic
    Reading PHY Rates
    User Interaction

7. Support Function Reference

    Introduction
    Command Line Functions

        assist
        basespec
        bytespec
        checkfilename
        dataspec
        error
        expect
        getoptv
        ipv4spec
        ipv6spec
        lookup
        putoptv
        synonym
        uintspec
        version

    Ethernet Functions

        channel
        closechannel
        openchannel
        readpacket
        sendpacket

    Network Functions

        NetworkBridges
        NetworkDevices

    Generic Functions

        binout
        checksum32
        checksum_32
        chrout
        decout
        endian
        fdchecksum32
        fdchecksum_32
        filepart
        hexdecode
        hexdump
        hexencode
        hexin
        hexout
        hexstring
        hexview
        memdecr
        memincr
        memout
        memswap
        strdecr
        strfbits
        strincr
        todigit
        typename

    Message Debug Functions

        MMECode
        MMEMode
        MMEName
        MMEPeek

    Key Generation Functions

        MACPasswords
        HPAVKeyDAK
        HPAVKeyNMK
        HPAVKeyNID
        HPAVKeyOut
        SHA256Block
        SHA256Fetch
        SHA256Ident
        SHA256Match
        SHA256Print
        SHA256Reset
        SHA256Write

    XML Editing Functions

        xmledit
        xmlfree
        xmlnode
        xmlopen
        xmlscan
        xmlschema
        xmltree

    Download Functions

        WriteExecuteApplet
        WriteExecuteApplet1
        WriteExecuteApplet2

    Procrastination Functions

        WaitForAssoc
        WaitForAssoc1
        WaitForAssoc2
        WaitForReset
        WaitForStart

    Traffic Functions

        CrossTraffic1
        CrossTraffic2
        LocalTraffic1
        LocalTraffic2
        NetworkTraffic1
        NetworkTraffic2
        Traffic1
        Traffic2

8. Serial Drivers

    Introduction
    Principles of Operation
    SPI Serial Driver

        qcaspi_spi_thread
        qcaspi_qca7k_sync

    Register Functions

        qcaspi_read_register
        qcaspi_write_register
        qcaspi_tx_cmd

    Interrupt Functions

        disable_spi_interrupts
        enable_spi_interrupts
        qcaspi_intr_handler

    Transmit Functions

        qcaspi_transmit
        qcaspi_tx_frame
        qcaspi_flush_txq

    Receive Functions

        qcaspi_receive

    DMA Functions

        qcaspi_dma_read_burst
        qcaspi_dma_read_legacy
        qcaspi_dma_write_burst
        qcaspi_dma_write_legacy

    Support Functions

        QcaFrmCreateHeader
        QcaFrmCreateFooter
        QcaFrmFsmInit
        QcaFrmFsmDecode

    Kernel Functions

        qcaspi_netdev_xmit
        qcaspi_netdev_tx_timeout
        qcaspi_netdev_uninit
        qcaspi_netdev_get_stats
        qcaspi_netdev_change_mtu
        qcaspi_netdev_set_mac_address
        qcaspi_netdev_close
        qcaspi_mod_exit

List of Figures

1.1. Windows Installer Dialogue
1.2. Control Panel System Dialogue
1.3. Control Panel Add/Remove Dialogue
1.4. Windows Installer Dialogue
1.5. Control Panel System Dialogue
1.6. Control Panel Add/Remove Dialogue
4.1. Simple Network
4.2. Upgrade Device (INT6000/INT6300/INT6400)
4.3. Update Local Host (INT6000/INT6300/INT6400)
4.4. Boot from Host (INT6000)
4.5. boot-from-host (INT6300)
4.6. Boot from Host (INT6400)
4.7. Boot from Host (AR7400)
4.8. Boot from Host (AR6410/AR7420)
4.9. Flashing the Softloader (AR7420)
4.10. Flash Parameters and Firmware (AR7420)

List of Tables

1.1. Program/Package Matrix
4.1. Softloader/Bootloader MMEs
4.2. Legacy Device Identification
4.3. Device Identification
8.1. SPI Transmit Frame
8.2. SPI Receive Frame

List of Examples

1.1. Toolkit Installation on GNU/Linux™
1.2. Toolkit Removal on GNU/Linux™
1.3. Setting the PATH variable on OS X™
1.4. Installing the Toolkit on Mac OS X™
2.1. “send-to-self” Patch Description
2.2. “send-to-self” Patch Application
2.3. “send-to-self” Patch Installation
2.4. “send-to-self” Patch Listing
3.1. The MAKEFILE constant
3.2. Stand-alone Compiling on GNU/Linux
3.3. Cross-compiling with make.def
3.4. Microsoft Visual Studio .NET 2003
3.5. Packing Structures with keyword “__packed”
3.6. Packing Structures with Attribute “packed”
3.7. Packing Structures with the Pragma “pack”
3.8. Packing Structures the Atheros Way
3.9. Frame Encoding by Offset
3.10. Frame Encoding by Address
5.1. Selecting another Interface on Linux
5.2. Changing the Default Interface on Linux
5.3. Finding Interfaces on Linux
5.4. Selecting another Interface on Windows
5.5. Finding Interfaces on Windows
5.6. Device Identification
5.7. Inspecting Device Configuration
5.8. Display Network Information
5.9. Setting the Network Membership Key
5.10. Forming a Custom Network
5.11. Remote Network Configuration
5.12. Read a PIB File
5.13. Modify a PIB File
5.14. Save a PIB File
5.15. Upgrade Firmware and PIB
5.16. Upgrade local device PIB
5.17. Upgrade remote PIB
5.18. Start Firmware on INT6000™
5.19. Start Firmware on INT6300™ and INT6400™
5.20. Start Firmware on AR7400™
5.21. Start Firmware on AR7420™
5.22. Flash NVRAM with int6kf
5.23. Flash NVRAM with int6k
6.1. hardware.sh
6.2. firmware.sh
7.1. Enumerating Local Devices
7.2. Enumerating Network Devices
7.3. SHA256 Digest Computation
7.4. XML Source File
7.5. XML Edit Schema
7.6. XML Parse Tree

Chapter 1.  Overview

Table of Contents

Introduction
Background
Toolkit Distribution
Toolkit Installation on Linux

    Toolkit Installation on GNU/Linux™
    Toolkit Documentation on GNU/Linux
    Toolkit Removal on GNU/Linux™

Toolkit Installation on Mac OS X
Toolkit Installation on Windows XP™

    Obtaining the Toolkit
    Installing the Toolkit
    Setting the PATH variable
    Removing the Toolkit

Toolkit Installation on Windows 7™

    Obtaining the Toolkit
    Installing the Toolkit
    Setting the PATH variable
    Removing the Toolkit

Toolkit Programs

    INT6400 Device Management
    INT6400 Device Monitoring
    AR7400 Device Management
    AR7400 Device Monitoring
    AR7420 Device Configuration
    Parameter File Management
    Firmware File Management
    Ethernet Traffic
    Passwords and Keys
    MDIO Programming
    Serial Programming

Toolkit Folders
Packages
Toolkit Support

Introduction

Qualcomm Atheros provides the Powerline Toolkit free of charge to their
customers. The toolkit contains C Language source code and GNU™ makefiles to
compile many useful programs. It also includes Linux shell scripts that use
these programs, in various ways, to interrogate, control and manage Qualcomm
Atheros INT6000™, INT6300™, INT6400™, AR7400™ and later powerline devices.
Qualcomm Atheros also provides a similar, but less extensive, toolkit for
INT5500™ powerline devices.

The toolkit is intended for hardware engineers, verification engineers, field
engineers and embedded software developers, consequently, programs are simple
and compact. It is not intended for computer novices or retail users. Many
customers embed a subset of toolkit programs in products for troubleshooting
purposes.

The toolkit includes extensive HTML documentation and online man pages for
users who cannot access installed man pages. HTML documentation starts with
file docbook/index.html. Online man pages start with file docbook/toolkit.html.
Qualcomm Atheros recommends that you add these two pages to your browser
favorites for later reference.

All toolkit programs are written in C and have command line intefaces. The
source code essentially conforms to ISO/IEC9899:1999. The source tree cleanly
compiles using gcc or pcc on Ubuntu, OpenBSD and MacOSX. It also compiles under
Microsoft C with the inclusion of special header files. The command line
interface conforms to Section 12.2 Utility Syntax Guidelines of The Open Group
Base Specification Issue 6 ( IEEE Std 1003.1, 2004 Edition).

The toolkit includes Microsoft Visual Studio .NET project files and solutions
files to compile toolkit programs, plus the executable version (.exe) of each
program and a set of Microsoft installation file (.msi) so that the toolkit
package comes ready to install and run on any Windows host; however, Qualcomm
Atheros does not provide support for Microsoft windows version of this toolkit.
Toolkit documentation does provide Windows developers with special guidance on
setting up their own Visual Studio projects and solutions, should they want to
do that.

Background

HomePlug® AV is an industry standard protocol for powerline communications
developed by the HomePlug Powerline Alliance. Qualcomm Atheros manufactures a
family of chipsets that conform to that standard and have MII, UART and SPI
host interfaces. The INT6x00™ and AR7x00™ series are flagship members of that
chipset family. The principle difference between the chipsets is their boot
method, cost and speed. The INT6000™ requires onboard NVRAM but the INT6300™,
INT6400™ and AR7400™ do not.

The HomePlug® AV protocol is based on IEEE-802.3, has ethertype 0x88E1 and uses
special message formats. A subset of those message formats is reserved for each
chipset vendor to define their own message formats. Qualcomm Atheros uses this
vendor-specific subset to communicate between host processors and Qualcomm
Atheros devices. This toolkit uses Qualcomm Atheros vendor-specific message
formats to communicates with Qualcomm Atheros devices. It also understands
Qualcomm Atheros firmware and configuration file formats.

This toolkit sends and receives Qualcomm Atheros vendor-specific messages but
not generic HomePlug® AV messages. Qualcomm Atheros vendor-specific management
message formats are described in the Qualcomm Atheros HomePlug® AV Firmware
Technical Reference Manual. If you do not have a copy of this document then you
may request one from Qualcomm Atheros.

Toolkit Distribution

The Qualcomm Atheros Powerline Toolkit is distributed using compressed tape
archive files named plc-utils-x.x.x.tar.gz and plc-utils-x.x.x.tar.bz2 and
standard compressed archive file named plc-utils-x.x.x.zip, where x.x.x is the
version number. Archive files ending in .gz can be decompressed with the Linux
gzip utility. Archive files ending in .bz2 can be decompressed with the Linux
bzip2 utility. Archive files ending in .zip can be decompressed using the Linux
unzip utility or the Windows WinZip utility. The contents of decompressed
archives can be extracted using the Linux tar utility. Recent versions of the
Linux tar utility allow decompression and extraction in one operation. The
WinZip or 7-zip program may be used to decompress archives and extract contents
on Microsoft Windows platforms.

Some Windows network administrators enable security software that removes .exe
and other executable files from .zip archives in transit or in-situ. In that
case, Windows user may want to download the *.tar.gz archive and use a program
like 7zip to unpack the archive file.

The toolkit includes source code, build scripts, documentation and pre-compiled
programs for Microsoft Windows. Some third party libraries may also be included
to support Microsoft platforms. Although the Microsoft Windows versions of
toolkit programs are pre-compiled and ready-to-run, they are not supported
because this package is designed for use on Linux platforms.

The Windows installer included in this version of the toolkit needs Microsoft
.NET 1.1. Windows versions of toolkit programs that communicate with powerline
devices need WinPcap 4.1.2 or later. A copy of Microsoft .NET 1.1 and WinPcap
4.1.2 is included in the support folder.

Toolkit Installation on Linux

The Linux version of the toolkit must be compiled from source code. The only
requirement is the standard GNU/Linux toolchain consisting of make, gcc and ld.
These are included with most Linux distributions but may require installation.
On Debian™ based distributions, such as Ubuntu™, they may be installed using
apt-get. On RedHat™ distributions, such as Fedora™, they may be installed using
rpm. On SuSE™ based distributions, they may be installed using YaST2.

Toolkit Installation on GNU/Linux™

Example 1.1.  Toolkit Installation on GNU/Linux™

# cp plc-utils-1.2.1.tar.gz /home/mydir
# cd /home/mydir
# tar -vzxf plc-utils-1.2.1.tar.gz
# cd plc-utils-1.2.1
# make
# make install
# make manuals


Decompress the archive and extract the contents with the tar utility. This will
create a folder having the same basename as the archive such that one version
will not over-write another. Consult the tar man page on your system for
detailed instructions. Change directory to the appropriate folder.

The main package folder contains a recursive Makefile that will compile and
install all toolkit programs. If you do not want to compile and install all
programs then change directory to the appropriate folder and run make from
there. To compile binary files, type make. To install binary files, type make
install. To install man pages, type make manuals. The package does not
automatically install examples, scripts, applets or man pages.

We recommend that you login as root user before installing the toolkit;
otherwise, you will be prompted for the root password as each program or
component is installed.

Programs are installed in folder /usr/local/bin and man pages are installed in
folders /usr/share/man/man7. If these folders are not correct for your system,
or if you want to install in other folders, then edit the folder names defined
in the make.def file found in main toolkit folder or over-ride these
definitions in subordinate makefiles.

Toolkit Documentation on GNU/Linux

Toolkit web pages are not automatically installed. To access toolkit
documentation, point your browser to docbook/index.html and add the page to the
browser bookmark or favorites list. If you are interested in how the toolkit
has been implemented then do the same for page docbook/toolkit.html.

The method described above is only recommended if you do not plan to move or
remove toolkit folders. Otherwise, you can merely copy the entire contents of
the toolkit docbook folder to another folder of your choice and point your
browser to the new file locations.

cp -rv docbook/* /home/mydir/toolkit

Toolkit Removal on GNU/Linux™

To uninstall installed programs and man pages on Linux, change to the main
toolkit folder and type make uninstall.

Example 1.2.  Toolkit Removal on GNU/Linux™

# cd /home/mydir/plc-utils-1.2.1
make uninstall


Toolkit Installation on Mac OS X

Toolkit installation on Mac OS X™ is essentially identical to installation on
Linux but special steps are needed before starting.

First, you must install the toolkit as the root user or you will be denied
permission. The root user account is disabled by default and so you must enable
it in order to login. Follow instructions at Enabling the "root" user in Mac OS
X to enable the account and login. After installation, toolkit programs should
be run from a normal user account.

Second, Mac OS X™ does not include C Language development tools by default. You
must download and install them in order to build the toolkit. You can download
and install them from the Apple website or (if you are ambitious) download,
compile and install them from various open source websites. Consider using
Xcode on Mac OS X Leopard or Lion.

Login as the root user and download or copy the toolkit archive file to your
preferred folder then follow the instructions for installing the toolkit on
Linux.

Example 1.3.  Setting the PATH variable on OS X™

While still logged in as the root user, edit /etc/profile and add folder/usr/
local/bin to the PATH definition found there. This will ensure that all users
can access toolkit programs. The change may not take effect until the next time
you login or open a new command shell.

PATH="/bin:/sbin:/usr/local/bin"


Example 1.4.  Installing the Toolkit on Mac OS X™

While still logged in as the root user, remember to delete the toolkit source
folder or, at least change ownership of all files in the toolkit folder, so
that you can access and/or remove them later.

cd ..
rm -r plc-utils-x.x.x


Toolkit Installation on Windows XP™

The Windows™ version of the toolkit comes pre-compiled and ready to install and
run using the Windows Installer. You may copy and distribute installation file
plc-utils-x.x.x.msi. Users may then click on the installation file to install
the package then discard it afterwards. The installation file permits remote
installation over the network.

The version of the Windows Installer used here needs Microsoft .NET Framework
1.1™ to work correctly. Newer versions of the .NET Framework™ will not work.
The .NET Framework™ must be installed before the toolkit is installed or the
Windows Installer™ will report depenency errors and refuse to complete
installation. Multiple versions of the .NET Framework™ can coexist under
Windows 7™. The .NET Framework™ needed is included in the toolkit support
folder.

Tip

Users on the QCA corporate network may be able to download installer ftp://
appslinux01.qca.qualcomm.com/windows/dotnetfx.exe then execute it by
right-clicking on the file and and selecting option Run As Administrator.

Windows versions of toolkit programs that communicate with powerline devices
all need WinPcap™ from winpcap.org to read and write Ethernet frames. WinPcap™
may be installed before or after toolkit installation but tools that access
powerline devices will not run without it. You may want to install WinPcap™
before starting toolkit installation. If you have Wireshark™ installed then you
probably already have WinPcap™ installed. A recent copy of WinPcap™ is included
in the toolkit support folder.

Tip

Users on the QCA corporate network may be able to download installer ftp://
appslinux01.qca.qualcomm.com/windows/WinPcap_4_1_2.exe then execute it by
right-clicking on the file and selecting option Run As Administator.

Failure to remove previous toolkit versions on some systems may result in the
message "Another version of this product is already installed" when trying to
install a new version. You may want to remove prior version before starting
toolkit installation.

Obtaining the Toolkit

QCA customers can download the toolkit from the QCA Customer FTP Site.

QCA employees may be able to download the toolkit from the QCA Application
Engineering World FTP site ftp://appslinux01.qca.qualcomm.com/toolkit/plc-utils
/. There are several installers available for Windows. Each installs a subset
of the toolkit. Download the desired installer files to your local machine then
execute them by right-clicking on them and selecting option "Run as
Administrator".

Installing the Toolkit

Use a compression program like WinZip to decompress the archive file and
extract all files. Use Microsoft Windows Explorer to locate file .\
VisualStudioNET\plc-utils-x.x.x.msi under the main toolkit folder. Click on the
file to start the Windows Installer then follow the installation instructions.

Figure 1.1.  Windows Installer Dialogue

                          Windows Installer Dialogue


Older toolkit programs were installed in folder C:\Program Files\Atheros\
Toolkit but they are now installed in folder C:\Program Files\Qualcomm Atheros\
Powerline Toolkit instead. If you select a different folder, remember it for
the next step.

Setting the PATH variable

Toolkit programs have command line interfaces and must be run from an open
console window. To simplify program access and minimize the typing required,
add the toolkit installation path mentioned above to the PATH environment
variable by following steps listed below. If you have Administrator privileges
then we recommend that you edit the system PATH variable; otherwise, you may
need to create and/or edit a user PATH variable.

Figure 1.2.  Control Panel System Dialogue

                         Control Panel System Dialogue


 1. On the Start menu, select the Control Panel option.

 2. In the Control Panel window, select the System icon.

 3. On the System Properties dialog box, select the Advanced tab.

 4. On the Advanced tab, press the Environment Variables button.

 5. On the Environment Variables dialog box, scroll down the System variables
    list and select the Path variable then press the Edit button.

 6. On the Edit System Variable dialogue box, append the installation path to
    the Variable value field.

 7. Press the OK button.

Removing the Toolkit

To remove an existing version of the Qualcomm Atheros Powerline Toolkit from
your system, follow the steps listed below. If the toolkit is not installed on
your system then omit these steps. If you are unsure, you can follow them to
determine if you have the toolkit installed or you can attempt to install,
anyway, and return here if installation is prevented.

Figure 1.3.  Control Panel Add/Remove Dialogue

                       Control Panel Add/Remove Dialogue


 1. On the Start menu, select the Control Panel option.

 2. In the Control Panel window, select the Add or Remove Programs icon.

 3. On the Add or Remove Programs dialog box, scroll down and select the
    Qualcomm Atheros Powerline Toolkit entry then press the Remove pushbutton.

Toolkit Installation on Windows 7™

The Windows™ version of the toolkit comes pre-compiled and ready to install and
run using the native Windows Installer. You may copy and distribute
installation file plc-utils-x.x.x.msi. Users merely click on the file to
install the package and may discard it afterwards. This method of installation
permits remote installation over anetwork.

The version of the Windows Installer used here needs Microsoft .NET Framework
1.1™ to work correctly. Newer versions of the .NET Framework™ will not work.
The .NET Framework™ must be installed before the toolkit is installed or the
Windows Installer™ will report depenency errors and refuse to complete
installation. Multiple versions of the .NET Framework™ can coexist under
Windows 7™. The .NET Framework™ needed is included in the toolkit support
folder.

Tip

Users on the QCA corporate network may be able to download installer ftp://
appslinux01.qca.qualcomm.com/windows/dotnetfx.exe then execute it by
right-clicking on the file and and selecting option Run As Administrator.

Failure to remove previous toolkit versions on some systems may result in the
message "Another version of this product is already installed" when trying to
install a new version. You may want to remove prior version before starting
toolkit installation.

Windows versions of toolkit programs that communicate with powerline devices
all need WinPcap™ from winpcap.org to read and write Ethernet frames. WinPcap™
may be installed before or after toolkit installation but tools that access
powerline devices will not run without it. You may want to install WinPcap™
before starting toolkit installation. If you have Wireshark™ installed then you
probably already have WinPcap™ installed. A recent copy of WinPcap™ is included
in the toolkit support folder.

Tip

Users on the QCA corporate network may be able to download installer ftp://
appslinux01.qca.qualcomm.com/windows/WinPcap_4_1_2.exe then execute it by
right-clicking on the file and selecting option Run As Administator.

Obtaining the Toolkit

QCA customers can download the toolkit from the QCA Customer FTP Site.

QCA employees may be able to download the toolkit from the QCA Application
Engineering World FTP site ftp://appslinux01.qca.qualcomm.com/toolkit/plc-utils
/. There are several installers available for Windows. Each installs a subset
of the toolkit. Download the desired installer files to your local machine then
execute them by right-clicking on them and selecting option "Run as
Administrator".

Installing the Toolkit

Older toolkit programs were installed in folder C:\Program Files\Atheros\
Toolkit by default but now they are installed in C:\Program Files (x86)\
Qualcomm Atheros\Powerline Toolkit instead. If you slect a different folder
during installation then remember it for the next step.

Figure 1.4.  Windows Installer Dialogue

                          Windows Installer Dialogue


Accept install defaults.

Setting the PATH variable

Toolkit programs have command line interfaces and must be run from an open
console window. To simplify program access and minimize the typing required,
add the toolkit installation path mentioned above to the PATH environment
variable by following steps listed below. If you have Administrator privileges
then we recommend that you edit the system PATH variable; otherwise, you may
need to create and/or edit a user PATH variable.

Figure 1.5.  Control Panel System Dialogue

                         Control Panel System Dialogue


 1. On the Start menu, select the Control Panel option.

 2. On the Adjust system settings page, select the System icon.

 3. On the View basic informtion about your computer page, select the Advanced
    system settings option.

 4. On the System Properties dialog, press the Environment Variables button.

 5. On the Environment Variables dialog box, scroll down the System variables
    list and select the Path variable then press the Edit button.

 6. On the Edit System Variable dialogue box, append the installation path to
    the Variable value field.

 7. Press the OK button.

Environment variable changes made here do not take effect until a console
window is opened. This means that you may need to close and then reopen console
windows that depend on the changes. It is a good idea to immediately open a
console window and execute a toolkit command in order to confirm that the PATH
variable is properly defined.

Removing the Toolkit

To remove an existing version of the Qualcomm Atheros Powerline Toolkit from
your system, follow the steps listed below. If the toolkit is not installed on
your system then omit these steps. If you are unsure, you can follow them to
determine if you have the toolkit installed or you can attempt to install,
anyway, and return here if installation is prevented.

Figure 1.6.  Control Panel Add/Remove Dialogue

                       Control Panel Add/Remove Dialogue


 1. On the Start menu, select the Control Panel option.

 2. On the Adjust system settings page, select the Programs and Features icon.

 3. On the Uninstall or change a program page, scroll down and select the
    appropriate QCA Powerline Toolkit entry then press the Remove pushbutton.
    There may be several different QCA Powerline Toolkit entries so be sure to
    select the correct one.

Toolkit Programs

The Qualcomm Atheros Powerline Toolkit is a collection of small, command line
programs. Each program deals with some aspect of powerline device management.
Programs can be combined, in various ways, using shell scripts, to perform
sophisticated and complex tasks. With these program, one can identify chipset
and firmware version, reset devices, flash devices, identify other powerline
network devices, validate *.pib and *.nvm files, sniff HomePlug® AV Ethernet
frames, send generic Ethernet frames and so on.

Program source code is designed to demonstrate device hardware and firmware
features and to illustrate techniques for software developers and hardware
engineers. The source code may be modified and distributed without obligation
to Qualcomm Atheros; hwoever Qualcomm Atheros would appreciate feedback
concerning improvements to program useability, reliability or efficiency. Keep
in mind that these tools, unlike some other tools, are intended to be simple
and compact.

Most programs in this toolkit start their life on Linux and are eventually
ported to other environments. Consequently, not all programs are available in
the Windows version of the toolkit but most of them are.

Program descriptions appear below in alphabetical order. Alternately, you may
browse the latest progam descriptions and source code here.

INT6400 Device Management

Programs in this group are older versions that communicate with INT6x00
chipsets. Many still work on AR7x00 chipsets. The main differencs is due to the
higher PHY data rates on AR7x00 chipsets. The higher data rates must be
expressed using 16-bits instead of 8-bits. Consequently, some MME formats have
changed.

int64host

    A command line utility that waits for and services VS_HST_ACTION messages
    from a flash-less device INT6300™ or INT6400™ device. It is similar to
    program int6khost but does not use an SDRAM configuration files. This
    program is installed in folder /usr/local/bin with 4555 file permissions.
    See the discussion on security for more information about file permissions.
    The main source code is located in folder ./plc. See the int64host man page
    for more information.

int6k

    A command line utility to inspect and control INT6000™ and INT6300™ devices
    connected to the local host. It performs several of the device maintenance
    functions available in the Atheros Windows Device Manager but is small
    enough to run on an embedded system. This program is installed in folder /
    usr/local/bin with 4555 file permissions. See the discussion on security
    for more information about file permissions. The main source code is
    located in folder .int6k. See the int6k man page for more information.

int6k2

    A command line utility to inspect and control INT6000™ and int6300™ devices
    connected to the local host. It is similar to int6k but calls the Atheros
    Embedded API, described in the Atheros HomePlug® AV API User's Guide, to
    perform device management tasks. This program is installed in folder /usr/
    local/bin with 4555 file permissions. See the discussion on security for
    more information about file permissions. The main source code is located in
    folder ./plc. See the int6k2 man page for more information.

int6kboot

    A command line utility to start and optionally flash INT6300™ and INT6400™'
    devices that have no NVRAM or have a blank or corrupted NVRAM. It
    communicates with the Atheros Bootloader to configure SDRAM, download
    runtime firmware and PIB and start firmware execution. Users can optionally
    request that the same PIB and firmware then be used to flash NVRAM. It is
    similar to program int6kf but does not accept an SDRAM configuration file.
    Instead, it uses on the memctl applet. This program is installed in folder
    /usr/local/bin with 4555 file permissions. See the discussion on security
    for more information about file permissions. The main source code is
    located in folder ./plc. See the int6kboot man page for more information.

int6kf

    A command line utility to start and optionally flash INT6000™ and INT6300™
    devices having no NVRAM or having a blank or corrupted NVRAM. It
    communicates with the Atheros Bootloader to configure SDRAM, download
    runtime firmware and PIB and start firmwrae execution. It can also be used
    to force flash blank or corrupted NVRAM. It is similar to program int6kboot
    but requires an SDRAM parameter file. This program is installed in folder /
    usr/local/bin with 4555 file permissions. See the discussion on security
    for more information about file permissions. The main source code is
    located in folder ./plc. See the int6kf man page for more information.

int6khost

    A command line utility that waits for and services VS_HST_ACTION messages
    from a flash-less INT6000™ or INT6300™ device. It is similar to program
    in64host but needs an SDRAM configuration file. This program is installed
    in folder /usr/local/bin with 4555 file permissions. See the discussion on
    security for more information about file permissions. The main source code
    is located in folder ./plc. See the int6khost man page for more
    information.

int6kid

    A command line utility that prints the DAK or NMK strings read from one or
    more devices. It can be used in shell scripts to dynamically obtain device
    keys and insert them on program command lines as arguments. This program is
    installed in folder /usr/local/bin with 4555 file permissions. See the
    discussion on security for more information about file permissions. The
    main source code is located in folder ./plc. See the int6kid man page for
    more information.

int6klist

    A command line utility that lists local devices, or remote devices
    associated with a specific device, on stdout in undecorated format. It can
    be used in shell scripts to dynamically determine, and then traverse,
    network topology. This program is installed in folder /usr/local/bin with
    4555 file permissions. See the discussion on security for more information
    about file permissions. The main source code is located in folder ./plc.
    See the int6klist man page for more information.

int6kprobe

    A command line utility that probes for neighboring networks. This program
    is installed in folder /usr/local/bin with 4555 file permissions. See the
    discussion on security for more information about file permissions. The
    main source code is located in folder ./plc. See the int6kprobe man page
    for more information.

int6krule

    A command line utility to format and send classification rules to a device.
    Classification rules are specified using symbolic names for actions,
    options, conditions and frame fields. This program is installed in folder /
    usr/local/bin with 4555 file permissions. See the discussion on security
    for more information about file permissions. The main source code is
    located in folder ./plc. See the int6krule man page for more information.

int6ktest

    A command line utility that downloads and executes program images stored in
    an Atheros .nvm file. This program can be used to download and execute
    Atheros hardware diagnostic programs like those in the ./applets folder. It
    is not intended to download and start runtime firmware, although it may be
    used for that. The program is installed in folder /usr/local/bin with 4555
    file permissions. See the discussion on security for more information about
    file permissions. The main source code is located in folder ./plc. See the
    int6ktest man page for more information.

int6kuart

    A command line utility used to manage a local powerline device over a host
    serial line interface. Program command line options are translated to
    AT-style serial commands and sent to the device. THe primary benefits of
    using this program, in place of a terminal emulator, is the ability to
    download parameter blocks and upload paameter blocks and firmware images.
    The program is installed in folder /usr/local/bin with 4555 file
    permissions. See the discussion on security for more information about file
    permissions. The main source code is located in folder ./serial. See the
    int6kuart man page for more information.

int6kwait

    A command line utility that polls the local powerline device and waits for
    the bootloader or runtime firmware to either stop executing or start
    executing or wait for a device to associate with another device. It can be
    used to synchronize scripts with device or network events such as
    connection make or break, power on or off and firmware stop or start. This
    program is installed in folder /usr/local/bin with 4555 file permissions.
    See the discussion on security for more information about file permissions.
    The main source code is located in folder ./plc. See the int6kwait man page
    for more information.

INT6400 Device Monitoring

int6klog

    A command line utility that exports the runtime watchdog report in binary
    or XML format. Output is suitable for input to the Atheros Windows Device
    Manager. This program is installed in folder /usr/local/bin with 4555 file
    permissions. See the discussion on security for more information about file
    permissions. The main source code is located in folder ./plc. See the
    int6klog man page for more information.

int6krate

    A command line utility that polls a device and prints the average transmit
    and receive PHY rates between it and each of it's network neighbors.
    Program output is suitable for loading into a spreadsheet or other program
    that can process column-oriented information. This program is installed in
    folder /usr/local/bin with 4555 file permissions. See the discussion on
    security for more information about file permissions. The main source code
    is located in folder ./plc. See the int6krate man page for more
    information.

    This program is suitable for use with INT6x00 chipsets but not AR7x00
    chipsets due to higher PHY rates. Use program amprate for AR7x00 chipsets
    and plcrate for mixed chipset environments.

int6kstat

    A command line utility that polls a poserline device and prints various
    network and link statistics in a format suitable for processing by another
    program. It is a work in progress because we are investigating different
    ways to present the information. This program is installed in folder /usr/
    local/bin with 4555 file permissions. See the discussion on security for
    more information about file permissions. The main source code is located in
    folder ./plc. See the int6kstat man page for more information.

AR7400 Device Management

The programs in this group are essentially identical to those in the INT6x00
group but they support higher PHY data rates offered by the AR7x00 chipsets.
Specifically, they handle the new VS_NW_INFO and VS_LNK_STATS message formats.

ampboot

    This program is installed in folder /usr/local/bin with 4555 file
    permissions. See the discussion on security for more information about file
    permissions. The main source code is located in folder ./plc. See the
    ampboot man page for more information.

amphost

    This program is installed in folder /usr/local/bin with 4555 file
    permissions. See the discussion on security for more information about file
    permissions. The main source code is located in folder ./plc. See the
    amphost man page for more information.

ampinit

    This program is installed in folder /usr/local/bin with 4555 file
    permissions. See the discussion on security for more information about file
    permissions. The main source code is located in folder ./plc. See the
    ampinit man page for more information.

amplist

    This program is installed in folder /usr/local/bin with 4555 file
    permissions. See the discussion on security for more information about file
    permissions. The main source code is located in folder ./plc. See the
    amplist man page for more information.

amptest

    A command line utility that downloads and executes program images stored in
    an Atheros .nvm file. It can be used to download and execute special
    Atheros hardware diagnostic programs. It is not intended to download and
    start runtime firmware. The program is installed in folder /usr/local/bin
    with 4555 file permissions. See the discussion on security for more
    information about file permissions. The main source code is located in
    folder ./plc. See the amptest man page for more information.

amptool

    This program is installed in folder /usr/local/bin with 4555 file
    permissions. See the discussion on security for more information about file
    permissions. The main source code is located in folder ./plc. See the
    amptool man page for more information.

ampwait

    This program is installed in folder /usr/local/bin with 4555 file
    permissions. See the discussion on security for more information about file
    permissions. The main source code is located in folder ./plc. See the
    ampwait man page for more information.

AR7400 Device Monitoring

The programs in this group are essentially identical to those in the INT6x00
group but they support higher PHY data rates offered by the AR7x00 chipsets.
Specifically, they handle the new VS_NW_INFO and VS_LNK_STATS message formats.

amprate

    A command line utility that polls a device and prints the average transmit
    and receive PHY rates between it and each of it's network neighbors.
    Program output is suitable for loading into a spreadsheet or other program
    that can process column-oriented information. This program is installed in
    folder /usr/local/bin with 4555 file permissions. See the discussion on
    security for more information about file permissions. The main source code
    is located in folder ./plc. See the amprate man page for more information.

    This program is suitable for use with AR7x00 chipsets and later that have
    higher PHY rates and newer firmware. Use program int6krate for AR6x00
    running earlier runtime firmware that may not recognize newer message
    formats. Use program plcrate for mixed chipset environments

ampsnif

    Enables or disables the powerline sniffer mode on the local powerline
    device using the VS_SNIFFER message. Use program ampsnot to display and/or
    record sniffer output. This program is installed in folder /usr/local/bin
    with 4555 file permissions. See the discussion on security for more
    information about file permissions. The main source code is located in
    folder ./plc. See the ampsnif man page for more information.

ampsnot

    Listens for sniffer output from the local powerline device and display
    results on the console. Use program ampsnif to enable or disable sniffer
    output. This program is installed in folder /usr/local/bin with 4555 file
    permissions. See the discussion on security for more information about file
    permissions. The main source code is located in folder ./plc. See the
    ampsnot man page for more information.

ampstat

    This program is installed in folder /usr/local/bin with 4555 file
    permissions. See the discussion on security for more information about file
    permissions. The main source code is located in folder ./plc. See the
    ampstat man page for more information.

amptone

    This program is installed in folder /usr/local/bin with 4555 file
    permissions. See the discussion on security for more information about file
    permissions. The main source code is located in folder ./plc. See the
    amptone man page for more information.

mdustats

    A command line utility to collect and display various MDU traffic
    statistics. This program is installed in folder /usr/local/bin with 0555
    file permissions. The main source code is located in folder ./plc. See the
    mdustats man page for more information.

AR7420 Device Configuration

Programs in this group understand changes to .nvm file formats and to the
device boot and memory flash messages and sequences.

plchost

    This program is installed in folder /usr/local/bin with 4555 file
    permissions. See the discussion on security for more information about file
    permissions. The main source code is located in folder ./plc. See the
    plchost man page for more information.

plcrate

    A command line utility that downloads and executes program images stored in
    either older or newer .nvm files. It can be used to download and execute
    special powerline hardware diagnostic programs. It is not intended to
    download and start runtime firmware. The program is installed in folder /
    usr/local/bin with 4555 file permissions. See the discussion on security
    for more information about file permissions. The main source code is
    located in folder ./plc. See the amptest man page for more information.

plctest

    A command line utility that downloads and executes program images stored in
    older and newer .nvm files. It can be used to download and execute special
    powerline hardware diagnostic programs. It is not intended to download and
    start runtime firmware. The program is installed in folder /usr/local/bin
    with 4555 file permissions. See the discussion on security for more
    information about file permissions. The main source code is located in
    folder ./plc. See the amptest man page for more information.

    This program automatically detects the type of .nvm file format and adapts.

Parameter File Management

Programs in this group are used to inspect and change .pib files in various
ways. The do not communicate directly with the powerline device. Use program
int6k, amptool or plctool to read the PIB from a powerline device or write a
PIB to the powerline device.

chkpib

    A command line utility to validate .pib files based on their internal
    checksum, file size and other characteristics. It can also be used to
    produce a text catalog of .pib files. This program is slower than program
    chkpib2 but requires less memory to execute. This program is installed in
    folder /usr/local/bin with 0555 file permissions. The main source code is
    located in folder ./pib. See the chkpib man page for more information.

chkpib2

    A command line utility to validate .pib files based on their internal
    checksum, file size and other characteristics. It can also be used to
    produce a text catalog of .pib files. This program is faster than program
    chkpib but requires more memory to execute. This program is installed in
    folder /usr/local/bin with 0555 file permissions. The main source code is
    located in folder ./pib. See the chkpib2 man page for more information.

getpib

    A free-form means of extracting paremeters from a PIB file when the offset,
    length and format of the parameter is known. It is a companion to program
    setpib. The user specifies the filename, a starting offset and a sequence
    of type/data pairs. Values are echoed in order on the console in the
    specified format. This program is installed in folder /usr/local/bin with
    0555 file permissions. The main source code is located in folder ./pib. See
    the getpib man page for more information.

modpib

    A command line utility to change the MAC, DAK and/or NMK of an existing PIB
    file and recompute the checksum. It can also be used to change the
    manufacturer string, network name and username strings. This program is
    installed in folder /usr/local/bin with 0555 file permissions. The main
    source code is located in folder ./pib. See the modpib man page for more
    information.

mrgpib

    A command line utility that transfers parameters from one PIB file to
    another. The two files needs not have the same PIB version. This program is
    installed in folder /usr/local/bin with 0555 file permissions. The main
    source code is located in folder ./pib. See the mrgpib man page for more
    information.

pib2xml

    An offset-driven XML dump utility for the PIB. It requires an offset
    description file to be useful. The user specifies an offset description
    file and a PIB file. The program output an XML description of PIB fields.
    An example file, piboffset.txt, is included as a basic example. The example
    offset description file is intentionally incomplete. Complete files are
    reserved for use by Atheros Field Application Engineers. This program is an
    alternative to program pibdump. The main source code is located in folder .
    /tools. See the pib2xml man page for more information.

pibcomp

    An offset-driven binary file compare utility for the PIB. It requires an
    offset description file to be useful. The user specifies an offset
    description file and two binary files. The files are compared, field by
    field, and differences are printed on stdout, field by field. An example
    file, piboffset.txt, is included as a basic example. The example offset
    description file is intentionally incomplete. Complete files are reserved
    for use by Atheros Field Application Engineers. This program is an
    alternative to program pib2xml and a companion to program pibdump. The main
    source code is located in folder ./tools. See the pibcomp man page for more
    information.

pibdump

    An offset-driven dump utility for the PIB. It requires an offset
    description file to be useful. An example file, piboffset.txt, is included
    as a basic example. The example offset description file is intentionally
    incomplete. Complete files are reserved for use by Atheros Field
    Application Engineers. This program is a companion to program pibcomp. The
    main source code is located in folder ./tools. See the pibdump man page for
    more information.

pibruin

    A command line utility that inserts classifier rules, read from a file,
    into a PIB file. It is an alternative to program int6krule and companion to
    program pibrump. The main source code is located in folder ./pib. See the
    pibruin man page for more information.

    This program supports INT6300, INT6400 and AR7400 PIBs only and is
    deprecated.

pibrump

    A command line utility that reads classifier rules from a PIB file and
    prints them on stdout in a format suitable for input to program pibruin.
    The main source code is located in folder ./pib. See the pibrump man page
    for more information.

psin

    A command line utility to insert an amplitude map into an existing PIB
    file. The map is read from stdin in text format allowing the output of
    program psout to be piped directly into this program. The main source code
    is located in folder ./pib. See the psin man page for more information.

psout

    A command line utility to that exports an amplitude map stored in an
    existing PIB file. The map is written directly to stdin in text format
    allowing the output of this program to be piped into the input of program
    psin. The main source code is located in folder ./pib. See the psout man
    page for more information.

pxe

    A generic 'Remote PIB Management' tool. One or more XML files define
    decimal, hexadecimal and string edits to be applied to a PIB file. The PIB
    is read, edits are applied, a new checksum is computed and the PIB is
    saved. This program is installed in folder /usr/local/bin with 0555 file
    permissions. The main source code is located in folder ./pib. See the pxe
    man page for more information.

setpib

    A simple means of setting PIB parameters when the parameter offset, length
    and format are known. It is an alternative to program pxe and a companion
    to program getpib. The user specifies the filename, a starting offset and a
    sequence of type/data pairs. Edits are applied in order and a new checksum
    is computed. A full or partial dump of the PIB displays the result. This
    program is installed in folder /usr/local/bin with 0555 file permissions.
    The main source code is located in folder ./pib. See the setpib man page
    for more information.

Firmware File Management

chknvm

    A command line utility to validate .nvm files based on their internal
    checksum, file size and other characteristics. This program is slower than
    program chknvm2 but requires less memory to execute. Optionally, it can be
    used to display the image headers inside the file. This program is
    installed in folder /usr/local/bin with 0555 file permissions. The main
    source code is located in folder ./nvm. See the chknvm man page for more
    information.

chknvm2

    A command line utility to validate .nvm files based on their internal
    checksum, file size and other characteristics. Optionally, it can be used
    to display the image headers inside the file. This program is faster than
    program chknvm but requires more memory to execute. This program is
    installed in folder /usr/local/bin with 0555 file permissions. The main
    source code is located in folder ./nvm. See the chknvm2 man page for more
    information.

config2cfg

    A command line utility to convert an SDRAM configruation file used by the
    Atheros Windows Device Manager to the configuration file format used by the
    Powerline Toolkit applications. This program is installed in folder /usr/
    local/bin with 0555 file permissions. The main source code is located in
    folder ./sdram. See the config2cfg man page for more information.

nvmmerge

    A command line utility to combine multiple Atheros image files into one. It
    is reserved for use by Atheros Field Application Engineers. Use of this
    probram could void some contractual obligations made by Atheros. This
    program is installed in folder /usr/local/bin with 0555 file permissions.
    The main source code is located in folder ./nvm. See the nvmmerge man page
    for more information.

nvmsplit

    A command line utility to extract all constituent images from an Atheros
    image file. It is reserved for use by Atheros Field Application Engineers.
    Use of this probram could void some contractual obligations made by
    Atheros. This program is installed in folder /usr/local/bin with 0555 file
    permissions. The main source code is located in folder ./nvm. See the
    nvmsplit man page for more information.

Ethernet Traffic

edru

    A command line program that reads one or more Ethernet II (IEEE 802.2)
    frames and write frame data to stdout as a continuous stream. This program
    can be used to capture serial data sent from a remote UART-enabled
    powerline device. This program is installed in folder /usr/local/bin with
    4555 file permissions. See the discussion on security for more information
    about file permissions. The main source code is located in folder ./ether.
    See the edru man page for more information.

edsu

    A command line program sends one or more files over the network using
    Ethernet II (IEEE 802.2) Frames. This program can be used to test remote
    UART-enabled powerline devices. This program is installed in folder /usr/
    local/bin with 4555 file permissions. See the discussion on security for
    more information about file permissions. The main source code is located in
    folder ./ether. See the edsu man page for more information.

efsu

    A freeform Ethernet frame send utility used to define and send Ethernet
    packets. Packets are defined in text files containing hexadecimal byte
    codes plus optional comments and whitespace. Input files are stripped of
    comments and whitespace then transmitted as Ethernet frames. This program
    is installed in folder /usr/local/bin with 4555 file permissions. See the
    discussion on security for more information about file permissions. The
    main source code is located in folder ./ether. See the efsu man page for
    more information.

hpav

    A basic HomePlug® AV packet sniffer that displays only HomePlug® AV
    protocol frames on the console as they are sent or arrive on a given
    interface. This program is installed in folder /usr/local/bin with 4555
    file permissions. See the discussion on security for more information about
    file permissions. The main source code is located in folder ./mme. See the
    hpav man page for more information.

pcapdevs

    A utility to enumerate LibPcap or WinPcap devices available on the host. It
    is compiled but only works if one of these two packages is installed on the
    host. At present, it is only needed with the Windows version of the Toolkit
    which is compiled against the WinPcap library. The main source code is
    located in folder ./ether. See the pcapdevs man page for more information.

Passwords and Keys

hpavkey

    A HomePlug® AV key generator. Pass phrase arguments are hashed to form the
    corresponding Device Access Key (DAK), Network Membership Key (NMK) or
    Network Identifier (NID). This program is installed in folder /usr/local/
    bin with 4555 permissions. The main source code is located in folder ./
    crypt. See the hpavkey man page for more information.

hpavkeys

    A HomePlug® AV key generator. Pass phrases are read from a file and hashed
    to form the corresponding Device Access Key (DAK), Network Membership Key
    (NMK) or Network Identifier (NID). This program is installed in folder /usr
    /local/bin with 4555 permissions. The main source code is located in folder
    ./crypt. See the hpavkeys man page for more information.

mac2pw

    A device password generator that prints a range of MAC address and
    passwords on stdout. It is an alternative to the Atheros Production Test
    System (PTS) DBBuilder Utility and toolkit program mac2pwd. This program is
    installed in folder /usr/local/bin with 4555 file permissions. See the
    discussion on security for more information about file permissions. The
    main source code is located in folder ./crypt. See the mac2pw man page for
    more information.

mac2pwd

    A device password generator that reads files containing MAC addresses and
    prints address/password pairs. It is an alternative to the Atheros
    Production Test System (PTS) DBBuilder Utility and toolkit program mac2pw.
    This program is installed in folder /usr/local/bin with 4555 file
    permissions. See the discussion on security for more information about file
    permissions. The main source code is located in folder ./crypt. See the
    mac2pwd man page for more information.

rkey

    A command line utility to dynamically generate distinct HomePlug AV
    compliant keys from a user created keyfile. It can be used in shell scripts
    to dynamically insert random and distinct keys on program command lines as
    arguments. For example, a Linux bash script can reference "$(rkey -i eth0
    -D secret.key)" inline. This program is installed in folder /usr/local/bin
    with 4555 file permissions. See the discussion on security for more
    information about file permissions. The main source code is located in
    folder ./crypt. See the rkey man page for more information.

MDIO Programming

int6kmdio

    A command line utility that uses VS_MDIO_COMMAND messages to read and write
    MDIO registers on a switch chip connected to the local powerline device.
    MDIO instructions are specified and send as Clause 22 instructions. This
    program is installed in folder /usr/local/bin with 0555 file permissions.
    The main source code is located in folder ./mdio. See the mdioblock man
    page for more information.

int6kmdio2

    A command line utility that uses VS_MDIO_COMMAND messages to read and write
    MDIO registers on a switch chip connected to the local powerline device.
    Instructions are read as Clause 45 instructions but send as Clause 22
    instructions. This program is installed in folder /usr/local/bin with 0555
    file permissions. The main source code is located in folder ./mdio. See the
    mdioblock man page for more information.

mdioblock

    A command line utility to assemble an Atheros MDIO instruction block from
    hexadecimal register instructions. MDIO instruction blocks are written to
    Atheros powerline devices as modules using the VS_MOD_OP message type. This
    program is installed in folder /usr/local/bin with 0555 file permissions.
    The main source code is located in folder ./mdio. See the mdioblock man
    page for more information.

mdioblock2

    A command line utility to assemble an Atheros MDIO instruction block from
    hexadecimal register instructions. MDIO instruction blocks are written to
    Atheros powerline devices as modules using the VS_MOD_OP message type. This
    program is installed in folder /usr/local/bin with 0555 file permissions.
    The main source code is located in folder ./mdio. See the mdioblock2 man
    page for more information.

mdiodump

    A command line utility to read and display Atheros MDIO custom modules in
    human readable format. This program is installed in folder /usr/local/bin
    with 0555 file permissions. The main source code is located in folder ./
    mdio. See the mdiodump man page for more information.

mdiogen

    A rudimentary command line utility that write a custom MDIO block to a
    fixed file. The user must edit a data statements, in the main program, to
    define MDIO command fields. A series of macros then mask, shift and merge
    the fields to create complete Clause 22 or Clause 45 MDIO commands on
    output. The program has no dependencies on other toolkit modules and so it
    will compile anywhere. This program must be manually compiled and it is not
    automatically installed. The main source code is located in folder ./mdio
    and file mdio.h is required for compilation. There are no help files
    available at this time. If you do not understand how to use it then you may
    not need it.

Serial Programming

ptsctl

    A command line program used to control a bank of three Weeder programmable
    attenuators. It may be used to construct a Production Test System (PTS) for
    Qualcomm Atheros SmartLink™ devices. See program weeder to control a bank
    of two Weeder programmable attenuators. This program is installed in folder
    /usr/local/bin with 0555 file permissions. The main source code is located
    in folder ./serial. See the ptsctl man page for more information.

ttycat

    A command line program that copies one or more host files to a specific
    serial port. It can be used to stream serial data to the local UART-enabled
    powerline device for transmission over powerline. This program is installed
    in folder /usr/local/bin with 0555 file permissions. The main source code
    is located in folder ./serial. See the ttycat man page for more
    information.

weeder

    A command line program used to control a bank of two Weeder programmable
    attenuators. It may be used to construct a Production Test System (PTS) for
    Qualcomm Atheros powerline devices. See program ptsctl to control a bank of
    three Weeder programmable attenuators. This program is installed in folder
    /usr/local/bin with 0555 file permissions. The main source code is located
    in folder ./serial. See the weeder man page for more information.

Atheros Communications reserves the right to add, remove or rename utility
programs or modify their command line options or their functionality in future
software releases without any obligation to notify or compensate users of this
software.

Toolkit Folders

The Atheros Powerline Toolkit package folder has many subfolders. Some contain
source code, some contain documentation and others contain shell scripts. Some
source folders contain programs that require components in neighboring folders.
Consequently, you will see references to relative pathnames like ../folder,
throughout source code, makefiles and shell scripts. This notation simplifies
development and maintenance and is helpful when locating specific files.

Folder descriptions appear below in alphabetical order:

./applets

    A library of programs that can run, stand-alone, on Atheros powerline
    devices and perform diagnostic tests for connection, functionality and
    performance. Some run to completion and return to the Bootloader. Others
    run continuously until the device is reset. Most can be run and executed in
    sequence using program int6ktest.

./classes

    A collection of C++ classes that implement many of the ANSI C functions
    found elsewhere in the toolkit. These classes will compile and run on most
    platforms but are still a work-in-progress. The programs folder contains
    actual and sample programs that use these classes.

./docbook

    HTML pages generated by several methods, but mostly Docbook 4.5. Some pages
    have been created using special tools that are not provided and will not be
    made available. The Makefile in this folder will compile the core XML
    source files on GNU/Linux systems that have Docbook 4.5 installed with
    extentions by Normal Walsh but it does not install the pages. See
    Installation on Linux for more information.

./ether

    Network specific source code that supports raw ethernet packets in a
    platform independent fashion using plugin modules. The principle feature is
    the channel data structure used to read and write raw ethernet packets
    using network features on GNU/Linux, with or without libpcap, and on
    Windows™ with winpcap. The source code in this folder is difficult to port
    cross-platform due to the way different operating systems implement their
    system header files and network stacks.

./plc

    The main source code for programs that communicate with Qualcomm Atheros
    powerline devices over Ethernet. The programs in this folder are essential
    programs for engineers and embedded software developers wanting to explore
    powerline device behavior. The Makefile in this folder will compile and
    install programs in /usr/local/bin on GNU/Linux systems.

./mme

    A collection of helper functions dealing with HomePlug® and Atheros
    management messages. They are not needed for proper toolkit operation but
    they can be useful during development and debugging because they print
    message content in readable format. Most of these functions require extra
    memory because they include symbol tables and extra data conversion
    functions.

./nodes

    A collection of functions that comrpise a generic, light-weight XML parser.
    Atheros is currently exprimenting with various XML-based applications to
    support device management on embedded systems. These functions are the
    core. Currently, they are only used by the pxe and int6k2 programs. See XML
    Editing Functions for more information.

./nvm

    Programs, functions and make files related to Atheros NonVolatile Memory
    (NVM) files. All programs in this folder either read from or write to NVM
    files. None communicate with powerline devices. Some of the popular
    programs are chknvm, nvmsplit and nvmmerge.

./patches

    A collection of useful Linux™ kernel patches and install scripts. Of
    particular interest is the send-to-self patch that enables external routing
    of ISO Layer 3 traffic between two Ethernet interfaces on the same host.
    Atheros provides them but does not support them.

./pib

    Programs, functions and make files related to Atheros Parameter Information
    Block (PIB) files. All programs in this folder either read from or write to
    PIB files. None communicate with powerline devices. Some of the popular
    programs are chkpib, modpib, getpib and setpib.

./programs

    A small collection of sample C++ programs that use the Atheros C++
    powerline classes. These programs compile and run on most environments but
    are still a work-in-progress. Users may actually find netifs and plcnets
    useful.

./serial

    Programs, functions and make files related to the Atheros Serial
    Communication Interface for Powerline devices. All of the programs in this
    folder communicate using a host serial port. None communicate with
    powerline devices over Ethernet. The main program of interest is int6kuart.

./scripts

    Miscellaneous shell scripts that call various programs in this package to
    perform tasks such as flashing a FW2.0 device. Care must be taken here to
    ensure that environment variables at the start of each script are
    appropriate for your system.

./ram

    Support modules for reading, printing and checking NVRAM and SDRAM
    configuration files. The .cfg files in this folder have a different format
    than the .config files released with the Atheros Windows Device Manager.
    The files distributed with the Windows Device Manger are 64 ASCII character
    with no checksum. The files in this directory are 32 binary bites with
    trailing checksum. Users may create new sdram configuration files by
    compiling sdram.c, using gcc -o sdram sdram.c and running it without any
    command line arguments.

./tools

    Source code and header files used by virtually all programs in the toolkit.
    These files are generic and have application beyond this package. They
    provide GNU/Linux-style or POSIX-style functionality to programs running in
    environments that do not have either. They also implement operations like
    checksum computation and multi-byte hexadecimal encoding and decoding. See
    Support Function Reference for more information.

./VisualStudioNET

    Components unique to Microsoft Windows are kept in and under this folder.
    Specifically, it contains a Visual Studio .NET™ solution to compile most of
    the programs in this package using only Microsoft and winpcap libraries.
    Compiled .exe files can be run on Windows™ enabled systems having winpcap
    installed. Adjustments may be necessary depending on your environment.

    Microsoft does not provide full POSIX support on Windows platforms.
    Consequently, alternative headers and libraries are included under this
    folder. For example, an abridged version of unistd.h and an alternative
    version of stdint.h are included under VisualStudioNET/include. Other
    significant header files included here are ethernet.h, if_ether.h and in.h.
    Subfolder VisualStudio\Library contains WinPcap™ libraries. These folders
    are referenced in appropriate compiler and linker options for Microsoft
    Development environments.

Packages

The following table lists programs and the release packages that contains them.
Packages contain programs of interest to various customer and engineering
groups based on the activities that they normally perform. Som groups may need
multiple packages. Some packages are restricted.

Table 1.1.  Program/Package Matrix

The toolkit is divided into 5 groups loosely based on chipset family, intended
audience, network security, intellectual property, code maturity and other
criteria. Som individual programs may be hard to classify and so their
placement may be subject to some debate.

amp-utils
    Tools developed for INT6000™, INT6300™, INT6400™ and AR7400™ chipsets. Some
    are obsolete but most are still useful. This package is a candidate for
    public distribution under a permissive open source license.
plc-utils
    Tools developed for QCA6410™, QCA7000™ and AR7420™ chipsets. These tools
    handle the newer files formats, hardware boot conventsions and flash memory
    layouts for chipsets having fixed internal SRAM. This package is a
    candidate for public distribution under a permissive open source license.
nda-utils
    Tools designed to manipulate parameter blocks or access reserved or
    restricted features on powerline devices. Most are useful during powerline
    product development and production but are not needed for proper product
    operation or maintenance. This package is reserved for Qualcomm Atheros
    customers who sign a non-disclosure agreement covering Qualcomm Atheros
    intellectual property. Parts of this package are candidates for some sort
    of restrictive license.
key-utils
    Tools that generate HomePlug AV compliant keys from device MAC address or
    user passwords. This package is reserved for Qualcomm Atheros customers who
    sign a non-disclosure agreement related to Qualcomm Atheros powerline
    intellectual property. Parts of this package are candidates for some sort
    of restrictive license.
qca-utils
    Tools that perform restricted or experiemental operations on active
    powerline devices or parameter information blocks. Some of these tools here
    are one-of-a-kind or could present security risks to active powerline
    networks. This package not not released to customers. It is reserved for
    Qualcomm Atheros PLC Engineering use. Most of this package is a candidate
    for restrictive license.

┌───────────┬─────────┬─────────┬─────────┬─────────┬─────────┬───────────┬──────────┐
│  Program  │amp-utils│plc-utils│nda-utils│key-utils│qca-utils│source-only│deprecated│
├───────────┼─────────┼─────────┼─────────┼─────────┼─────────┼───────────┼──────────┤
│CMEncrypt  │amp-utils│plc-utils│         │         │qca-utils│           │          │
├───────────┼─────────┼─────────┼─────────┼─────────┼─────────┼───────────┼──────────┤
│adccap     │         │         │         │         │qca-utils│           │          │
├───────────┼─────────┼─────────┼─────────┼─────────┼─────────┼───────────┼──────────┤
│ampagc     │         │         │         │         │qca-utils│           │          │
├───────────┼─────────┼─────────┼─────────┼─────────┼─────────┼───────────┼──────────┤
│ampboot    │amp-utils│         │         │         │qca-utils│           │          │
├───────────┼─────────┼─────────┼─────────┼─────────┼─────────┼───────────┼──────────┤
│amphost    │amp-utils│         │         │         │qca-utils│           │          │
├───────────┼─────────┼─────────┼─────────┼─────────┼─────────┼───────────┼──────────┤
│ampinit    │         │         │nda-utils│         │qca-utils│           │          │
├───────────┼─────────┼─────────┼─────────┼─────────┼─────────┼───────────┼──────────┤
│ampID      │amp-utils│         │         │         │qca-utils│           │          │
├───────────┼─────────┼─────────┼─────────┼─────────┼─────────┼───────────┼──────────┤
│amplist    │amp-utils│         │         │         │qca-utils│           │          │
├───────────┼─────────┼─────────┼─────────┼─────────┼─────────┼───────────┼──────────┤
│amprate    │amp-utils│         │         │         │qca-utils│           │          │
├───────────┼─────────┼─────────┼─────────┼─────────┼─────────┼───────────┼──────────┤
│ampsnr     │         │         │         │         │qca-utils│           │          │
├───────────┼─────────┼─────────┼─────────┼─────────┼─────────┼───────────┼──────────┤
│ampstat    │amp-utils│         │         │         │qca-utils│           │          │
├───────────┼─────────┼─────────┼─────────┼─────────┼─────────┼───────────┼──────────┤
│amptest    │amp-utils│         │         │         │qca-utils│           │          │
├───────────┼─────────┼─────────┼─────────┼─────────┼─────────┼───────────┼──────────┤
│amptone    │amp-utils│         │         │         │qca-utils│           │          │
├───────────┼─────────┼─────────┼─────────┼─────────┼─────────┼───────────┼──────────┤
│amptool    │amp-utils│         │         │         │qca-utils│           │          │
├───────────┼─────────┼─────────┼─────────┼─────────┼─────────┼───────────┼──────────┤
│ampwait    │amp-utils│         │         │         │qca-utils│           │          │
├───────────┼─────────┼─────────┼─────────┼─────────┼─────────┼───────────┼──────────┤
│arpc       │         │         │         │         │qca-utils│           │          │
├───────────┼─────────┼─────────┼─────────┼─────────┼─────────┼───────────┼──────────┤
│arpc1      │         │         │         │         │qca-utils│           │          │
├───────────┼─────────┼─────────┼─────────┼─────────┼─────────┼───────────┼──────────┤
│chknvm     │amp-utils│plc-utils│nda-utils│         │qca-utils│           │          │
├───────────┼─────────┼─────────┼─────────┼─────────┼─────────┼───────────┼──────────┤
│chknvm2    │amp-utils│plc-utils│nda-utils│         │qca-utils│           │          │
├───────────┼─────────┼─────────┼─────────┼─────────┼─────────┼───────────┼──────────┤
│chkpib     │amp-utils│plc-utils│nda-utils│         │qca-utils│           │          │
├───────────┼─────────┼─────────┼─────────┼─────────┼─────────┼───────────┼──────────┤
│chkpib2    │amp-utils│plc-utils│nda-utils│         │qca-utils│           │          │
├───────────┼─────────┼─────────┼─────────┼─────────┼─────────┼───────────┼──────────┤
│config2cfg │         │         │         │         │         │source-only│          │
├───────────┼─────────┼─────────┼─────────┼─────────┼─────────┼───────────┼──────────┤
│coqos_add  │         │         │         │         │qca-utils│           │          │
├───────────┼─────────┼─────────┼─────────┼─────────┼─────────┼───────────┼──────────┤
│coqos_info │         │         │         │         │qca-utils│           │          │
├───────────┼─────────┼─────────┼─────────┼─────────┼─────────┼───────────┼──────────┤
│coqos_man  │         │         │         │         │qca-utils│           │          │
├───────────┼─────────┼─────────┼─────────┼─────────┼─────────┼───────────┼──────────┤
│coqos_mod  │         │         │         │         │qca-utils│           │          │
├───────────┼─────────┼─────────┼─────────┼─────────┼─────────┼───────────┼──────────┤
│coqos_rel  │         │         │         │         │qca-utils│           │          │
├───────────┼─────────┼─────────┼─────────┼─────────┼─────────┼───────────┼──────────┤
│dlinkug    │         │         │         │         │qca-utils│           │          │
├───────────┼─────────┼─────────┼─────────┼─────────┼─────────┼───────────┼──────────┤
│edru       │amp-utils│         │         │         │qca-utils│           │          │
├───────────┼─────────┼─────────┼─────────┼─────────┼─────────┼───────────┼──────────┤
│edsu       │amp-utils│         │         │         │qca-utils│           │          │
├───────────┼─────────┼─────────┼─────────┼─────────┼─────────┼───────────┼──────────┤
│efbu       │amp-utils│plc-utils│         │         │qca-utils│           │          │
├───────────┼─────────┼─────────┼─────────┼─────────┼─────────┼───────────┼──────────┤
│efeu       │         │         │         │         │qca-utils│           │          │
├───────────┼─────────┼─────────┼─────────┼─────────┼─────────┼───────────┼──────────┤
│efru       │         │         │         │         │qca-utils│           │          │
├───────────┼─────────┼─────────┼─────────┼─────────┼─────────┼───────────┼──────────┤
│efsu       │amp-utils│plc-utils│         │         │qca-utils│           │          │
├───────────┼─────────┼─────────┼─────────┼─────────┼─────────┼───────────┼──────────┤
│fetchpib   │         │         │         │         │         │source-only│          │
├───────────┼─────────┼─────────┼─────────┼─────────┼─────────┼───────────┼──────────┤
│getpib     │         │         │nda-utils│         │qca-utils│           │          │
├───────────┼─────────┼─────────┼─────────┼─────────┼─────────┼───────────┼──────────┤
│grab       │         │         │         │         │qca-utils│           │          │
├───────────┼─────────┼─────────┼─────────┼─────────┼─────────┼───────────┼──────────┤
│hpav       │         │         │nda-utils│         │qca-utils│           │          │
├───────────┼─────────┼─────────┼─────────┼─────────┼─────────┼───────────┼──────────┤
│hpavkey    │         │         │nda-utils│key-utils│qca-utils│           │          │
├───────────┼─────────┼─────────┼─────────┼─────────┼─────────┼───────────┼──────────┤
│hpavkeys   │         │         │nda-utils│key-utils│qca-utils│           │          │
├───────────┼─────────┼─────────┼─────────┼─────────┼─────────┼───────────┼──────────┤
│int64host  │amp-utils│         │         │         │qca-utils│           │          │
├───────────┼─────────┼─────────┼─────────┼─────────┼─────────┼───────────┼──────────┤
│int6k      │amp-utils│         │         │         │qca-utils│           │          │
├───────────┼─────────┼─────────┼─────────┼─────────┼─────────┼───────────┼──────────┤
│int6kbaud  │amp-utils│         │         │         │qca-utils│           │          │
├───────────┼─────────┼─────────┼─────────┼─────────┼─────────┼───────────┼──────────┤
│int6kboot  │amp-utils│         │         │         │qca-utils│           │          │
├───────────┼─────────┼─────────┼─────────┼─────────┼─────────┼───────────┼──────────┤
│int6kdetect│amp-utils│         │         │         │qca-utils│           │          │
├───────────┼─────────┼─────────┼─────────┼─────────┼─────────┼───────────┼──────────┤
│int6kecho  │         │         │nda-utils│         │qca-utils│           │          │
├───────────┼─────────┼─────────┼─────────┼─────────┼─────────┼───────────┼──────────┤
│int6keth   │         │         │nda-utils│         │qca-utils│           │          │
├───────────┼─────────┼─────────┼─────────┼─────────┼─────────┼───────────┼──────────┤
│int6khost  │         │         │         │         │qca-utils│           │deprecated│
├───────────┼─────────┼─────────┼─────────┼─────────┼─────────┼───────────┼──────────┤
│int6kid    │amp-utils│         │         │         │qca-utils│           │          │
├───────────┼─────────┼─────────┼─────────┼─────────┼─────────┼───────────┼──────────┤
│int6klist  │amp-utils│         │         │         │qca-utils│           │          │
├───────────┼─────────┼─────────┼─────────┼─────────┼─────────┼───────────┼──────────┤
│int6klog   │amp-utils│         │         │         │qca-utils│           │          │
├───────────┼─────────┼─────────┼─────────┼─────────┼─────────┼───────────┼──────────┤
│int6kmdio  │amp-utils│         │         │         │         │           │deprecated│
├───────────┼─────────┼─────────┼─────────┼─────────┼─────────┼───────────┼──────────┤
│int6kmdio2 │amp-utils│         │         │         │         │           │deprecated│
├───────────┼─────────┼─────────┼─────────┼─────────┼─────────┼───────────┼──────────┤
│int6kmod   │amp-utils│         │nda-utils│         │qca-utils│           │          │
├───────────┼─────────┼─────────┼─────────┼─────────┼─────────┼───────────┼──────────┤
│int6kp     │         │         │nda-utils│         │qca-utils│           │          │
├───────────┼─────────┼─────────┼─────────┼─────────┼─────────┼───────────┼──────────┤
│int6kpair  │         │         │         │         │qca-utils│           │          │
├───────────┼─────────┼─────────┼─────────┼─────────┼─────────┼───────────┼──────────┤
│int6kprobe │         │         │nda-utils│         │qca-utils│           │          │
├───────────┼─────────┼─────────┼─────────┼─────────┼─────────┼───────────┼──────────┤
│int6krate  │amp-utils│         │         │         │qca-utils│           │          │
├───────────┼─────────┼─────────┼─────────┼─────────┼─────────┼───────────┼──────────┤
│int6krule  │amp-utils│         │         │         │qca-utils│           │          │
├───────────┼─────────┼─────────┼─────────┼─────────┼─────────┼───────────┼──────────┤
│int6kstat  │amp-utils│         │         │         │qca-utils│           │          │
├───────────┼─────────┼─────────┼─────────┼─────────┼─────────┼───────────┼──────────┤
│int6ktest  │amp-utils│         │         │         │qca-utils│           │          │
├───────────┼─────────┼─────────┼─────────┼─────────┼─────────┼───────────┼──────────┤
│int6ktone  │amp-utils│         │         │         │qca-utils│           │          │
├───────────┼─────────┼─────────┼─────────┼─────────┼─────────┼───────────┼──────────┤
│int6kuart  │amp-utils│         │         │         │qca-utils│           │          │
├───────────┼─────────┼─────────┼─────────┼─────────┼─────────┼───────────┼──────────┤
│int6kug    │         │         │         │         │qca-utils│           │          │
├───────────┼─────────┼─────────┼─────────┼─────────┼─────────┼───────────┼──────────┤
│int6kwait  │amp-utils│         │         │         │qca-utils│           │          │
├───────────┼─────────┼─────────┼─────────┼─────────┼─────────┼───────────┼──────────┤
│mac2pw     │         │         │nda-utils│key-utils│qca-utils│           │          │
├───────────┼─────────┼─────────┼─────────┼─────────┼─────────┼───────────┼──────────┤
│mac2pwd    │         │         │nda-utils│key-utils│qca-utils│           │          │
├───────────┼─────────┼─────────┼─────────┼─────────┼─────────┼───────────┼──────────┤
│mdioblock  │         │         │nda-utils│         │qca-utils│           │          │
├───────────┼─────────┼─────────┼─────────┼─────────┼─────────┼───────────┼──────────┤
│mdioblock2 │         │         │nda-utils│         │qca-utils│           │          │
├───────────┼─────────┼─────────┼─────────┼─────────┼─────────┼───────────┼──────────┤
│mdiodump   │         │         │nda-utils│         │qca-utils│           │          │
├───────────┼─────────┼─────────┼─────────┼─────────┼─────────┼───────────┼──────────┤
│mdustats   │amp-utils│         │         │         │qca-utils│           │          │
├───────────┼─────────┼─────────┼─────────┼─────────┼─────────┼───────────┼──────────┤
│mme        │         │         │nda-utils│         │qca-utils│           │          │
├───────────┼─────────┼─────────┼─────────┼─────────┼─────────┼───────────┼──────────┤
│modpib     │amp-utils│plc-utils│nda-utils│         │qca-utils│           │          │
├───────────┼─────────┼─────────┼─────────┼─────────┼─────────┼───────────┼──────────┤
│mrgpib     │         │         │         │         │qca-utils│           │          │
├───────────┼─────────┼─────────┼─────────┼─────────┼─────────┼───────────┼──────────┤
│netifs     │amp-utils│plc-utils│nda-utils│         │qca-utils│           │          │
├───────────┼─────────┼─────────┼─────────┼─────────┼─────────┼───────────┼──────────┤
│nvmmerge   │         │         │nda-utils│         │qca-utils│           │          │
├───────────┼─────────┼─────────┼─────────┼─────────┼─────────┼───────────┼──────────┤
│nvmsplit   │         │         │nda-utils│         │qca-utils│           │          │
├───────────┼─────────┼─────────┼─────────┼─────────┼─────────┼───────────┼──────────┤
│odc        │         │         │         │         │         │           │deprecated│
├───────────┼─────────┼─────────┼─────────┼─────────┼─────────┼───────────┼──────────┤
│odd        │         │         │         │         │         │           │deprecated│
├───────────┼─────────┼─────────┼─────────┼─────────┼─────────┼───────────┼──────────┤
│odx        │         │         │         │         │         │           │deprecated│
├───────────┼─────────┼─────────┼─────────┼─────────┼─────────┼───────────┼──────────┤
│pcapdevs   │amp-utils│plc-utils│nda-utils│         │qca-utils│           │          │
├───────────┼─────────┼─────────┼─────────┼─────────┼─────────┼───────────┼──────────┤
│pib2xml    │         │         │nda-utils│         │qca-utils│           │          │
├───────────┼─────────┼─────────┼─────────┼─────────┼─────────┼───────────┼──────────┤
│pibcomp    │         │         │nda-utils│         │qca-utils│           │          │
├───────────┼─────────┼─────────┼─────────┼─────────┼─────────┼───────────┼──────────┤
│pibdump    │         │         │nda-utils│         │qca-utils│           │          │
├───────────┼─────────┼─────────┼─────────┼─────────┼─────────┼───────────┼──────────┤
│pibruin    │         │         │nda-utils│         │qca-utils│           │          │
├───────────┼─────────┼─────────┼─────────┼─────────┼─────────┼───────────┼──────────┤
│pibrump    │         │         │nda-utils│         │qca-utils│           │          │
├───────────┼─────────┼─────────┼─────────┼─────────┼─────────┼───────────┼──────────┤
│plcboot    │         │plc-utils│         │         │qca-utils│           │          │
├───────────┼─────────┼─────────┼─────────┼─────────┼─────────┼───────────┼──────────┤
│plcecho    │         │         │nda-utils│         │qca-utils│           │          │
├───────────┼─────────┼─────────┼─────────┼─────────┼─────────┼───────────┼──────────┤
│plcfwd     │amp-utils│plc-utils│         │         │qca-utils│           │          │
├───────────┼─────────┼─────────┼─────────┼─────────┼─────────┼───────────┼──────────┤
│plcget     │amp-utils│plc-utils│         │         │qca-utils│           │          │
├───────────┼─────────┼─────────┼─────────┼─────────┼─────────┼───────────┼──────────┤
│plchost    │         │plc-utils│         │         │qca-utils│           │          │
├───────────┼─────────┼─────────┼─────────┼─────────┼─────────┼───────────┼──────────┤
│plcId      │         │plc-utils│         │         │qca-utils│           │          │
├───────────┼─────────┼─────────┼─────────┼─────────┼─────────┼───────────┼──────────┤
│plcinit    │         │         │nda-utils│         │qca-utils│           │          │
├───────────┼─────────┼─────────┼─────────┼─────────┼─────────┼───────────┼──────────┤
│plclist    │         │plc-utils│         │         │qca-utils│           │          │
├───────────┼─────────┼─────────┼─────────┼─────────┼─────────┼───────────┼──────────┤
│plcm       │         │         │         │         │qca-utils│           │          │
├───────────┼─────────┼─────────┼─────────┼─────────┼─────────┼───────────┼──────────┤
│plcmmcinfo │         │         │nda-utils│         │qca-utils│           │          │
├───────────┼─────────┼─────────┼─────────┼─────────┼─────────┼───────────┼──────────┤
│plcmdio16  │         │plc-utils│         │         │qca-utils│           │          │
├───────────┼─────────┼─────────┼─────────┼─────────┼─────────┼───────────┼──────────┤
│plcmdio32  │         │plc-utils│         │         │qca-utils│           │          │
├───────────┼─────────┼─────────┼─────────┼─────────┼─────────┼───────────┼──────────┤
│plcmod     │         │         │nda-utils│         │qca-utils│           │          │
├───────────┼─────────┼─────────┼─────────┼─────────┼─────────┼───────────┼──────────┤
│plcnets    │amp-utils│plc-utils│         │         │qca-utils│           │          │
├───────────┼─────────┼─────────┼─────────┼─────────┼─────────┼───────────┼──────────┤
│plcrate    │         │plc-utils│         │         │qca-utils│           │          │
├───────────┼─────────┼─────────┼─────────┼─────────┼─────────┼───────────┼──────────┤
│plcrule    │         │plc-utils│         │         │qca-utils│           │          │
├───────────┼─────────┼─────────┼─────────┼─────────┼─────────┼───────────┼──────────┤
│plcset     │amp-utils│plc-utils│         │         │qca-utils│           │          │
├───────────┼─────────┼─────────┼─────────┼─────────┼─────────┼───────────┼──────────┤
│plcstat    │         │plc-utils│         │         │qca-utils│           │          │
├───────────┼─────────┼─────────┼─────────┼─────────┼─────────┼───────────┼──────────┤
│plcsnif    │         │         │         │         │qca-utils│           │          │
├───────────┼─────────┼─────────┼─────────┼─────────┼─────────┼───────────┼──────────┤
│plctest    │         │plc-utils│         │         │qca-utils│           │          │
├───────────┼─────────┼─────────┼─────────┼─────────┼─────────┼───────────┼──────────┤
│plctone    │         │plc-utils│         │         │qca-utils│           │          │
├───────────┼─────────┼─────────┼─────────┼─────────┼─────────┼───────────┼──────────┤
│plctool    │         │plc-utils│         │         │qca-utils│           │          │
├───────────┼─────────┼─────────┼─────────┼─────────┼─────────┼───────────┼──────────┤
│plcwait    │         │plc-utils│         │         │qca-utils│           │          │
├───────────┼─────────┼─────────┼─────────┼─────────┼─────────┼───────────┼──────────┤
│po1        │         │         │         │         │qca-utils│           │          │
├───────────┼─────────┼─────────┼─────────┼─────────┼─────────┼───────────┼──────────┤
│po2        │         │         │         │         │qca-utils│           │          │
├───────────┼─────────┼─────────┼─────────┼─────────┼─────────┼───────────┼──────────┤
│psgen      │         │         │nda-utils│         │qca-utils│           │          │
├───────────┼─────────┼─────────┼─────────┼─────────┼─────────┼───────────┼──────────┤
│psin       │         │         │nda-utils│         │qca-utils│           │          │
├───────────┼─────────┼─────────┼─────────┼─────────┼─────────┼───────────┼──────────┤
│pskey      │         │         │nda-utils│         │qca-utils│           │          │
├───────────┼─────────┼─────────┼─────────┼─────────┼─────────┼───────────┼──────────┤
│psnotch    │         │         │nda-utils│         │qca-utils│           │          │
├───────────┼─────────┼─────────┼─────────┼─────────┼─────────┼───────────┼──────────┤
│psout      │         │         │nda-utils│         │qca-utils│           │          │
├───────────┼─────────┼─────────┼─────────┼─────────┼─────────┼───────────┼──────────┤
│ptsctl     │         │         │nda-utils│         │qca-utils│           │          │
├───────────┼─────────┼─────────┼─────────┼─────────┼─────────┼───────────┼──────────┤
│pxe        │         │         │         │         │         │           │deprecated│
├───────────┼─────────┼─────────┼─────────┼─────────┼─────────┼───────────┼──────────┤
│rkey       │         │         │nda-utils│key-utils│qca-utils│           │          │
├───────────┼─────────┼─────────┼─────────┼─────────┼─────────┼───────────┼──────────┤
│sada       │amp-utils│plc-utils│         │         │qca-utils│           │          │
├───────────┼─────────┼─────────┼─────────┼─────────┼─────────┼───────────┼──────────┤
│sdram      │amp-utils│         │         │         │qca-utils│           │deprecated│
├───────────┼─────────┼─────────┼─────────┼─────────┼─────────┼───────────┼──────────┤
│setpib     │         │         │nda-utils│         │qca-utils│           │          │
├───────────┼─────────┼─────────┼─────────┼─────────┼─────────┼───────────┼──────────┤
│slac       │         │         │         │         │qca-utils│           │deprecated│
├───────────┼─────────┼─────────┼─────────┼─────────┼─────────┼───────────┼──────────┤
│throwpib   │         │         │         │         │         │source-only│          │
├───────────┼─────────┼─────────┼─────────┼─────────┼─────────┼───────────┼──────────┤
│weeder     │         │         │nda-utils│         │qca-utils│           │          │
├───────────┼─────────┼─────────┼─────────┼─────────┼─────────┼───────────┼──────────┤
│xml2pib    │         │         │nda-utils│         │qca-utils│           │          │
└───────────┴─────────┴─────────┴─────────┴─────────┴─────────┴───────────┴──────────┘


Toolkit Support

Contact the Qualcomm Atheros System Application Engineering Team if you have
questions concerning the content, operation, application or direction of this
toolkit on GNU/Linux systems. If you are having trouble communicating with
Qualcomm Atheros powerline devices using the toolkit, try following the
troubleshooting procedure found later in this document.

Chapter 2.  Hardware

Table of Contents

Introduction
Device Form Factors
Device Communications
Device Configurations

    Local Host to Local Device
    Local Host to Remote Device
    Local Host to Remote Host

Powerline Workstations

    Host Hardware
    Host Software
    Network Configuration
    Isolated Power-strip

Send-to-self Patch

Introduction

Device Form Factors

Atheros Communications, Ocala FL USA designs and manufactures chipsets that
permit network communications over powerline. They do no not manufacture
powerline communication products for market. Instead, they provide chipsets,
reference designs and expertise needed to build powerline communications
products. Atheros does manufacture some sample products, in various form
factors, for evaluation purposes only.

Wall Adapters

    A small unit that plugs into any power outlet and has one RJ45 Ethernet
    jack. The RJ45 jack can be used to connect the unit to another Ethernet
    device, such as a hub, switch or computer network interface card using CAT5
    Ethernet cable. Two or more such units can be used to connect Ethernet
    devices over the powerline. For example, a computer on one room can be
    connected to a network printer in another room. See Atheros Product Brief
    27003417 - RD6300-ETH HomePlug® AV Wall Adapter Reference Design for more
    information.

Desktop Adapters

    A compact unit having a 6ft power cord, one threaded coax cable F connector
    and one RJ45 Ethernet jack. Two such units can be used to connect Ethernet
    devices over either powerline (as above) or coax cable. Use of coax cable
    improves performance over longer distances and permits network segments to
    be isolated from each other. See Atheros Product Brief 27002824 -
    RD6000-ETH HomePlug® AV Ethernet Hybrid Adapter Reference Design for more
    information.

PCI Cards

    A standard PCI compliant computer card having one DIN powerline connector
    and one threaded coax cable F connector. The card can be inserted into a
    PCI bus slot on a computer, or other device. Atheros provides device
    drivers that make the card behave like an ordinary Ethernet card. Like the
    desktop unit (above), computers and embedded systems can be connected
    either over powerline or coax cable. See Atheros Product Brief 27003239 -
    EK6000-PCI HomePlug® AV Card Evaluation Kit for more information.

    PCI cards are no longer available from Atheros but reference designs may be
    obtained from selected Atheros customers that specialize in PCI designs.

Mini-PLC

    A Mini-PCI form factor card that integrates most components needed to embed
    HomePlug® AV into your product design. Although the card will insert into a
    Mini-PCI slot, it is not electrically compatible with the Mini-PCI
    standard. Atheros uses this card in both the RD6000-ETH Desktop Adaptor and
    the EK6000-PCI Card described above. See Atheros Product Brief 27002835 -
    RD6000-PLC HomePlug® AV Mini-PLC Module Reference Design for more
    information.

    Unlike Wall and Desktop Adapters, the Mini-PLC Cards require a device
    driver written for the particular operating system used. Atheros provides a
    device drivers for the Windows XP Operating System and for the Linux 2.4
    and Linux 2.6 kernel. These drivers make the PCI card look like an ordinary
    Ethernet interface card.

    Mini-PLC cards are no longer available from Atheros but cards may be
    obtained from selected Atheros customers that specialize in PCI designs.

Embedded Systems

    Atheros offers an expanding family of reference designs for
    powerline-enabled switches and routers. Most include onboard CPU and
    enablement software based on Linux, OpenWRT and other suitable operating
    systems. Atheros will assist customers in adapting the basic hardware and
    software to suite particular markets.

Chipsets

    Atheros offers an expanding family of Powerline enabled chipsets. Several
    SoC chipsets are also planned to support a variety of communications
    applications.

Device Communications

Atheros powerline communication chipsets serve as a transparent bridges between
an Ethernet network and an active powerline or passive coax cable, effectively
extending the Ethernet network. HomePlug® AV devices on the powerline, or at
either end of a coax cable, will automatically detect each other and establish
communications. Normal Ethernet frames that are detected by one HomePlug® AV
device are passed over powerline or coax to other HomePlug® AV devices which
then pass the frames on to any Etherenet devices that may be connected to them.

There are three levels of communication.

Powerline Communications

    HomePlug® AV devices use a proprietary protocol defined by the HomePlug
    Powerline Alliance. In most cases, HomePlug® AV communications do not leave
    the powerline or coax media used to connect devices. Connected devices use
    this protocol to detect each other, establish connection, encapsulate
    Ethernet frames and route them between devices. This level of
    communications is proprietary and hidden. See the HomePlug Powerline
    Alliance HomePlug® AV Specification for more information.

Atheros Device Communications

    Atheros devices use a subset of the HomePlug® AV protocol, mentioned above,
    to communicate with a local host processor. The subset is known as
    vendor-specific messages . Atheros vendor-specific messages are intercepted
    and processed by Atheros devices. In some cases, they are forwared over
    powerline or coax to other Atheros devices. Atheros vendor-specific
    messages are used to interrogate, synchronize, configure and control
    Atheros devices without affecting HomePlug® AV devices from other
    manufacturers. See the Atheros HomePlug® AV Firmware Technical Reference
    Manual for more information.

Network Traffic

    This is the normal network traffic that passes transparently from local
    Ethernet, over powerline or coax, to remote Ethernet through HomePlug® AV
    devices.

Device Configurations

There are several test configurations that can be used to experiment with
Atheros powerline communication devices. Configurations vary based on the
powerline communications devices you have available to work with. All
configurations described here require at least one computer with an Ethernet
card and the Powerline Toolkit installed. Most configurations require two
Atheros powerline devices.

Powerline Toolkit programs let the user specify which Ethernet interface card
to use when sending and receiving Ethernet frames. This means that a computer
with two interface cards installed can emulate two computers provided there are
not internal routing conflicts. To avoid routing conflicts, Atheros recommends
that you start with two computers until your are ready for more sophisticated
experimentation.

Powerline Toolkit programs default to eth0 . This allows the computer to be
connected to the normal network on eth0 and connected to the powerline network
on eth1. To over-ride the default powerline interfaces, set environment
variable PLC to the desired interface name. All configurations assume that the
Ethernet card is installed, the Ethernet driver for that card is loaded and the
correct interface is enabled.

Atheros powerline communication devices radiate across powerline or coax at
radio frequencies. If two devices are connected, in any way, without
intermmediate filters or isolation, they will attempt to commicate.
Additionally, they will attempt to circumvent certain types of powerline noise
or competing frequencies which can cause reduce data rates. Atheros recomends
that devices under test (DUT) take their power from a shared but isolated power
source like an isolation power strip or an uninterruptable power supply.

( ... explain about powerline isolation ... ) The power strip should have no
filtering, surge protectors or electronic cirtuits inside.

        ---> [ATTENUATOR] ---> [POWER_STRIP] ---> [POWERLINE_DEVICE] --->


Typical configurations are:

Local Host to Local Device

This is the simplest configuration. It establishes an Ethernet connection
between the host and one powerline device. It can be used to test or program a
single powerline device.

It requires

  ● One host computer with an Ethernet interface card

  ● One CAT-5 Ethernet cable with an RJ-45 connector at either end.

  ● One Atheros powerline device with RJ-45 connector.

  ● An isolated power source

        [LOCAL_HOST] ---/ ethernet /-----> [POWERLINE_DEVICE] ---/ powerline /----->


Connect the local host to the powerline device with an ordinary CAT-5 Ethernet
cable. Apply power to the powerline device. The local host cannot ping the
powerline device because it functions at the data link layer. The local host
can interrogate and control the powerline device using int6k or int6k2 
programs.

  ● Type "int6k -r" and note the hardware and firmware revision.

  ● Type "int6k -I" and note the device MAC, DAK and NMK.

  ● Type "int6k -m" and confirm that the device detects no other devices
    indicating proper powerline isolation.

Local Host to Remote Device

This configuration is the simplest powerline network configuration. It expands
the previous configuration by creating a simple powerline network having two
powerline devices. One device, the "local device", is connected to the host via
Ethernet. A second device, the "remote device", is connected to the first via
powerline.

It requires

  ● One host computer with an Ethernet interface card

  ● One CAT-5 Ethernet cable with an RJ-45 connector at either end.

  ● Two Atheros powerline devices, one with RJ-45 connector.

  ● An isolated power source.

        [LOCAL_HOST] ---/ ethernet /-----> [POWERLINE_DEVICE] ---/ powerline /----->
                                           [POWERLINE_DEVICE] ---/ powerline /----->


Configure the previous network then plug a second powerline device into the
same power source as the first powerline device. The local host still cannot
ping any Ethernet network devices because there are no remote Ethernet devices
to ping but it can interrogate and control both powerline devices.

Local Host to Remote Host

This configuration is the simplest Ethernet network configuration. It expands
the previous network by connecting the second powerline device to an existing
Ethernet network through an Ethernet switch.

It requires

  ● Two host computers, each with an Ethernet interface card

  ● Two CAT-5 Ethernet cables with RJ-45 connectors at either end.

  ● Two Atheros powerline devices, each with RJ-45 connector.

  ● An isolated power source.

        [LOCAL_HOST]  ---/ ethernet /-----> [POWERLINE_DEVICE] ---/ powerline /----->
        [REMOTE_HOST] ---/ ethernet /-----> [POWERLINE_DEVICE] ---/ powerline /----->


Configure the previous network then plug the second powerline device into an
Ethernet switch connected to an exiting Ethernet network. The local host can
now ping other Ethernet network devices on the.

Powerline Workstations

The Powerline Toolkit is a collection of independent programs. Individually,
they perform basic but useful operations on powerline communication devices and
associated support files such as PIB and NVM files. Collectively, they can
perform many types of engineering experiments, functional tests and production
tasks. Their simplicity and high degree of flexibility lets customers adapt an
off-the-shelf linux host to meet a wide range of production requirements. We
call this configuration a “powerline workstation”.

This section explains how to configure a powerline workstation and setup the
Powerline Toolkit on that workstation. It covers some necessary aspects of
Linux and the Toolkit but it is not a Linux tutorial or a Powerline Toolkit
tutorial. Linux essentials are covered on the Internet and Powerline Toolkit
essentials are covered in other sections of this documentation and on-line man
pages. Although some typical configurations are illustrated, many variations
are possible and are left to the customer to develop based on our examples.
There is no single correct way to do anything.

Host Hardware

A powerline workstation host has no special hardware requirements. Any host
capable of running Linux and supporting multiple Ethernet cards will do. For
example, a 450mhz CPU having 128mb of memory, one 3gb disk and three 10/100
Ethernet cards is adequate.

Production tasks such as device initialization or firmware upgrade require one
Ethernet card. Experimentation and functional testing typically require two
Ethernet cards. Atheros recommends three Ethernet cards so that the host can
communicate with other hosts over a local area network while talking to
powerline devices. Atheros also recommends that all Ethernet cards installed
support at least 100mbps and be of the same type to simplify network
configuration.

Host Software

Atheros recommends installiing a Debian-based or Ubuntu-based Linux
distribution due to the simplicity of network configuration. Redhat™-based or
SuSE™-based distributions are also acceptable. A complete GNU toolchain is
required to compile and install the Powerline Toolkit. Atheros uses GNU make
3.8.0, GNU gcc 3.3.5 and GNU ld 2.15. If these components are not installed
then you must install them. Linux system installation and configuration is
beyond the scope of this documentation but there is a wealth of information
available on the Internet.

Of course, the Powerline Toolkit needs to be installed and successful
installation proves that all required Linux components are installed correctly.
See Installation on Linux for more information on how to install the Powerline
Toolkit.

Network Configuration

Linux will assign interface names like eth0, eth1 and eth2 to each installed
network card. Atheros recommends that eth0 be connected to your local network
so that you can communicate with other hosts on that network. The other two
interface cards can then be connected to Atheros devices that are plugged into
an isolated power-strip. Of course, one CAT-5 Ethenet cable will be needed for
each Ethernet card installed.

Interfaces eth1 and eth2 should be assigned IP addresses on a separate sub-net
so that you can ping one card from the other over the powerline without sending
traffic over the local network. Remember that powerline devices have MAC
addresses but not IP addresses. Also, Linux ping uses the routing table to
route messages and so you may need to use the -I option when pinging over the
powerline. Otherwise, ping packets may go out over the local network by
default.

# ifconfig
eth0      Link encap:Ethernet  HWaddr 00:50:04:A5:D9:5A
          inet addr:192.168.99.12  Bcast:192.168.99.255  Mask:255.255.255.0
          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1

eth1      Link encap:Ethernet  HWaddr 00:01:03:2B:03:67
          inet addr:192.168.101.10  Bcast:192.168.101.255  Mask:255.255.255.0
          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1

eth2      Link encap:Ethernet  HWaddr 00:01:03:2B:03:73
          inet addr:192.168.101.11  Bcast:192.168.101.255  Mask:255.255.255.0
          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1

lo        Link encap:Local Loopback
          inet addr:127.0.0.1  Mask:255.0.0.0
          UP LOOPBACK RUNNING  MTU:16436  Metric:1

The abbreviated ifconfig console display, shown above, illustrates a typical
Ethernet configuration using three cards, as recommended by Atheros. Interface
eth0 is on the 192.168.99.0 subnet which serves as the local network, in this
case. Interfaces eth1 and eth2 are both on the 192.168.101.0 subnet which
serves as the powerline network, in this case.

Although not required, installing both wireshark and tshark is a great idea
because they can be used to monitor and log network traffic on any or all of
the Ethernet interfaces during various operations.

Isolated Power-strip

Atheros devices have a way of finding each other over powerline and sometimes
across nearby powerlines. Power-strip isolation prevents cross-talk with other
powerline devices that may be plugged into nearby. Proper isolation is not
critical when getting started but can be critical in technical evaluation and
production environments.

There are many ways to isolate powerline devices. One way is to plug the
powerline workstation and the power-strip into an Uninterruptable Power Supply
(UPS). Atheros also provides several reference designs for both expensive and
inexpensive hardware that can be used to isolate devices and workstations.

Atheros powerline devices tend to work best when there is some signal
attenuation over powerline or coax connections. Engineering evaluation
configurations should insert some type of variable attenuation between
powerline devices to measure the performance of their own powerline device
designs. Consult with your Atheros Field Application Engineer on this matter.

Send-to-self Patch

One advantage of Linux™ powerline workstations is the ability to control the
low-level networking environment. ISO Layer 2 traffic can be easily directed
from one Ethernet interface to another on the same host but Layer 3 traffic is
a different matter because routing software merely routes this type of traffic
internally.

A Linux™ kernel patch is available that will allow ISO Layer 3 traffic to be
routed from one Ethernet interface to another on the same host. With this
patch, multiple instances of a traffic generator, like ttcp or iperf, can be
effectively deployed on the same host without modification.

This patch is useful for testing on a closed network but it could pose a
security risk to the local host when connected to a public network. Kernels
having this patch installed should have a special designation such as
“linux-2.6.28-send-to-self” so that users are aware that the patch is
installed.

Example 2.1.  “send-to-self” Patch Description

The following is the full, original patch description.

        Send-To-Self interface flag
        Julian Anastasov <ja@ssi.bg>, July 2003

        Patches for different kernels:

        send-to-self-2.4.21-1.diff
        send-to-self-2.5.73-1.diff

        The  presented patch implements routing of traffic between local
IP addresses externally via ethernet interfaces. This patch is basically
the Ben Greear's send-to-self work but reimplemented entirely on routing
level.   The idea is  to return output route  via external interfaces if
path between two local IP addresses is requested and they are configured
on different interfaces with /proc/sys/net/ipv4/conf/DEVNAME/loop set to
1.    As  result,  arp_filter  (if  enabled  -  the  recommended  value)
automatically  accepts  the ARP  requests  on the  right  interface. The
rp_filter  check is modified to accept traffic from such interfaces with
local  IP as sender, so using loop=1 for interfaces attached to insecure
mediums is not recommended.

Pros:
- it can be used from all existing applications without change
- it is not limited to 2 interfaces
- you can use it with many IP addresses
- does not depend on the rp_filter and arp_filter states, they
can be set to 1
- the packets are not altered in any way, useful for QoS testings
- the routing result is cached, the routing checks are not per packet

Cons:
- not possible to use it for interfaces attached to insecure
mediums (the rp_filter protection allows saddr to be local IP).
By design. Use at your own risk.

        The usage is simple:

# Connect two or more interfaces to same hub or via crossover cable

# Enable loopback mode for eth0 and eth1. This even can be
# default mode without breaking any other talks. By this way
# we allow external routing only between local IPs configured
# on the specified interfaces.

echo 1 > /proc/sys/net/ipv4/conf/eth0/loop
echo 1 > /proc/sys/net/ipv4/conf/eth1/loop

# Add some IP addresses for testing, eg. client and server IP

ip address add 192.168.1.1 dev eth0
ip address add 192.168.2.1 dev eth1

# Testing with applications that are aware of this binding.
# The main thing the apps need to know is what src and dst IP
# addresses to use. The client app needs to bind to the src IP
# and by this way to request output route to the dst IP. There
# is no specific configuration for the server app listening on
# 192.168.2.1

ping -I 192.168.1.1 192.168.2.1

# Note that specifying the output device (SO_BINDTODEVICE is
# not recommended)


# Testing with applications that are not aware of this feature:
# for 192.168.1.1 client (the same for the server is not needed).
# Note that by default, in local routes the kernel uses the local
# IPs as preferred source. This is the safe default mode (if loop=1)
# for applications that do not care what src IP will be used
# for their talks with local IPs. We try to change that and to
# use IPs from different interfaces.

ip route replace local 192.168.2.1 dev eth1 scope host src 192.168.1.1 proto kernel

# but for any case, here it is and for the "server":

ip route replace local 192.168.1.1 dev eth0 scope host src 192.168.2.1 proto kernel

# Testing it:

ping 192.168.2.1
ping -I 192.168.1.1 192.168.2.1
telnet 192.168.2.1

# Note that by replacing the local route's preferred source IP address
# we help the IP address autoselection to select proper IP to the
# target, in our case, route via eth


Example 2.2.  “send-to-self” Patch Application

The following example illustrates how to use iperf to perform TCP and UDP
traffic measurements once this patch is installed. We illustrate the use of
iperf but do not necessarily endorse it for traffic measurement. We also
illustrate the use of two interfaces but the “send-to-self” patch will support
additional interfaces. We also illustrate the use of environment variables so
that procedures can execute on different hosts without modification but these
environment variables are not required.

First, we define environment variables, IF1 and IF2, for each Ethernet
interface and, IP1 and IP2, for their IP addresses. Each interface must be on a
separate IP subnet. We export definitions here so that they are accessible to
this process and any subprocesses, such as shell scripts. Do whatever is
appropriate for your environment.

export IF1=eth1
export IF2=eth2
export IP1=192.168.1.1
export IP2=192.168.2.2

Next, we assign the IP addresses to the interfaces using program ifconfig.
There are other ways to do this. Observe that we reference our environment
variables on the command line.

ifconfig ${IF1} ${IP1}
ifconfig ${IF2} ${IP2}

Next, we suppress internal routing between local interfaces. The loop propery
only exists on kernels that have the “send-to-self” patch installed and have
the /proc filesystem mounted. Some systems may not mount this file system.

echo 1 > /proc/sys/net/ipv4/conf/${IF1}/loop
echo 1 > /proc/sys/net/ipv4/conf/${IF2}/loop

Alternately, you could edit file /etc/sysctl.conf, as follows, to set the loop
property for each interface during system startup. Again, the loop propery only
exists on kernels that have the “send-to-self” patch installed and so errors
will occur if you boot another kernel that does not have it installed.

net.ipv4.conf.eth1.loop = 1
net.ipv4.conf.eth2.loop = 1

Open a console window and start iperf as a server. Option -s identifies this
instance of iperf as the server. Option -B binds this instance to one host
interface by IP address, in this case IP1 defined earlier.

iperf -B ${IP1} -s
------------------------------------------------------------
Server listening on TCP port 5001
Binding to local address 192.168.1.1
TCP window size: 85.3 KByte (default)
------------------------------------------------------------

Open a second console window and start iperf as a client. Option -c identifies
this instance of iperf as a client. Option -B binds this instance to the one
interface by IP address, in this case IP2 defined earlier. The server address
must also be specified, in this case IP1 bound to the server in the last step.

iperf -B ${IP2} -c ${IP1}
------------------------------------------------------------
Client connecting to 192.168.1.1, TCP port 5001
Binding to local address 192.168.2.1
TCP window size: 16.0 KByte (default)
------------------------------------------------------------
[  3] local 192.168.2.1 port 5001 connected with 192.168.1.1 port 5001
[ ID] Interval       Transfer     Bandwidth
[  3]  0.0-10.0 sec  31.1 MBytes  26.0 Mbits/sec


Example 2.3.  “send-to-self” Patch Installation

The “send-to-self” patch exists for several recent Linux™ kernel versions but
not all versions. Assuming you have obtained the correct kernel archive and the
correct patch version, the following script illustrates the steps needed to
apply the patch on Ubuntu 9.04™ and recompile the kernel. Observe that, in this
case, the patch version does not match the kernel version because a patch has
not been published for that kernel version.

The following script can be used on a Ubuntu Linux distribution to download
kernel source, the send-to-self patch, apply the patch then compile and install
the resulting kernal image. When the menuconfig screen appears:

 1. Select General Setup on the “Linux Kernel Configuration” screen.

 2. Select Local version - append to kernel release on the “General Setup”
    screen.

 3. Enter the version suffix “-send-to-self”.

 4. Select ok to return to the “General Setup” screen.

 5. Select Automatically append version information to the version string on
    the “General Setup” screen.

 6. Select exit to return to the “Linux Kernel Configuration” screen.

 7. Select exit to close the menuconfig program.

 8. Select yes if prompted to save your new kernel configuration. This message
    does not appear each time.

#!/bin/bash
# file: patches/send-to-self-2.6.28.sh

# ====================================================================
# environment variables;
# --------------------------------------------------------------------

VERSION=2.6.28
CURRENT=9
VARIANT=send-to-self
PACKAGE=linux-source-${VERSION}
ARCHIVE=${PACKAGE}.tar.bz2
PATCH=send-to-self-2.6.26-1.diff

# ====================================================================
# extend version string;
# --------------------------------------------------------------------

if [ ! -z ${CURRENT} ]; then
        VERSION+=.${CURRENT}
fi
if [ ! -z ${VARIANT} ]; then
        VERSION+=-${VARIANT}
fi

# ====================================================================
# install required software;
# --------------------------------------------------------------------

if [ ! -f ${ARCHIVE} ]; then
        wget http://www.ssi.bg/~ja/${PATCH}
        apt-get install ${PACKAGE}
#       apt-get install ${PACKAGE} --reinstall
        apt-get install binutils patch gcc g++
        apt-get install ncurses-dev
        mv /usr/src/${ARCHIVE} .
fi

# ====================================================================
# confirm archive file exists;
# --------------------------------------------------------------------

if [ ! -f ${ARCHIVE} ]; then
        echo "File ${ARCHIVE} is missing or misplaced"
        exit 1
fi

# ====================================================================
# confirm patch file exists;
# --------------------------------------------------------------------

if [ ! -f ${PATCH} ]; then
        echo "File ${PATCH} is missing or misplaced"
        exit 1
fi

# ====================================================================
# remove old kernel source if present;
# --------------------------------------------------------------------

if [ -d ${PACKAGE} ]; then
        echo "Removing old source ..."
        rm -fr ${PACKAGE}
fi

# ====================================================================
# extract kernel source;
# --------------------------------------------------------------------

tar -vjxf ${ARCHIVE}
if [ ! -d ${PACKAGE} ]; then
        echo "Folder ${PACKAGE} does not exist"
        exit 1
fi
cd ${PACKAGE}

# ====================================================================
# patch kernel source;
# --------------------------------------------------------------------

patch -p1 < ../${PATCH}

# ====================================================================
# compile kernel source;
# --------------------------------------------------------------------

make mrproper
make menuconfig
make

# ====================================================================
# install kernel source;
# --------------------------------------------------------------------

make modules_install
make install

# ====================================================================
# install kernel source;
# --------------------------------------------------------------------

mkinitramfs -o /boot/initrd.img-${VERSION} ${VERSION}
ln -fs config-${VERSION} /boot/config
ln -fs initrd.img-${VERSION} /boot/initrd.img
ln -fs System.map-${VERSION} /boot/System.map
ln -fs vmlinuz-${VERSION} /boot/vmlinuz



In case you don't know ...

apt-get --reinstall

The apt-get program is only available on Debian-based distributions. If you do
not use a Debian-based system then you must find another way to obtain the
necessary packages. Option --reinstall instructs apt-get to download the kernel
even though it has been installed before. It is not needed on the first script
execution but may be needed on subsequent script executions if you have deleted
the kernel archive file.

mkinitramfs

This script uses mkinitramfs instead of the mkinitrd. This may differ on other
distributions. The kernel source package used here has Ubuntu™ modifications
that result in a minor version being appended to the kernel version. This may
not happen with other distributions or with kernels obtained directly from
kernel.org.

cut-and-paste

This script, or some like it, are included in the ./patches folder of the
toolkit. You can also copy and paste this script but remember to edit the
environment variables at the top, remove all carriage returns and set correct
file permissions with chmod 0755 before executing it on your Linux™ host. Run
the script as root user.

grub/menu.lst

If your system uses grub then edit file /boot/grub/menu.lst and add a new
reference to the new initrd.img, System.map and vmlinuz files installed in
folder /boot by this script. We recommend adding these references as the last
ones in the file so that the new kernel does not start by default. Once you are
confident that everything works, you can then move the references to the first
entry. We also recommend setting the timeout value to 10 for now.

Example 2.4.  “send-to-self” Patch Listing

The following “send-to-self” patch is specifically for Linux™ kernel 2.6.30 and
is provided for information only. For practical purposes, the patch has not
changed much from version to version but the line numbers have changed. Some
recent “send-to-self” patches are included in the toolkit ./patches folder.

diff -urp v2.6.30/linux/Documentation/networking/ip-sysctl.txt linux/Documentation/networking/ip-sysctl.txt
--- v2.6.30/linux/Documentation/networking/ip-sysctl.txt        2009-06-13 10:53:29.000000000 +0300
+++ linux/Documentation/networking/ip-sysctl.txt        2009-06-13 15:54:15.000000000 +0300
@@ -637,6 +637,13 @@ accept_redirects - BOOLEAN
 forwarding - BOOLEAN
        Enable IP forwarding on this interface.

+loop - BOOLEAN
+       By default (loop=0) the traffic between local IP addresses
+       is routed via interface "lo". Setting this flag for two
+       interfaces allows traffic between their IP addresses to
+       be looped externally. This is useful for setups where the
+       interfaces are attached to same broadcast medium.
+
 mc_forwarding - BOOLEAN
        Do multicast routing. The kernel needs to be compiled with CONFIG_MROUTE
        and a multicast routing daemon is required.
diff -urp v2.6.30/linux/include/linux/inetdevice.h linux/include/linux/inetdevice.h
--- v2.6.30/linux/include/linux/inetdevice.h    2009-06-13 10:53:56.000000000 +0300
+++ linux/include/linux/inetdevice.h    2009-06-13 15:54:15.000000000 +0300
@@ -106,6 +106,7 @@ static inline void ipv4_devconf_setall(s
          IN_DEV_ORCONF((in_dev), ACCEPT_REDIRECTS)))

 #define IN_DEV_ARPFILTER(in_dev)       IN_DEV_ORCONF((in_dev), ARPFILTER)
+#define IN_DEV_LOOP(in_dev)            IN_DEV_CONF_GET(in_dev, LOOP)
 #define IN_DEV_ARP_ANNOUNCE(in_dev)    IN_DEV_MAXCONF((in_dev), ARP_ANNOUNCE)
 #define IN_DEV_ARP_IGNORE(in_dev)      IN_DEV_MAXCONF((in_dev), ARP_IGNORE)
 #define IN_DEV_ARP_NOTIFY(in_dev)      IN_DEV_MAXCONF((in_dev), ARP_NOTIFY)
diff -urp v2.6.30/linux/include/linux/sysctl.h linux/include/linux/sysctl.h
--- v2.6.30/linux/include/linux/sysctl.h        2009-06-13 10:53:56.000000000 +0300
+++ linux/include/linux/sysctl.h        2009-06-13 15:54:40.000000000 +0300
@@ -491,6 +491,7 @@ enum
        NET_IPV4_CONF_PROMOTE_SECONDARIES=20,
        NET_IPV4_CONF_ARP_ACCEPT=21,
        NET_IPV4_CONF_ARP_NOTIFY=22,
+       NET_IPV4_CONF_LOOP=23,
        __NET_IPV4_CONF_MAX
 };

diff -urp v2.6.30/linux/kernel/sysctl_check.c linux/kernel/sysctl_check.c
--- v2.6.30/linux/kernel/sysctl_check.c 2009-06-13 10:53:57.000000000 +0300
+++ linux/kernel/sysctl_check.c 2009-06-13 15:55:00.000000000 +0300
@@ -220,6 +220,7 @@ static const struct trans_ctl_table tran
        { NET_IPV4_CONF_PROMOTE_SECONDARIES,    "promote_secondaries" },
        { NET_IPV4_CONF_ARP_ACCEPT,             "arp_accept" },
        { NET_IPV4_CONF_ARP_NOTIFY,             "arp_notify" },
+       { NET_IPV4_CONF_LOOP,                   "loop" },
        {}
 };

diff -urp v2.6.30/linux/net/ipv4/devinet.c linux/net/ipv4/devinet.c
--- v2.6.30/linux/net/ipv4/devinet.c    2009-06-13 10:53:58.000000000 +0300
+++ linux/net/ipv4/devinet.c    2009-06-13 15:55:22.000000000 +0300
@@ -1449,6 +1449,7 @@ static struct devinet_sysctl_table {
                DEVINET_SYSCTL_RW_ENTRY(ARP_IGNORE, "arp_ignore"),
                DEVINET_SYSCTL_RW_ENTRY(ARP_ACCEPT, "arp_accept"),
                DEVINET_SYSCTL_RW_ENTRY(ARP_NOTIFY, "arp_notify"),
+               DEVINET_SYSCTL_RW_ENTRY(LOOP, "loop"),

                DEVINET_SYSCTL_FLUSHING_ENTRY(NOXFRM, "disable_xfrm"),
                DEVINET_SYSCTL_FLUSHING_ENTRY(NOPOLICY, "disable_policy"),
diff -urp v2.6.30/linux/net/ipv4/fib_frontend.c linux/net/ipv4/fib_frontend.c
--- v2.6.30/linux/net/ipv4/fib_frontend.c       2009-06-13 10:53:58.000000000 +0300
+++ linux/net/ipv4/fib_frontend.c       2009-06-13 15:54:15.000000000 +0300
@@ -239,16 +239,17 @@ int fib_validate_source(__be32 src, __be
                                        .tos = tos } },
                            .iif = oif };
        struct fib_result res;
-       int no_addr, rpf;
+       int no_addr, rpf, loop;
        int ret;
        struct net *net;

-       no_addr = rpf = 0;
+       no_addr = rpf = loop = 0;
        rcu_read_lock();
        in_dev = __in_dev_get_rcu(dev);
        if (in_dev) {
                no_addr = in_dev->ifa_list == NULL;
                rpf = IN_DEV_RPFILTER(in_dev);
+               loop = IN_DEV_LOOP(in_dev);
        }
        rcu_read_unlock();

@@ -258,6 +259,11 @@ int fib_validate_source(__be32 src, __be
        net = dev_net(dev);
        if (fib_lookup(net, &fl, &res))
                goto last_resort;
+       if (loop && res.type == RTN_LOCAL) {
+               *spec_dst = FIB_RES_PREFSRC(res);
+               fib_res_put(&res);
+               return 0;
+       }
        if (res.type != RTN_UNICAST)
                goto e_inval_res;
        *spec_dst = FIB_RES_PREFSRC(res);
diff -urp v2.6.30/linux/net/ipv4/route.c linux/net/ipv4/route.c
--- v2.6.30/linux/net/ipv4/route.c      2009-06-13 10:53:58.000000000 +0300
+++ linux/net/ipv4/route.c      2009-06-13 15:54:15.000000000 +0300
@@ -2521,6 +2521,11 @@ static int ip_route_output_slow(struct n
                        dev_put(dev_out);
                        goto out;       /* Wrong error code */
                }
+               err = -ENETDOWN;
+               if (!(dev_out->flags&IFF_UP)) {
+                       dev_put(dev_out);
+                       goto out;
+               }

                if (ipv4_is_local_multicast(oldflp->fl4_dst) ||
                    oldflp->fl4_dst == htonl(0xFFFFFFFF)) {
@@ -2588,10 +2593,41 @@ static int ip_route_output_slow(struct n
        free_res = 1;

        if (res.type == RTN_LOCAL) {
-               if (!fl.fl4_src)
-                       fl.fl4_src = fl.fl4_dst;
+               struct in_device *in_dev;
+               __be32 src;
+
                if (dev_out)
                        dev_put(dev_out);
+               dev_out = FIB_RES_DEV(res);
+               in_dev = in_dev_get(dev_out);
+               src = fl.fl4_src? : FIB_RES_PREFSRC(res);
+               if (in_dev && IN_DEV_LOOP(in_dev) && src) {
+                       struct net_device *dev_src;
+
+                       in_dev_put(in_dev);
+                       in_dev = NULL;
+                       dev_src = ip_dev_find(net, src);
+                       if (dev_src && dev_src != dev_out &&
+                           (in_dev = in_dev_get(dev_src)) &&
+                           IN_DEV_LOOP(in_dev)) {
+                               in_dev_put(in_dev);
+                               dev_out = dev_src;
+                               fl.fl4_src = src;
+                               fl.oif = dev_out->ifindex;
+                               res.type = RTN_UNICAST;
+                               if (res.fi) {
+                                       fib_info_put(res.fi);
+                                       res.fi = NULL;
+                               }
+                               goto make_route;
+                       }
+                       if (dev_src)
+                               dev_put(dev_src);
+               }
+               if (in_dev)
+                       in_dev_put(in_dev);
+               if (!fl.fl4_src)
+                       fl.fl4_src = fl.fl4_dst;
                dev_out = net->loopback_dev;
                dev_hold(dev_out);
                fl.oif = dev_out->ifindex;


Chapter 3.  Software

Table of Contents

Introduction
Security Considerations
Platform Options

    GNU/Linux
    GNU/Linux with Libpcap
    GNU/Linux with BPF
    Mac OS X™ with BPF
    Windows XP™ with Winpcap

GNU Makefiles on Linux
Stand-alone Compiling on GNU/Linux
Cross-Compiling on GNU/Linux
Compilation with Visual Studio .NET 2003
Microsoft Solution Files
Header Files
Compiler Constants

    Platform Constants
    Ethernet Constants

LibPcap, WinPcap and BPF
Structure Packing
Endian-ness
Packet Basics
Frame Encoding

Introduction

The Powerline Toolkit is designed to support hardware engineers and embedded
software developers working on GNU/Linux and Linux-like systems. Debian GNU/
Linux is the platform of choice because it is open source and has extensive
cross-platform support. The toolkit has been compiled and executed on several
platforms but Qualcomm Atheros does not necessarily support the toolkit on
those platforms. Qualcomm Atheros has made every effort to enable
cross-platform compatibility by conforming to POSIX standards and following
good programming practice but there are limitations on any such effort.

Security Considerations

Toolkit programs are installed in /usr/local/bin with owner root and group root
(chown root:root) and with read and execute permissions for owner, group and
others (chmod 0555). This lets anyone execute these programs even though they
are owned by user root.

Additionally, programs that send raw Ethernet frames are installed with seteuid
owner (chmod 4555) so that they will execute with root user privileges,
regardless of the user executing them. This lets any user send raw Ethernet
frames but it also presents a security risk on the host computer. For example,
program int6k is intended to read and write .nvm and .pib files but a malicious
user could use it to overwrite other files normally protected by standard file
permissions.

You can change the default file permissions by changing the -m 4555 option on
the install command in various Makefiles. Be aware that doing so will restrict
program access to the the root user.

Platform Options

Qualcomm Atheros makes no claim that the Powerline Toolkit will compile and
link in all environments without generating warnings or errors. Different
compilers, and compiler versions, treat certain conditions differently and
different distributions include different header files or define standard
constants and macros differently. Developers should expect to make some source
code and makefile modifications to match their environment.

The principle consideration is support for raw Ethernet frames. Other
considerations include POSIX compliance, system header file locations, compiler
version and library support. This section discusses some of these
considertations.

GNU/Linux

The toolkit will compile and execute on GNU/Linux systems without modification
by using standard Linux header files and native Linux libraries. Raw socket
support is native to the Linux Kernel. This is the preferred environment due to
cost, networking speed and ease of access to Layer 2 networking.

Qualcomm Atheros has cross-compiled and executed versions of the toolkit on
MontaVista™ and AMiLDA™ Linux both for MIPSEL™ processors. Most toolkit
makefiles have symbolic hooks for cross-compilers but Qualcomm Atheros does not
support cross-compilation efforts on any platform.

GNU/Linux with Libpcap

The toolkit can compile and will execute on GNU/Linux systems having the
libpcap development package and runtime libraries installed; however, this
feature is disabled by default because it is not needed on Linux and offers no
benefits over native Linux sockets.

GNU/Linux with BPF

The toolkit should compile and execute on GNU/Linux systems having BPF compiled
into the kernel but modifications would be needed to toolkit source code. This
configuration has not been tested but the source code is present to support it.
Consult Qualcomm Atheros if this option is of interest to you.

Mac OS X™ with BPF

The toolkit will compile and execute on Mac OS X without modification by using
native BPF support compiled into the Darwin kernel. Compilation is clean on
Leopard and should be fairly clean on Tiger.

You may observe compiler warnings concerning the size_t data type and print
statements. These warning occur because Mac OS X defined the size_t data type
as a 64-bit integer while most other systems define it as a 32-bit integer.
Ignore the warnings. We will eventually eliminate them all.

You may observe a compiler warning concerning the definition of intrinsic
function snprinf. We are not sure what causes this warning but it will be
corrected eventually.

Windows XP™ with Winpcap

The toolkit will compile and execute on Microsoft Windows XP™ having WinPcap
4.0.1 runtime libraries installed. To assist windows devlopers, the toolkit
includes a Microsoft Visual Studio .NET 2003™ solution file plus required
WinPcap 4.0.1 header files and libraries. The resulting programs should execute
on any Microsoft Windows™ computer having WinPcap 4.0.1 runtime libraries
installed. Qualcomm Atheros does not support the toolkit under any Microsoft
Windows™ operating system at this time.

Recent versions of the toolkit include self-extraing file .\VisualStudioNET\
WinPcap4_0_1.exe that installs WinPcap 4.0.1 libraries on your system in cases
where you have another version installed. If this creates a conflict the you
must resolve it to satifsy your system requirements.

This is not the preferred Toolkit environment due to cost, networking overhead,
difficulty accessing Layer network support and lack of a powerful native
scripting language. Qualcomm Atheros has not implemented all Toolkit programs
on Windows for technical reasons.

GNU Makefiles on Linux

The toolkit includes recursive GNU makefiles for Linux. The Makefile in the
root folder calls Makefiles in subordinate folders. Makefiles in subordinate
folders can be run indpendently to produce individual toolkit components.
Developers can control which components are compiled and installed by editing
the FOLDERS symbol in the main Makefile.

Component Makefiles have a standard format that includes the following targets:

compile

    Compiles source code files prior to installation. Intermmediate files and
    target files are created in the same folder as the Makefile. This is the
    default target. That means that typing make or make compile have the same
    result.

library

    Creates any special folders that are needed for installation. This target
    is built by the install target but it can be built independently.

scripts

    Installs scripts required for proper toolkit operation. This target must be
    built explicitly to prevent accidental loss of changes made to existing
    scripts. This target may be built at any time, before or after the install
    target.

manuals

    Creates manuals, documents or html pages. Documentation files are not
    automatically installed by any target. Installation is left to the user.

install

    Installs executable files in folder /usr/local/bin. This target
    automatically builds the compile target before installation. This means
    that make install will compile and install in one step.

uninstall

    Removes installed components. This target does nothing for Makefiles that
    have install targets defined.

clean

    Removes intermmediate and temporary files. Temporary files are defined by
    variable TRASH at the start of each Makefile.

fresh

    Removes intermmediate and temporary then re-compiles local targets. It is
    normally equivalent to make clean followed by make compile.

Developers wanting to compile the toolkit under Windows™ should use Visual
Studio .NET™ solution files instead of makefiles.

Developers wanting to compile the toolkit under OpenBSD must make changes to
accommodate variations in make program syntax.

Stand-alone Compiling on GNU/Linux

You do not need makefiles to build toolkit programs because source files
explicitly include all required components using include statement blocks like
that shown below. You will see similar blocks near the top of most programs.

Example 3.1.  The MAKEFILE constant

#ifndef MAKEFILE
#include "../tools/getoptv.c"
#include "../tools/putoptv.c"
#include "../tools/version.c"
...
#endif


This mechanism has several advantages. First, the preprocessor include
statements form a complete inventory of required files. Secondly, the relative
pathnames help developers locate needed source files. Third, the complete
program can be compiled with one gcc command, like the one shown below. This
allows program compilation in environments where the GNU make program or the
Atheros Makefiles are not available.

Example 3.2.  Stand-alone Compiling on GNU/Linux

# gcc -o program program.c


Most toolkit makefiles define the preprocessor constant MAKEFILE as a compiler
option using CFLAGS= ... -DMAKEFILE .... When this constant is defined, the
compiler will not include components inside an include block like that shown
above and so the Makefile is responsible for compiling and linking all
components. If the constant is not defined, because no Makefile was used, the
compiler will merely include everything needed.

Cross-Compiling on GNU/Linux

Makefiles are setup for cross-compilation using custom toolchains. File
make.def, in the main toolkit folder, defines cross-comilation symbols
referenced in lower-level makefiles. Lower-level makefiles include make.def
before building their targets. The following is an example make.def file used
when cross-compiling for the ADM5120 MIPSEL-based gateway.

Example 3.3.  Cross-compiling with make.def

# file: make.def

# ====================================================================
# Edimax Hardware;
# --------------------------------------------------------------------

PLATFORM=-D_ADM5120_
MODEL=-D_6104KP_
ENDIAN=-D_LITTLE_ENDIAN_
GATEWAY=y

# ====================================================================
# AMiLDA Software; uncomment these lines when cross-compiling;
# --------------------------------------------------------------------

# CROSS=/export/tools/mipsel-linux-uclibc/bin/mipsel-uclibc-
# CROSS_LINUX=/export/tools/bin/mipsel-linux-

# ====================================================================
# toolchain;
# --------------------------------------------------------------------

CC=$(CROSS)gcc
STRIP=$(CROSS)strip
LD=$(CROSS)ld
AR=$(CROSS)ar
RANLIB=$(CROSS)ranlib
CAS=$(CROSS)gcc -c
CPP=$(CROSS)gcc -E

# ====================================================================
# folders;
# --------------------------------------------------------------------

BIN=/usr/local/bin
MAN=/usr/share/man/man7
WWW=/home/www
DOC=/home/www/software/plc-utils/

# ====================================================================
# permissions;
# --------------------------------------------------------------------

OWNER=0
GROUP=0



Developers are encouraged to make changes in this file rather than adding
additional variables to the lower-level makefiles. For example, you can edit
variable BIN to install toolkit programs in some location other than /usr/local
/bin or variable WWW to install HTML documentation on your local website.

Compilation with Visual Studio .NET 2003

To build the Powerline Toolkit on Windows XP, you must have access to a Windows
computer with Visual Studio .NET 2003 and WinPcap runtime libraries installed.
WinPcap is an open source version of the packet capture library, libpcap,
widely used on Linux and OpenBSD systems. It is readily available on the
Internet. Installation of these components is beyond the scope of this
document.

The Windows and Linux versions of the Powerline Toolkit use the same code base
but the Windows version requires a Microsoft solution file that includes
special compiler settings and specific POSIX header files. The solution file
and header files are included in the same archive as Linux version.

Example 3.4.  Microsoft Visual Studio .NET 2003

                                 [VisualStud]


Use an application like WinZip to extract archived files into a build folder of
your choice. Use Windows Explorer to locate solution file .\VisualStudioNET\
plc-utils.sln under the toolkit root folder. Double-click the file to open it
with Visual Studio .NET. In Visual Studio .NET, open the Solution Explorer
window and observe a display similar to that shown above.

Figure 1 illustrates a Visual Studio .NET window with the Solution Explorer
pane exposed. In the Solution Explorer window, right-click the plc-utils
solution and select the Rebuild menu option. Compiliation should begin. Watch
for comilation errors.

On successful compilation of all projects in this solution, you should find
executable programs in the Release folder under each project folder. If not
then look in the Debug folder, instead. You can now open a console window,
change to each Release or Debug folder in turn and run the programs located
there. Instead, we recommend that you create a Windows Installer package by
right-clicking on the Install project in the Solution Explorer window and
selecting the Build menu option. Compilation should resume.

On successful completion of the install project build, you should find the
Windows Installer file plc-utils.msi in the VisualStudioNET folder above the
install project folder. Double-clicking on this file will start the Windows
Installer program.

To distribute the toolkit package to other Windows computers, copy the Windows
Installer file to a public network share or some type of portable media.

Microsoft Solution Files

The Atheros Powerline Toolkit includes a Visual Studio .NET™ solution file, ./
VisualStudioNET/plc-utils.sln, that will build the toolkit on Windows XP SP2
from the Linux code base. The following information may be helpful to
developers wanting to modify or extend the solution or port it to another
version of Microsoft Visual Studio:

  ● All projects are WIN32 Console Projects.

  ● All projects have pre-compiled headers suppressed.

  ● All projects should globally define preprocessor constant MAKEFILE to
    prevent proliferation of "already defined" link errors. See Stand-alone
    Compiling on GNU/Linux for an explanation of this constant.

  ● All projects search folder ..\include for stdint.h and unistd.h because
    Microsoft does not provide them. These header files are customized or
    abbreviated versions of their POSIX counterparts and should be used when
    originals are available.

  ● Projects that perform raw Ethernet I/O should globally define preprocessor
    constant WINPCAP to enable appropriate code segments. Preprocessor error
    statements should (but may not) alert you if WINPCAP is not defined on
    Windows™ platforms.

  ● Projects that perform raw Ethernet I/O search folder ..\include for WinPcap
    header files. These files are taken from the WinPcap development package
    and may require periodic updates. Header files pcap.h, pca-stdinc.h,
    pcap-bpf.h, ipv6_misc.h and bittypes.h belong in folder VisualStudioNET\
    include. Other header files belong in folder VisualStudioNET\include\pcap.

  ● Projects that perform raw Ethernet I/O should include folder ..\library for
    core WinPcap libraries.

  ● Projects that perform raw Ethernet I/O should link to libraries ws2_32.lib,
    packet.lib and wpcap.lib. The first library is the Microsoft Winsock2
    library. The others are core WinPcap libraries.

Header Files

Atheros Powerline Toolkit programs reference POSIX functions and constants
where possible. Specifically, they make wide use of the data types uint8_t,
uint16_t and uint32_t which are defined in file stdint.h. Microsoft Visual C™
and .NET™ environments do not include this file. Consequently, Atheros provides
an alternative in folder ../Windows/include. This file is open source and was
designed to be compatible with the Microsoft development environments; however,
you may occassionally experience warnings about the "benign redefinition" for
some of these data types.

Where possible, this toolkit includes OpenBSD™ network constants because the
OpenBSD project pioneered many of the common network protocols and applications
used today. Some systems do not include all OpenBSD™ network header files or do
not define all OpenBSD™ network constants. Specifically, Microsoft systems do
not provide file netinet/if_ether.h and so an alternative is included in folder
../Windows/include/netinet and Windows™ applications should include it.

When the gcc -std=iso9899:1999 option is enabled, some OpenBSD™ header files
found on GNU/Linux systems will exclude required constant definitions because
they do not conform to that standard. Atheros is investigating the best way to
address this problem.

On some systems, such as OpenBSD™, FreeBSD™ and Mac OS X™, header files must be
included in specific order to avoid compilation errors. We have done our best
to deal with this problem. Visit the GNU Autocnf Project for more information
about this.

Compiler Constants

Platform Constants

Platform constants conditionaly compile source code blocks based on the
hardware architecture and host operating system. Hardware architecture
constants are normally defined in system header files. Operating system
constants are often compiler intrinsic or defined in system header files.

__APPLE__

    A intrinsic compiler constant indicating Mac OS X™ operating system
    support.

__BYTE_ORDER

    A standard constant indicating big or little endian host architecture. Some
    systems may not define this constant and so an alternative should be used.

LIBPCAP

    An Atheros constant, that must be manually defined in your makefile or
    solution file, to indicate that the target host will have LibPcap support.
    It is not used by the toolkit, at this time, and so the associated code has
    not been tested.

__linux__

    A standard constant indicating GNU/Linux™ kernel support. It is
    automatically defined on GNU/Linux™ systems.

__OpenBSD__

    A standard constant indicating OpenBSD™ kernel support. It is automatically
    define on OpenBSD™ systems. It is not used by the toolkit, at this time,
    and so the associated code has not been extensively tested.

WIN32

    A standard constant indicating Microsoft Windows™ support. It is
    automatically defined in Microsoft Windows™ environments.

WINPCAP

    An Atheros constant, that must be manually defined in your makefile or
    solution file, to indicate that the target host will have WinPcap support.
    The toolkit only defines this constant in Windows Microsoft project files
    for programs that perform raw Ethernet I/O.

Ethernet Constants

The toolkit attempts to use existing definitions for Ethernet related constants
where possible. This has been problematic due to inconsistencies in the way
different systems structure their header files. Most of the following
definitions already exist on Linux™, OpenBSD™ and OS X™ but there are still
some differences between Linux™ distributions and many constants are undefined
on Windows™.

The Windows™ version of the toolkit includes an abbreviated net/ethernet.h that
provides constant definitions mentioned in this section.

ETHER_ADDR_LEN

    The length of an Ethernet hardware address in bytes. The value is 6 bytes.
    On Linux™ and OS X™, this is defined in net/ethernet.h.

ETHER_CRC_LEN

    The length of an Ethernet frame FCS trailer. The value is 4 bytes. On
    Linux™ and OS X™, this is defined in net/ethernet.h. Atheros also includes
    a conditional definition in int6k/int6k.h because some Linux™ system do not
    define it anywhere.

ETHER_HDR_LEN

    The length of an Ethernet frame header including the source address,
    destination address and type/length field. The value is 14 bytes or
    ETHER_ADDR_LEN + ETHER_ADDR_LEN + ETHER_TYPE_LEN. On Linux™ and OS X™, this
    is defined in net/ethernet.h.

ETHER_MAX_LEN

    The maximum length of an Ethernet frame in bytes. The value is 1518 bytes
    of ETHER_HDR_LEN + ETHERMTU + ETHER_CRC_LEN. On Linux™ and OS X™, this is
    defined in net/ethernet.h.

ETHER_MIN_LEN

    The minimum length of an Ethernet frame in bytes. The value is 64 bytes. On
    Linux™ and OS X™ this is defined in net/ethernet.h

ETHER_TYPE_LEN

    The length of Ethernet type/length, or ethertype, field in bytes. The value
    is 2. On Linux™ and OS X™, it is defined in net/ethernet.h.

ETHERMTU

    The maximum transfer unit (ie; data handling capacity) for an Ethernet
    frame in bytes. The value is 1500 bytes. On Linux™ and OS X™, this is
    defined in net/ethernet.h

LibPcap, WinPcap and BPF

LibPcap is an open source Ethernet packet capture library that is widely used.
It provides core functionality for the Wireshark packet sniffer, formerly known
as Ethereal. LibPcap libraries are available for Linux and OpenBSD. On Linux
and OpenBSD you must link applications to libpcap.a and libwpcap.a. The toolkit
does not use either of these libraries on Linux because they are not needed
there.

WinPcap is an open source version of LibPcap written for Microsoft Windows™.
The WinPcap libraries let Windows applications send and receive raw packets. On
Windows™ you must link applications to Packet.lib and wpcap.lib.

In principle, the LibPcap and WinPcap library implementations should function
identically but they do not; however, they are similar enough to provide a
useful degree of platform independence. Defining preprocessor constants LIBPCAP
or WINPCAP when compiling the toolkit will enable the corresponding source
code. This can be done by adding "-DLIBPCAP" or "-DWINPCAP" to variable LFLAGS
in file Makefile in folders int6k, int6k2, efsu and hpav. Constant WINPCAP need
only be defined this way when compiling the toolkit using cygwin™ or mingw™
environments. Do not define both constants LIBPCAP and WINPCAP at the same time
or compiler errors will occur.

Berkeley Packet Filters (BPF) is an open source Ethernet packet capture
mechanism available on many UNIX™-like systems. Native BPF is supported on some
systems but must be explicitly compiled into the kernel on other systems.
Linux™ systems normally do not support BPF by default but Mac OS X™ does and so
we automatically use it whenever compiler constant __APPLE__ is defined. In
principle, one could compile a custom Linux™ kernel with BPF enabled.

Structure Packing

Programs in this toolkit make extensive use of packed data structures to
simplify source code and guarantee reliability; however, this creates
portability issues because different compilers implement structure packing in
different ways. Three common structure packing mechanisms are:

_packed

    The __packed keyword is not part of any C or C++ standard but it is
    recognized by some compilers, such as the ARM C/C++ and OpenBSD C compiler.
    This keyword only affects the data structure that it prefaces and it is an
    ideal way to selectively pack structures. It can be easily defined and
    undefined using a preprocessor macro. Atheros has elected to insert this
    keyword wherever it might be appropriate. The ARM C compilers accept this
    keyword.

    Example 3.5.  Packing Structures with keyword “__packed”

    typedef struct __packed header_eth
    {
            uint8_t source [ETHER_ADDR_LEN];
            uint8_t target [ETHER_ADDR_LEN];
            uint16_t protocol;
    }
    header_eth;


__attribute__ ((packed))

    Attributes are not part of any C or C++ standard but they are recognized by
    the gcc and Sun Microsystems C compiler. Attributes only affect structures
    and functions that reference them in their declaration. This is convenient
    because we can use a preprocessor macro to define the keyword __packed,
    mentioned above, to be __attribute__ ((packed)). Atheros includes this
    definition in tools/types.h and OpenBSD does this in their system header
    files.

    Example 3.6.  Packing Structures with Attribute “packed”

    typedef struct __attribute__ ((packed)) header_eth
    {
            uint8_t source [ETHER_ADDR_LEN];
            uint8_t target [ETHER_ADDR_LEN];
            uint16_t protocol;
    }
    header_eth;


#pragrma pack

    Pragmas are part of most C and C++ language standards but some compilers do
    not recognize or implement the pack pragma. In addition, different
    compilers implement it in different ways. The pack pragma affects all data
    structures up the next pack pragma or end of compile unit. Most pragma
    implementations accept the push and pop option for pragma nesting. Some
    pragma pack implementations accept no arguments, most permit either one or
    two arguments while others allow three arguments. OpenBSD does not
    recognize this pragma and generates warnings in all cases. Aside from all
    that, the pack pragma is the most widely supported method for declaring
    packed structures.

    Example 3.7.  Packing Structures with the Pragma “pack”

    #pragma pack (push, 1)
    struct header_eth
    {
            uint8_t source [ETHER_ADDR_LEN];
            uint8_t target [ETHER_ADDR_LEN];
            uint16_t protocol;
    }
    header_eth;
    #pragma pack (pop)


The Atheros Way

    Toolkit programs declares packed structures using all three methods, as
    shown below.

    Example 3.8.  Packing Structures the Atheros Way

    #ifndef __packed
    #ifdef __GNUC__
    #define __packed __attribute__ ((packed))
    #else
    #define __packed
    #endif
    #endif

    #ifndef __GNUC__
    #pragma pack (push, 1)
    #endif

    struct __packed header_eth
    {
            uint8_t source [ETHER_ADDR_LEN];
            uint8_t target [ETHER_ADDR_LEN];
            uint16_t protocol;
    }
    header_eth;

    #ifndef __GNUC__
    #pragma pack (pop)
    #endif



Endian-ness

Atheros vendor-specific messages contain information in mixed endian format.
The Ethernet header portion is sent big endian but the Atheros header and
payload are sent in little endian . The traditional endian converstion
functions htons(), htonl(), ntohs() and ntohl() can be used to perform platform
independent conversions on the Ethernet header but not the Atheros header
payload.

The Atheros Embedded API defines macros ihtons, ihtonl, intohs and intohl in
ihp.h to perform the inverse function of their standard counterparts mentioned
above. In other words, the standard endian functions do nothing on big-endian
hosts while Atheros endian functions do nothing on little-endian hosts.

The Powerline Toolkit includes similar macros HTOLE16, HTOLE32, LE16TOH and
LE32TOH in endian.h which serve the same function but conform to
recommendations for standarized byte order function on Linux, OpenBSD and
FreeBSD. Observe that the names are independent of any network implications.

#if BYTE_ORDER == BIG_ENDIAN
#       define LE16TOH(x) __bswap_16(x)
#       define LE32TOH(x) __bswap_32(x)
#       define LE64TOH(x) __bswap_64(x)
#       define HTOLE16(x) __bswap_16(x)
#       define HTOLE32(x) __bswap_32(x)
#       define HTOLE64(x) __bswap_64(x)
#elif BYTE_ORDER == LITTLE_ENDIAN
#       define LE16TOH(x) (x)
#       define LE32TOH(x) (x)
#       define LE64TOH(x) (x)
#       define HTOLE16(x) (x)
#       define HTOLE32(x) (x)
#       define HTOLE64(x) (x)
#else
#error "Undefined host byte order."
#endif

In addition, the Powerline Toolkit includes function endian that reverses byte
order over a variable-length memory region.

Packet Basics

Local and remote HomePlug® AV powerline devices are managed by sending Ethernet
frames that contain HomePlug AV® formatted management messages. These frames
have an 802.3 Ethernet header and a payload that contains the Management
Message (MM).

The Ethernet header must be transmitted in newtwork byte order which is
big-endian. The Ethernet payload must be sent in ARM™ host byte order which is
little endian. You should use standard network functions htons() and htonl() to
write Ethernet headers and ntohs() and ntohl() to read them. You should use
function HTOLE16() and HTOLE32() to write integer payload values and LE26TOH()
and LE32TOH() to read them.

+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+ ... +---+---+
| Ethernet Header                                       | Ethernet Payload    |
+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+ ... +---+---+

Ethernet headers consist of a destination address (ODA), a source address (OSA)
and an ethertype (MTYPE). The ethertype is always 0x88E1 for Homeplug frames of
any type. Programmers may use either function EthernetHeader.c or
EncodeEthernetHeader to encode a buffer with the ODA and OSA and the HomePlug
ethertype. An example appears later on. Structure header_eth is defined in
ihp.h for this purpose.

+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+ ... +---+---+
|          ODA          |          OSA          | MTYPE | Ethernet Payload    |
+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+ ... +---+---+

Management messages consist of a message header (MMHEADER) and a message entry
(MMENTRY). The message header identifies the nature of the message entry that
follows it. The acronyms MME and MMENTRY both mean Management Message Entry but
they are often used to mean the entire management message or Ethernet frame.
This imprecise usage can be confusing at times. Structure header_mme is defined
in ihp.h for this purpose.

+---+ ... +---+---+---+---+---+---+---+---+---+---+---+ ... +---+---+---+---+---+
|             | MMHEADER              | MMENTRY                                 |
+---+ ... +---+---+---+---+---+---+---+---+---+---+---+ ... +---+---+---+---+---+

The message header contains message protocol version (MMV), message type
(MMTYPE) and vendor identifier (OUI). The management message entry (MMENTRY)
that follows the header contains information unique to a the request (REQ),
confirmation (CNF), response (RSP) or indication (IND). Programmers may use the
Atheros EncodeAtherosHeader function to encode a buffer with a specific MMTYPE
and the Atheros MMV and OUI. AN example appears later on.

+---+ ... +---+---+---+---+---+---+---+---+---+---+---+ ... +---+---+---+---+---+
|             |MMV| MMTYPE|    OUI    |        MMENTRY                          |
+---+ ... +---+---+---+---+---+---+---+---+---+---+---+ ... +---+---+---+---+---+

The MMV value, within MMHEADER, indicates the Homeplug AV Management Message
protocol version which determines how the message should be interpreted. The
protocol version is defined in the HomePlug AV Specification and may change
from time to time. One notable change is the recent insertion of an FMI
(Fragment Management Information ) field between MMTYPE and OUI , as shown
below.

In most cases, protocol changes are hidden from the application by the Atheros
API functions; however, software developers should set the HOMEPLUG_MMV
constant, defined in ihp.h, to the version appropriate for their firmware or
application. The value of this constant enables or disables conditional
compilation statements throughout the HomePlug API code base.

To send an MME, you must encode an Ethernet frame buffer with information and
transmit it. To read an MME, you must read an Ethernet frame buffer and decode
it. The information necessary to encode or decode Atheros vendor-specific
Ethernet frames is covered in the INT6000™ Firmware Technical Reference Manual;
however, the Atheros HomePlug API includes many buffer encode and decode
functions that support basic operational requirements.

Frame Encoding

The following technique illustrates one way to encode a frame buffer with an
Ethernet header followed by an Atheros message header. We first declare the
frame buffer then a length variable to keep track of how many bytes have
actually been encoded. At any time, the value 'buffer + length' is the address
of the next buffer position to encode and the expression 'sizeof (buffer) -
length' is the number of un-encoded bytes remaining in the buffer. Each call to
an encoding function will increment the length for the next operation. This
technique minimizes the number of intermmediate application variables and makes
maximum use of compiler generated constants.

Example 3.9.  Frame Encoding by Offset

uint8_t buffer [ETHER_MAX_LEN];
size_t length = 0;

uint8_t OSA [ETHER_ADDR_LEN] = { 0x00, 0xB0, 0x52, 0x00, 0xD4, 0x32 };
uint8_t ODA [ETHER_ADDR_LEN] = { 0x00, 0xB0, 0x52, 0x00, 0x66, 0xF7 };
uint16_t MMTYPE = 0xA050;

length += EncodeEthernetHeader (buffer + length, sizeof (buffer) - length, uint8_t OSA, uint8_t ODA);
length += EncodeAtherosHeader (buffer + length, sizeof (buffer) - length, unit16_t MMTYPE);

if (length < sizeof (MME))
{
        error (...);
}


For those who prefer to use pointers, the following technique accomplishes the
same thing because. At any given time, the value bp - buffer is the encoded
length.

Example 3.10.  Frame Encoding by Address

uint8_t buffer [ETHER_MAX_LEN];
uint8_t bp = buffer;

bp += EncodeEthernetHeader (bp, buffer + sizeof (buffer) - bp, uint8_t OSA, uint8_t ODA);
bp += EncodeAtherosHeader (bp, buffer + sizeof (buffer) - bp, unit16_t MMTYPE);

if (bp < (buffer + sizeof (MME)))
{
        error (...);
}


Chapter 4.  Firmware

Table of Contents

Introduction
Firmware Components

    Bootloader
    Softloader
    Memory Configuration Parameters
    Runtime Firmware (MAC Software)
    Parameter Information Block (PIB)

Architecture Overview
Firmware Boot Process
Boot from Host Configuration
Things to Remember
Every Little Bit Hurts
Liar! Liar! Pants on Fire!
But wait! There's more ...
Upgrade Device (INT6000/INT6300/INT6400)
Update Local Host (INT6000/INT6300/INT6400)
Boot from Host (INT6000)
Boot from Host (INT6300)
Boot from Host (INT6400)
Boot from Host (AR7400)
Boot from Host (AR7420)
Flash Memory (AR6410/AR7420)

Introduction

An Atheros chipset consists of an integral CPU, ROM and proprietary circuitry.
The CPU requires a minimum amount of external SDRAM to execute runtime software
and store runtime configurtation parameters. The INT6000™ chipset also requires
a minimum amount of external flash memory in order to start. The INT6300™ can
use external flash memory in the same way as the INT6000™ or it can use a local
host processor as surrogate flash memory.

On startup, the SDRAM memory controller must be configured before runtime
firmware and parameters are loaded. On the INT6000™, runtime firmware and
configuration parameters must be loaded from external flash memory. On the
INT6300™, it may be loaded from external flash memory or from a external host
processor. Runtime firmware determines device capability. Runtime configuration
parameters determine device network identity and personality.

The following sections identify and describe firmware related components and
discuss some of the routine actions required to manage them. Consult the
Atheros HomePlug AV Hardware Technical Reference Manual and HomePlug AV
Firmware Technical Reference Manual for more information.

Firmware Components

Device initialization involves the following components. They are described
here and then referenced throughout the toolkit documentation. You may want to
read and re-read this page.

Bootloader

The Bootloader is permanent software burned into the chipset. The INT6000™ and
INT6300™ both have a Bootloader program but they behave differently because the
INT6000™ needs flash memory and the INT6300™ does not. Neither the INT6000™
Bootloader nor the INT6300™ Bootloader can write to flash memory.

On startup, the INT6000™ Bootloader attempts to load runtime firmware from
flash memory into SDRAM. If flash memory is not available, or the runtime
firmware stored there cannot be loaded, then the INT6000™ Bootloader cannot
continue so the device cannot function.

On startup, the INT6300™ Bootloader attempts to load runtime firmware from
flash memory into SDRAM. If flash memory is not available, or the runtime
firmware stored there cannot be loaded, then Bootloader will request runtime
firmware from the local host processor.

Softloader

An optional program stored in flash memory in place of runtime firmware. This
program is used on the INT6000™ to support the Boot From Host operation, if
needed. It is not used on the INT6300™ because the INT6300™ Bootloader now
performs similar functions. The Softloader cannot write to flash memory.

On startup, the INT6000™ Bootloader loads the Softloader from flash memory into
SDRAM, as it would do with runtime firmware. The Softloader then requests the
actual runtime firmware from local host.

Memory Configuration Parameters

A small block of information that describes the type, size and characteristics
of the SDRAM available for the benefit of the Bootloader. On the INT6000, SDRAM
configuration must be stored in flash memory. On the INT6300, it may be stored
in flash memory or on the local host. The INT6300™ Bootloader attempts to read
configuration information from flash memory when it is present; otherwise, it
requests that information from the local host using a VS_HST_ACTION message and
so the host must store this information until it is requested.

There are two SDRAM configuration file formats. The first format is used by the
Windows Device Manager and the int6k2 program and typically has a .config file
extension. The second format is used by the int6k program and int6kf program
and typically has a .cfg file extension. The latter format is more robust and
should eventually replace the format.

The Windows Device Manager form consists of 64 hexadecimal ASCII characters.
Files are at least 64 bytes but only the first 64 bytes are used. Files can be
modified using a text editor. ASCII hex to binary conversion and checksum
computation is needed on input. The config2cfg program can be used to convert
this format to Powerline Toolkit format.

The Powerline Toolkit format consists of 32 binary bytes plus a 4 byte
checksum. The file size is exactly 36 bytes. No conversion or checksum
computation is needed on input. The chkcfg program can be used the validate
this file format because it contains a checksum.

The INT6400™ chipset does not need a memory configuration parameter file
because it has a different memory controller than earlier chipsets. SDRAM is
now configured dynamically by an applets stored in the .nvm file.

Runtime Firmware (MAC Software)

The executable image that determines INT6000™ or INT6300™ capability and
functionality. Runtime firmware refers to any executable image except the
Bootloader which is considered to be boot firmware. Firmware files have a .nvm
extension and can contain multiple firmware images. One of these images could
be the parameter information block but Atheros currently distributes that as a
seperate file. The chknvm program can be used to detect obsolete or corrupt
.nvm files. Runtime firmware can write to flash memory and must be running in
order to re-program the chipset.

Parameter Information Block (PIB)

The configuration image that determines device network identity, functional
capability and operational mode. The PIB structure often changes from one major
firmware release to the next and often is not portable across major releases.
Parameter information files have a .pib extension by convention and contain one
parameter set. The chkpib program can be used to detect obsolete or corrupt PIB
files.

Recent firmware releases support two PIB images in flash memory: the Factory
PIB and the User PIB. The Factory PIB is the first PIB image written to flash
memory. Once written, the Factory PIB cannot be changed without special
software. The User PIB is created and over-written whenever the device needs to
save new PIB parameters. Factory default values are restored by erasing the
User PIB and rebooting the device. When a device reboots, it attempts to load
the User PIB from flash memory. Failing that, it attempts to load the Factory
PIB from flash memory. Failing that, it loads a Default PIB having minimum
functionality. The loaded PIB becomes the Working PIB and determines runtime
device identity and behavior.

Architecture Overview

The following figure illustrates a hypothetical powerline network consisting of
two devices. Each device has an INT6300™ with optional dedicated flash memory
and an onboard processor with associated storage. The processor in each device
is the local host for that device and the remote host for the other device. The
processor storage is unspecified but it must be persistent. The two devices are
connected via coax or powerline. The flash memory is optional in this design
because it uses the INT6300™ chipset.

Figure 4.1.  Simple Network

                                Simple Network


The Boot Loader is permanent program that executes on startup. It detects the
presence of flash memory and attempts to read SDRAM configuration from flash
memory then load and runtime the firmware image and PIB from flash memory. On
success, the Boot runtime firmware starts and the device assumes HomePlug AV
compliant behavior. On failure, the Boot Loader requests SDRAM configruation,
runtime firmware image and PIB from the local host. The local host must be
prepared to respond to these requests.

On a system having no flash memory, the Boot Loader will request SDRAM
configuration information from the local host. Once that is received, the Boot
Loader will request a firmware image and PIB from the local host. The local
host determines which firmware image and PIB to download, manages the download
sequence and starts firmware execution.

Atheros software, such as the Windows Device Manager, Linux Flash Utility and
Embedded API all support the Boot from Host configuration.

Once the firmware is running on the INT6300™ , a remote host can forward
runtime firmware and PIB to the local host via the INT6300™ firmware. The
remote host might reside on anotherINT6300™ device, as shown in the previous
figure, or be located anywhere on the HomePlug® AV network. In either case, the
operations described are the same.

Firmware Boot Process

The INT6300™ can boot HomePlug AV firmware from either dedicated flash memory
or a local host processor. This means that dedicated flash memory in not
necessary when an onboard processor having persistent storage is available. The
absence of dedicated flash memory and availability of an onboard host processor
is called a Boot from Host configuration.

The Boot from Host configuration is of interest to customers who are committed
to using a host processor in their INT6300™ based product and want to use it to
eliminate the additional cost of dedicated flash memory to store HomePlug AV
firmware for INT6300™ devices.

The Boot from Host configuration supports three operations: Upgrade Device,
Update Local Host and Boot from Host. Product designers must write host
software to support all three operations as described later in this document.
Atheros provides an Embedded Application Program Interface to assist product
designers with this effort. Obtain a copy of the HomePlug AV Application
Programming Interface User's Guide from Atheros Communications, Ocala FL USA
for more information.

Readers should not confuse a Boot from Host configuration with the Boot from
Host operation. The former is a hardware configuration having an INT6300™ with
no dedicated flash memory available. The latter is the process of downloading
configuration information, firmware and PIB from the local host to the device
and starting firmware execution on startup.

This discussion assumes that the reader is familiar with the following:

 1. The distinction between a local and remote host

 2. The relationship between the powerline device H1, M1 and PHY interfaces.

 3. The structure of the following Atheros Management Message types:
    VS_HST_ACTION, VS_SET_SDRAM, VS_WR_MEM, VS_WR_MOD, VS_RS_DEV, VS_ST_MAC and
    VS_WRITE_AND_EXECUTE. Be aware that message types VS_SET_SDRAM, VS_WR_MEM,
    VS_WR_MOD and VS_ST_MAC are deprecated and will no longer be supported by
    the newest firmware.

 4. Hardware architecture covered in the QCA Powerline Hardware Technical
    Reference Manual and the management message formats covered in the QCA
    Powerline Firmware Technical Reference Manual.

Boot from Host Configuration

The Boot from Host configuration requires a permanent connection between the
powerline device and a local host having some type of persistent storage. In
most cases, the poserline device and local host are co-located, possibly on the
same board or same chip, and act together as an integral unit. Essentially, the
local host provides persistent memory for the device.

The Boot from Host configuration lets the local host decide which runtime
parameters and firmware to download on startup. This offers a considerable
degree of product adaptability, allowing different parameter and firmware
combinations to be downloaded based on external factors.

In a Boot from Host configuration, the processor must act as local host while
the device is booting but it can also act as remote host when upgrading other
devices. The former is a design requirement and latter is a design option.

Things to Remember

The Boot from Host configuration offers design flexibility but also increases
the possibilities. Remember that the processes described here are based on
simple rules that ultimatey dictate why each process step is needed. Readers
may find it helpful to review these rules.

 1. The softloader and bootloader programs have limited vocabulary.

    The INT6000™ softloader recognizes only the VS_SW_VER, VS_ST_MAC,
    VS_RS_DEV, VS_WR_MOD requests. It does not recognize VS_WR_MEM.

    The INT6300™ bootloader recognizes only the VS_SW_VER, VS_WR_MEM,
    VS_ST_MAC, VS_RS_DEV and VS_SET_SDRAM requests. It does not recognize
    VS_WR_MOD.

    The INT6400™ bootloader recognizes only the VS_SW_VER, VS_WR_MEM,
    VS_ST_MAC, VS_RS_DEV requests. It recognizes VS_SET_SDRAM and responds to
    it but ignores it. It does not recognize VS_WR_MOD.

    The AR7400™ bootloader recognizes only VS_SW_VER, VS_WR_MEM, VS_ST_MAC,
    VS_RS_DEV requests. It recognizes VS_SET_SDRAM and responds to it but
    ignores it. It does not recognize VS_WR_MOD.

    The AR7420™ bootloader recognizes only VS_SW_VER, VS_RS_DEV,
    VS_WRITE_AND_EXECUTE and VS_RAND_MAC_ADDRESS requests. Early versions
    recognize VS_WRITE_MEM and VS_ST_MAC requests but they must not be used.

    Table 4.1.  Softloader/Bootloader MMEs

    ┌──────┬────────────────────┬──────────┬──────────┬──────────┬──────────┬──────────┐
    │ MME  │        NAME        │ INT6000  │ INT6300  │ INT6400  │  AR7400  │  AR7420  │
    │      │                    │Softloader│Bootloader│Bootloader│Bootloader│Bootloader│
    ├──────┼────────────────────┼──────────┼──────────┼──────────┼──────────┼──────────┤
    │0xA000│VS_SW_VER           │Yes       │Yes       │Yes       │Yes       │Yes       │
    ├──────┼────────────────────┼──────────┼──────────┼──────────┼──────────┼──────────┤
    │0xA008│VS_WR_MEM           │No        │Yes       │Yes       │Yes       │Deprecated│
    ├──────┼────────────────────┼──────────┼──────────┼──────────┼──────────┼──────────┤
    │0xA00C│VS_ST_MAC           │Yes       │Yes       │Yes       │Yes       │Deprecated│
    ├──────┼────────────────────┼──────────┼──────────┼──────────┼──────────┼──────────┤
    │0xA01C│VS_RS_DEV           │Yes       │Yes       │Yes       │Yes       │Yes       │
    ├──────┼────────────────────┼──────────┼──────────┼──────────┼──────────┼──────────┤
    │0xA020│VS_WR_MOD           │Yes       │No        │No        │No        │No        │
    ├──────┼────────────────────┼──────────┼──────────┼──────────┼──────────┼──────────┤
    │0xA05C│VS_SDRAM            │No        │Yes       │Ignored   │Ignored   │No        │
    ├──────┼────────────────────┼──────────┼──────────┼──────────┼──────────┼──────────┤
    │0xA060│VS_HOST_ACTION      │No        │Yes       │Yes       │Yes       │Yes       │
    ├──────┼────────────────────┼──────────┼──────────┼──────────┼──────────┼──────────┤
    │0xA098│VS_WRITE_AND_EXECUTE│No        │No        │No        │Yes       │Yes       │
    ├──────┼────────────────────┼──────────┼──────────┼──────────┼──────────┼──────────┤
    │0xA0D4│VS_RAND_MAC_ADDRESS │No        │No        │No        │Yes       │Yes       │
    └──────┴────────────────────┴──────────┴──────────┴──────────┴──────────┴──────────┘

 2. The Softloader, Bootloader and runtime firmware may treat the same MME
    differently because each is a different program. A notorious obvious
    example is the VS_SW_VER message type. This means that one may need to be
    aware of the device state when anticipating device behaviour or
    interpreting device response.

 3. The local host is surrogate flash memory. When dedicated flash memory is
    not available to a device, the device will request firmware and parameter
    storage services from the local host using VS_HST_ACTION messages. The
    local host must be programmed to detect and respond to these messages or
    the firmware will appear to hang. See program int6khost, int64host, amphost
    or plchost to demonstrate and experiment with this iteraction.

 4. Only runtime firmware can write flash memory. Runtime firmware must be
    executing in order to write flash memory or upload to the local host. The
    Softloader and Bootloader cannot perform either operation.

 5. All PIB changes must be written in flash memory. There are several things
    that can cause PIB changes. When a PIB change is needed, the Working PIB is
    copied to a scratch area and modified there. The Scratch PIB must then be
    written to flash memory or sent to the local host for storage. The device
    then resets causing the stored PIB to replace the Working PIB. If a freshly
    downloaded PIB changes for any reason then the cycle will repeat,
    automatically.

 6. Runtime firmware updates the PIB after joining and before leaving an AVLN.
    This will cause a device reset in each case. If the device is using the
    local host for persistent storage, runtime firmware will send the
    associated VS_HST_ACTION messages to the host and the host will send the
    associated VS_RD_MOD and VS_RS_DEV messages as per Update Local Host.

Every Little Bit Hurts

With the addition of Push Button Encryption, and other planned features,
runtime firmware can now modify the PIB. Consequently, host applications must
not assume that the PIB has not changed since it was last downloaded. Atheros
strongly recommends that applications always perform a read-modify-write when
making PIB modifications. Failure to do so can result in infinite reset loops
caused when a device modifies the PIB that has just been downloaded.

As one example, recent PIBs contain a network membership bit to indicate that
the device has successfully joined the network associated with the current NMK.
If the firmware detects the network and discovers that the membership bit is
clear then it will join the network and set the bit. The firmware will then
attempt to preserve the change by sending a VS_HOST_ACTION message to the local
host. If the host application does not upload and store the changed PIB (as the
device requested) before resetting the device then the original PIB will be
downloaded again, after reset, and the process will repeat. Of course, a
similar situation will occur when the device leaves the network and again when
it joins another network.

Liar! Liar! Pants on Fire!

It is important to use the right Boot from Host sequence for each type of
Atheros device. This means that you should query the device using a VS_SW_VER
message beforehand to determine or confirm the device type. Although this
should be a simple operation, there have been several changes that complicate
matters.

 1. The INT6300™ Bootloader incorrectly identifies the chipset as an INT6000™
    chipset in the MDEVICEID field of the VS_SW_VER message.

 2. The AR7400™ Bootloader incorrectly identifies the chipset as an INT6400™
    chipset in the MDEVICEID field of the VS_SW_VER message.

 3. The Bootloader, for INT6400™ chipsets and later, returns two additional
    field, IDENT and STEP_NUMBER in the VS_SW_VER confirmation message. These
    fields, the hardware identifier and step number, are correct but are not
    returned in earlier chipsets.

The table below illustrates what is reported by various firmware, in the
DEVICEID field of the VS_SW_VER message, on each type of hardware platform.

Table 4.2.  Legacy Device Identification

┌───────┬────────────┬────────────┬──────────┬───────────────────────────────────────────┐
│       │ DEVICEID/  │  MVERSION  │DEVICEID/ │                                           │
│Chipset│   IDENT    │(Bootloader)│  IDENT   │            MVERSION (Firmware)            │
│       │(Bootloader)│            │(Firmware)│                                           │
├───────┼────────────┼────────────┼──────────┼───────────────────────────────────────────┤
│INT6000│0x01 /      │BootLoader  │0x01 / na │INT6000-MAC-0-0-3213-1206-20071224-FINAL   │
│       │0x00000042  │            │          │                                           │
├───────┼────────────┼────────────┼──────────┼───────────────────────────────────────────┤
│INT6300│0x02 /      │BootLoader  │0x02 / na │INT6300-MAC-0-0-4203-00-4089-20091105-FINAL│
│       │0x00006300  │            │          │                                           │
├───────┼────────────┼────────────┼──────────┼───────────────────────────────────────────┤
│INT6400│0x03 /      │BootLoader  │0x03 / na │INT6400-MAC-4-3-4304-01-4397-20100924-FINAL│
│       │0x00006400  │            │          │                                           │
├───────┼────────────┼────────────┼──────────┼───────────────────────────────────────────┤
│INT7400│0x03 /      │BootLoader  │0x04 / na │INT7400-MAC-5-2-5213-01-1027-20110428-FINAL│
│       │0x00007400  │            │          │                                           │
├───────┼────────────┼────────────┼──────────┼───────────────────────────────────────────┤
│INT7450│0x03 /      │BootLoader  │0x20 /    │QCA7450-MAC-5-2-5213-01-1027-20110428-FINAL│
│       │0x0F001D1A  │            │0x00001D1A│                                           │
├───────┼────────────┼────────────┼──────────┼───────────────────────────────────────────┤
│INT7451│0x03 /      │BootLoader  │0x20 /    │QCA7451-MAC-5-2-5213-01-1027-20110428-FINAL│
│       │0x00007400  │            │0x0E001D1A│                                           │
├───────┼────────────┼────────────┼──────────┼───────────────────────────────────────────┤
│AR6405 │0x03 /      │BootLoader  │0x05 / na │INT6405-MAC-4-3-4304-01-4397-20100924-FINAL│
│       │0x00006400  │            │          │                                           │
├───────┼────────────┼────────────┼──────────┼───────────────────────────────────────────┤
│AR7420 │0x05 /      │BootLoader  │0x20 /    │MAC-QCA7420-2.5.14.2259-23-20110621-FINAL  │
│       │0x001CFCFC  │            │0x001CFCFC│                                           │
├───────┼────────────┼────────────┼──────────┼───────────────────────────────────────────┤
│QCA6410│0x05 /      │BootLoader  │0x21 /    │MAC-QCA6410-2.5.14.2259-23-20110621-FINAL  │
│       │0x001B58EC  │            │0x001B58EC│                                           │
├───────┼────────────┼────────────┼──────────┼───────────────────────────────────────────┤
│QCA6411│0x05 /      │BootLoader  │0x21 /    │MAC-QCA6411-2.5.14.2259-23-20110621-FINAL  │
│       │0x001B58BC  │            │0x001B58BC│                                           │
├───────┼────────────┼────────────┼──────────┼───────────────────────────────────────────┤
│QCA7000│0x05 /      │BootLoader  │0x22 /    │MAC-QCA7000-1.4.13.3259-43-20110621-FINAL  │
│       │0x001B589C  │            │0x001B589C│                                           │
└───────┴────────────┴────────────┴──────────┴───────────────────────────────────────────┘


To properly detect the correct chipset perform the following steps.

 1. Send a VS_SW_VER request message from the local host to the local device
    using the Atheros Local Management Address.

 2. Read the VS_SW_VER confirm message returned to the host by the device.

 3. Extract and save the MDEVICEID field (a small integer) and the MVERSION
    field (a string).

 4. If the MVERSION string is “SoftLoader” then the MDEVICEID field is valid.

 5. If the MVERSION string is not “BootLoader” then the MDEVICEID field is
    valid unless it is 0x07. In that case, set the stored DEVICEID to 0x04 to
    indicate an AR7400™. Do not inspect the IDENT field because it does not
    exist in the firmware version of the VS_SW_VER message on any platform.

 6. If the MDEVICEID field is 1, indicating an INT6000™, then the chipset is
    actually an INT6300™. Set the stored MDEVICEID to 2, indicating an
    INT6300™. Do not inspect the IDENT field because it does not exist in the
    BootLoader version of the VS_SW_VER message for either of these two
    chipsets.

 7. If the MDEVICEID field is 3, indicating an INT6400™, then the chipset could
    be either an INT6300™ or an AR7400™. Inspect the IDENT field.

 8. If the IDENT field is 0x6400, indicating an INT6400™, then the stored
    MDEVICEID is valid.

 9. If the IDENT field is 0x7400, indicating an AR7400™, then set the stored
    MDEVICEID to 4, indicating an AR7400™.

Having performed the previous conversions, the expression (1 << (DEVICEID - 1))
now indicates the proper IGNORE bit found in each NVM file header.
Unfortunately, this only works for DeviceID values from 0x01 through 0x06.
After that, the device identification scheme changes.

But wait! There's more ...

Starting with the AR7420™, the DeviceID field in VS_SW_VER is now the
DEVICE_CLASS field and identifies the “Device Family”, not the device type.
Instead, the IDENT field in VS_SW_VER identifies the device type and the IDENT
field is located at a variable offset within the message frame. Previously, the
IDENT was located a fixed offset within the frame.

Table 4.3.  Device Identification

┌───────┬──────────┬──────────┬────────┬──────────┐
│Chipset│Softloader│Bootloader│Firmware│ Identity │
├───────┼──────────┼──────────┼────────┼──────────┤
│INT6000│0x01      │          │0x01    │0x00000042│
├───────┼──────────┼──────────┼────────┼──────────┤
│INT6300│          │0x01      │0x02    │0x00006300│
├───────┼──────────┼──────────┼────────┼──────────┤
│INT6400│          │0x03      │0x03    │0x00006400│
├───────┼──────────┼──────────┼────────┼──────────┤
│AR7400 │          │0x03      │0x04    │0x00007400│
├───────┼──────────┼──────────┼────────┼──────────┤
│AR6405 │          │0x03      │0x05    │0x00006400│
├───────┼──────────┼──────────┼────────┼──────────┤
│AR7420 │          │0x05      │0x20    │0x001CFCFC│
├───────┼──────────┼──────────┼────────┼──────────┤
│QCA6410│          │0x05      │0x21    │0x001B58EC│
├───────┼──────────┼──────────┼────────┼──────────┤
│QCA7000│          │0x05      │0x22    │0x001B589C│
└───────┴──────────┴──────────┴────────┴──────────┘


Upgrade Device (INT6000/INT6300/INT6400)

The Upgrade Device operation downloads firmware and/or PIB from a remote host
to an Atheros device for permanent storage and immediate execution. The device
determines where and how it will store the information based on the
availability of onboard flash memory. If the device has dedicated flash memory
then it will store the firmware and PIB there and reset itself; otherwise, it
will hand the firmware and PIB to the local host for storage and the local host
will reset the device. The reset ensures that new formware and PIB take
immediate effect once they are saved. This operation requires custom software
on the remote host and Atheros firmware on the device.

Figure 4.2.  Upgrade Device (INT6000/INT6300/INT6400)


        REMOTE-HOST                        INT6300/INT6400
        [01] |-------- VS_WR_MOD.REQ ------------>| [01]
        [01] |<------- VS_WR_MOD.CNF -------------| [01]
        [01] |----------------------------------->| [01]
        [01] |<-----------------------------------| [01]
             |                                    |
        [02] |-------- VS_WR_MOD.REQ ------------>| [02]
        [02] |<------- VS_WR_MOD.CNF -------------| [02]
        [02] |----------------------------------->| [02]
        [02] |<-----------------------------------| [02]
             |                                    |
        [03] |-------- VS_MOD_NVM.REQ ----------->| [04]
        [05] |<------- VS_MOD_NVM.CNF ------------| [04]
             |                                    | [06]



 1. Optionally, the remote host writes firmware to the device by sending a
    series of VS_WR_MOD.REQ messages and waiting for a VS_WR_MOD.CNF message
    after each one. The message MODULEID field is set to 0x01 for this
    operation.

 2. Optionally, the remote host writes the PIB to the device by sending
    VS_WR_MOD.REQ messages and waiting for a VS_WR_MOD.CNF message after each
    one. The MODULEID is set to 0x02 for this operation.

 3. The remote host commits the firmware and/or PIB to persistent storage by
    sending a VS_MOD_NVM.REQ message and waiting for a VS_MOD_NVM.CNF message.

 4. The device received the VS_MOD_NVM.REQ and sends a VS_MOD_NVM.CNF message
    to the remote host.

 5. The remote host receives the VS_MOD_NVM.CNF and proceeds with other
    activity. The remote host does not know or care that the device may not
    have dedicated flash memory available.

 6. The device determines where and how to store the information. If dedicated
    flash memory is available, the device writes the downloaded firmware and
    PIB to flash memory and performs a software reset that results in a normal
    Boot from Flash operation. If no dedicated flash memory is available, the
    device initiates an Update Local Host operation.

The device does not notify the remote host when the upgrade operation
completes. It is therefore incumbent on the remote host to determine ultimate
success or failure by polling the device, possiby using a VS_SW_VER.REQ
message, until a response is received. The complete upgrade operation can take
from 20 seconds to 45 seconds depending on device configuration.

Update Local Host (INT6000/INT6300/INT6400)

The Update Local Host operation transfers a firmware image and/or PIB image
from the device to the local host for permanent storage. After the firmware and
PIB are stored, the local host will reset the device and the device will
retrieve parameters and firmware using the Boot from Host operation described
in the next section.

The firmware may initiate this operation after a remote host has downloaded new
firmware or PIB and issued a VS_MOD_NVM.REQ to the device, the device has been
asked to restore factory default settings or the firmware has dynamically
altered the runtime PIB in some way. Consequently, the device will be reset by
the host in each case.

The device initiates this operation to complete an Upgrade Device operation
when the device has no dedicated flash memory onboard. This operation requires
running Atheros firmware on the device and custom software on the local host.

Figure 4.3.  Update Local Host (INT6000/INT6300/INT6400)


      INT6300/INT6400                           LOCAL-HOST
        [01] |-------- VS_HOST_ACTION.IND ------->| [01]
        [03] |<------- VS_HOST_ACTION.RSP --------| [02]
             |                                    |
        [04] |<------- VS_RD_MOD.REQ -------------| [04]
        [04] |-------- VS_RD_MOD.CNF ------------>| [04]
        [04] |<-----------------------------------| [04]
        [04] |----------------------------------->| [04]
             |                                    |
        [05] |<------- VS_RD_MOD.REQ -------------| [05]
        [05] |-------- VS_RD_MOD.CNF ------------>| [05]
        [05] |<-----------------------------------| [05]
        [05] |----------------------------------->| [05]
             |                                    |
        [06] |<------- VS_RS_DEV.REQ -------------| [06]
        [07] |-------- VS_RS_DEV.CNF ------------>| [07]



 1. The runtime firmware initiates this operation by broadcasting
    VS_HOST_ACTION.IND messages every 500 milliseconds. The HOST_ACTION_REQ
    field of the message can be either 0x01, 0x02 or 0x03 to indicate that a
    firmware image, a paramter block image or both are ready for upload by the
    local host.

 2. The local host sends a VS_HOST_ACTION.RSP message to the device to indicate
    the ability and willingness to upload the information. The MSTATUS field is
    set to 0x00 for affirmative and 0x01 for negative.

 3. Assuming an affirmative response, the device stops broadcasting and will
    wait indefinitely for local host action.

 4. Optionally, the local host reads the firmware image from the device by
    sending a series of VS_RD_MOD.REQ messages to the device and waiting for a
    VS_RD_MOD.CNF message after each one. The message MODULEID field is set to
    0x01 for this operation.

 5. Optionally, the local host reads the PIB from the device by sending a
    series of VS_RD_MOD.REQ messages to the device and waiting for a
    VS_RD_MOD.CNF message after each one. The message MODULEID field is set to
    0x02 for this operation.

 6. The local host sends a VS_RS_DEV.REQ message to the device to initiate a
    firmware reboot.

 7. The device sends a VS_RS_DEV.CNF to the host and performs a software reset.
    This forces a Boot from Host.

Boot from Host (INT6000)

The Boot from Host operation downloads a firmware image and PIB image from the
local host and starts firmware execution. The process is initiated by the
INT6000™ Bootloader following a device reset. The Bootloader passes control to
the INT6000™ Softloader to negotiate with the local host. The process
thererfore requires Softloader aware software running on the local host in
order to complete.

The device does not have a unique hardware address until the firmware starts
and assigns one. Until that time, the Softloader accepts messages addressed to
00:B0:52:00:00:01. In addition, the Softloader does not know the hardware
address of the local host and so it addresses VS_HST_ACTION messages to
FF:FF:FF:FF:FF:FF; however, these messages are not forwarded over powerline.

Figure 4.4.  Boot from Host (INT6000)


          INT6000                             LOCAL-HOST
        [01] |                                    |
        [02] |-------- VS_HST_ACTION.IND -------->| [03]
        [05] |<------- VS_HST_ACTION.RSP ---------| [04]
             |                                    |
        [07] |<------- VS_WR_MOD.REQ -------------| [07]
        [07] |-------- VS_WR_MOD.CNF ------------>| [07]
        [07] |<-----------------------------------| [07]
        [07] |----------------------------------->| [07]
             |                                    |
        [08] |<------- VS_WR_MOD.REQ -------------| [08]
        [08] |-------- VS_WR_MOD.CNF ------------>| [08]
        [08] |<-----------------------------------| [08]
        [08] |----------------------------------->| [08]
             |                                    |
        [10] |<------- VS_ST_MAC.REQ -------------| [09]
        [11] |-------- VS_ST_MAC.CNF ------------>| [12]




 1. The INT6000™ Bootloader automatically starts after device reset. It reads
    the Softloader from NVRAM, writes it into SDRAM and starts execution. The
    Softloader then manages the Boot from Host process.

 2. The Softloader broadcasts a VS_HST_ACTION.IND message every 500
    milliseconds to request the download of runtime firmware and PIB. The
    HOST_ACTION_REQ field of the message is 0x00 in this case. The message
    source address if 00:B0:52:00:00:01 as explained above.

 3. The local host receives the VS_HST_ACTION.IND message and inspects the
    HOST_ACTION_REQ field to determine action requested. It may then elect to
    service the request or ignore it. On a single-host system, the host must
    service the request or the device will not start. On a multi-host system,
    one of the hosts must elect to service the request or the device will not
    start.

 4. The local host sends a VS_HST_ACTION.RSP message to the device to indicate
    the ability and willingness to service the request. The MSTATUS field is
    set to 0x00 for affirmative and 0x01 for negative.

 5. The Softloader receives the VS_HST_ACTION.RSP from the host and inspects
    the MSTATUS field. On affirmative status, the Softloader stops sending
    VS_HST_ACTION messages and waits indefinitely for the firmware image and
    PIB.

 6. The local host determines which firmware image and PIB to download. In some
    cases there may be no choice. In other cases, there may be a choice between
    default and custom software or between current and upgraded software. This
    is a principle design issue to consider.

 7. The local host downloads a firmware image to the device by sending
    VS_WR_MOD.REQ messages to the device and waiting for a VS_WR_MEM.CNF
    messages from the device after each request. Each message contains an image
    segment, the memory offset, the segment length and the checksum used to
    monitor and manage download progress. If a single transaction fails, the
    local host should detect it and repeat it.

 8. The local host downloads a PIB to the device by sending VS_WR_MOD.REQ
    messages to the device and waiting for a VS_WR_MEM.CNF message from the
    device after each request. Each message contains an image segement, the
    memory offset, the segment length and the checksum used to monitor and
    manage download progress. If a single transaction fails, the local host
    should detect it and repeat it.

 9. The local host starts execution of the downloaded firmware by sending a
    VS_ST_MAC.REQ message to the device. The message contains the start address
    for the firmware.

10. The Softloader receives the VS_ST_MAC.REQ from the local host, validates
    the content.

11. The Softloader sends a VS_ST_MAC.CNF message to the local host to indicate
    an ability or willingness to start execution. Assuming an ability and
    willingness, the Softloader immediately starts firmware execution which
    relinquishes device control to the firmware.

12. The local host receives the VS_ST_MAC.CNF message from the device, inspects
    the MSTATUS field and acts accordingly. Assuming an affirmative status,
    this process terminates.

Boot from Host (INT6300)

The boot-from-host operation downloads SDRAM configuration information, runtime
parameters and runtime firmware from a local host and starts firmware
execution. This method is initiated by the device bootloader after reset reset
if the device has no flash memory, blank flash memory or corrupted flash
memory. The method requires the bootloader aware software running on the local
host to detect and service VS_HOST_ACTION messages from the device.

The INT6300™ boot-from-host method is similar to the INT6000™ method but it has
an extra stage to download SDRAM configuration parameters and it uses VS_WR_MEM
messages to download runtime paramters and firmware instead of VS_WR_MOD
messages. The VS_WR_MEM messages write directy to SDRAM and an VS_ST_MAC
message is needed to start firmware execution. Once the firmware is running,
another method is used to write runtime parameters and firmware to flash
memory.

The INT6300™ does not have a unique hardware address until runtime firmware
starts and assigns one from the runtime parameter block. Until that time, the
bootloader will accept messages addressed to 00:B0:52:00:00:01. In addition,
the bootloader does not know the hardware address of the local host and so it
addresses VS_HOST_ACTION messages to FF:FF:FF:FF:FF:FF; however, these messages
are not transmitted over the powerline.

Figure 4.5.  boot-from-host (INT6300)


         INT6300                             LOCAL-HOST
        [01] |                                    |
        [02] |-------- VS_HOST_ACTION.IND ------->| [03]
        [05] |<------- VS_HOST_ACTION.RSP --------| [04]
             |                                    |
        [07] |<------- VS_SET_SDRAM.REQ ----------| [06]
        [07] |-------- VS_SET_SDRAM.CNF --------->| [08]
             |                                    | [09]
        [10] |<------- VS_WR_MEM.REQ -------------| [10]
        [10] |-------- VS_WR_MEM.CNF ------------>| [10]
        [10] |<-----------------------------------| [10]
        [10] |----------------------------------->| [10]
             |                                    |
        [11] |<------- VS_WR_MEM.REQ -------------| [11]
        [11] |-------- VS_WR_MEM.CNF ------------>| [11]
        [11] |<-----------------------------------| [11]
        [11] |----------------------------------->| [11]
             |                                    |
        [13] |<------- VS_ST_MAC.REQ -------------| [12]
        [14] |-------- VS_ST_MAC.CNF ------------>| [15]




 1. The bootloader automatically starts after device reset and attempts to read
    the runtime firmware image from flash memory, write it into SDRAM and start
    execution. If it succeeds then normal operation begins and no futher action
    is required. If it fails, for any reason, then the bootloader starts the
    boot-from-host process.

 2. The bootloader broadcasts VS_HOST_ACTION.IND with HOST_ACTION_REQ set to
    0x04 to indicate that configuration is required. The destination address is
    FF:FF:FF:FF:FF:FF and the source address is 00:B0:52:00:00:01 as explained
    above. This message is sent every 10 seconds which differs from that of
    other chips.

 3. The host receives the VS_HOST_ACTION.IND message and inspects the
    HOST_ACTION_REQ field to determine the action requested. On a single-host
    system, the local host must elect to service the request or the device will
    not start. On a multi-host system, one of the hosts must elect to service
    the request of the device will not start.

 4. The host sends a VS_HOST_ACTION.RSP message to the device to indicate an
    ability and willingness to service the request. The MSTATUS field is set to
    0x00 for affirmative and 0x01 for negative.

 5. The bootloader receives the VS_HOST_ACTION.RSP from the host and inspects
    the MSTATUS field. On affirmative response, the bootloader stops
    broadcasting VS_HOST_ACTION.IND and waits indefinitely for SDRAM
    configuration information from the host.

 6. The host sends a VS_SET_SDRAM.REQ message to the device containing an SDRAM
    configuration block and the block checksum.

 7. The bootloader receives the VS_SET_SDRAM.REQ, validates the content,
    initializes SDRAM parameters and sends a VS_SET_SDRAM.CNF message to the
    servicing host to indicate either success or failure.

 8. The local host receives the VS_SET_SDRAM.CNF and inspects the MSTATUS field
    for success or failure. Assuming success, the local host waits indefinitely
    for further requests from the device.

 9. The local host determines which parameter block and firmware image to
    download. In some cases there may be no choice. In other cases, there may
    be a choice between default and custom software or between current and
    upgraded software. This is a principle design issue to consider.

10. The local host downloads the firmware image to the device by sending
    VS_WR_MEM.REQ messages to the device and waiting for a VS_WR_MEM.CNF
    messages from the device after each request. Each message contains an image
    segment, the memory offset, the segment length and the checksum used to
    monitor and manage download progress. It a single transaction fails, the
    local host should detect it and repeat it.

11. The local host downloads a parameter block to the device by sending
    VS_WR_MEM.REQ messages to the device and waiting for a VS_WR_MEM.CNF
    message from the device after each request. Each message contains an image
    segment, the memory offset, the segment length and the checksum used to
    monitor and manage download progress. If a single transaction fails, the
    local host should detect it and repeat it.

12. The local host starts firmware execution by sending a VS_ST_MAC.REQ message
    to the device. The message contains the firmware start address.

13. The bootloader receives the VS_ST_MAC.REQ from the local host, validates
    the content.

14. The device sends a VS_ST_MAC.CNF message to indicate an ability or
    willingness to start firmware execution. The device immediately starts
    firmware execution which relinquishes device control to the firmware. It
    can take 5 to 10 seconds for the firmware to start.

15. The host receives the VS_ST_MAC.CNF message from the device, inspects the
    MSTATUS field and acts accordingly. An afffirmative indication means that
    the firmware will start executing on the device in 5 to 10 seconds. Once
    the firmware starts, future messages will contain the unique hardware
    address for the device.

Boot from Host (INT6400)

The INT6400™ boot-from-host operation downloads and executes a memory
configuration applet then downloads runtime parameters and firmware from a
local host and starts firmware execution. This method is initiated by the
INT6400™ bootloader after reset on a device having no flash memory, blank flash
memory or corrupted flash memory. The method requires bootloader aware software
running on the local host in order to complete.

The INT6400™ boot-from-host method is similar to the INT6300™ boot-from-host
method but it downloads and executes an SDRAM configuration applet instead of
downloading SDRAM parameters. The applet is downloaded and executed using the
same mechanism as runtime firmware. The applet executes and returns to the
bootloader when done. The bootloader then continues to drive the boot process
using VS_HOST_ACTION messages.

The INT6400™ boot-from-host method will work for AR7400™ and QCA7420™ chipsets
but will not work on successive chipsets. Customers should adopt or implement
the AR7400™ boot-from-host method, instead of this one, to avoid building
obsolete products.

The INT6400™ does not have a unique hardware address until the firmware starts
and assigns one from the parameter information block. Until that time, the
bootloader will only acknowledge messages addressed to 00:B0:52:00:00:01. In
addition, the bootloader does not know the hardware address of the local host
and so it addresses VS_HOST_ACTION messages to FF:FF:FF:FF:FF:FF; however,
these messages are not transmitted over the powerline.

Figure 4.6.  Boot from Host (INT6400)


          INT6400                            LOCAL-HOST
        [01] |                                    |
        [02] |-------- VS_HOST_ACTION.IND ------->| [03]
        [05] |<------- VS_HOST_ACTION.RSP --------| [04]
             |                                    |
        [06] |<------- VS_WR_MEM.REQ -------------| [06]
        [06] |-------- VS_WR_MEM.CNF ------------>| [06]
        [06] |<-----------------------------------| [06]
        [06] |----------------------------------->| [06]
             |                                    |
        [08] |<------- VS_ST_MAC.REQ -------------| [07]
        [09] |-------- VS_ST_MAC.CNF ------------>| [10]
        [11] |                                    |
        [12] |-------- VS_HOST_ACTION.IND ------->| [13]
        [15] |<------- VS_HOST_ACTION.RSP --------| [14]
             |                                    |
             |                                    | [16]
             |                                    |
        [17] |<------- VS_WR_MEM.REQ -------------| [17]
        [17] |-------- VS_WR_MEM.CNF ------------>| [17]
        [17] |<-----------------------------------| [17]
        [17] |----------------------------------->| [17]
             |                                    |
        [18] |<------- VS_WR_MEM.REQ -------------| [18]
        [18] |-------- VS_WR_MEM.CNF ------------>| [18]
        [18] |<-----------------------------------| [18]
        [18] |----------------------------------->| [18]
             |                                    |
        [20] |<------- VS_ST_MAC.REQ -------------| [19]
        [21] |-------- VS_ST_MAC.CNF ------------>| [22]




 1. The bootloader automatically starts after device reset and attempts to read
    the runtime firmware image from flash memory, write it into SDRAM and start
    execution. If it succeeds then normal operation begins and no futher action
    is required. If it fails, for any reason, then the bootloader initiates the
    boot-from-host sequence.

 2. The bootloader broadcasts VS_HOST_ACTION.IND with HOST_ACTION_REQ set to
    0x04 to request configuration. The destination address is FF:FF:FF:FF:FF:FF
    and source address is 00:B0:52:00:00:01 as explained above. This message is
    sent every 500 milliseconds which differs from that of other chips.

 3. The local host receives the VS_HOST_ACTION.IND message and inspects the
    HOST_ACTION_REQ field to determine the appropriate action. On a single-host
    system, the lone host must service the request or the device will not
    start. On a multi-host system, one host must elect to service the request
    of the device will not start.

 4. The local host sends VS_HOST_ACTION.RSP to silence the bootloader or
    indicate the ability and willingness to service the request. The
    destination address must be 00:B0:52:00:00:01 and the source address is
    that of the host interface. The MSTATUS field is set to 0x00 for
    affirmative and 0x01 for negative.

 5. The bootloader receives the VS_HOST_ACTION.RSP from the host and inspects
    the MSTATUS field. On affirmative response, the bootloader stops
    broadcasting VS_HOST_ACTION.IND messages and waits indefinitely for the
    local host to download a configuation applet and start execution.

 6. The host downloads the memory control applet to the device by sending
    VS_WR_MEM.REQ messages to the device and waiting for a VS_WR_MEM.CNF
    message from the device after each one. Each message contains an image
    segment and the segment memory offset, length and checksum. These values
    are used to monitor and manage download progress. If a transaction fails,
    the host can detect it and should repeat it.

 7. The host starts execution of the memory control applet by sending a
    VS_ST_MAC.REQ message to the device. The message contains the applet load
    address, length, checksum and start address. These values are often
    obtained from an NVM file image header.

 8. The bootloader receives the VS_ST_MAC.REQ from the host and validates the
    contents.

 9. The bootloader sends a VS_ST_MAC.CNF message to the host indicating the
    ability and willingness to start applet execution. The MSTATUS field is set
    to 0x00 for affirmative and 0x01 for negative.

10. The host receives the VS_ST_MAC.CNF message from the device and evaluates
    the MSTATUS field. On affirmative, the host waits for further requests from
    the device. On negative, the host may attempt another start or another
    download followed by a start or attempt to alert a human.

11. The bootloader starts applet execution. The applet configures memory, runs
    to completion and returns to the Bootloader.

12. The bootloader broadcasts a VS_HOST_ACTION.IND message every 500
    milliseconds to request runtime firmware and parameter download. The
    message destination address is FF:FF:FF:FF:FF:FF and source address is
    00:B0:52:00:00:01 as explained above. The HOST_ACTION_REQ field is set to
    0x00.

13. The host receives the VS_HOST_ACTION.IND message and inspects the
    HOST_ACTION_REQ field to determine the requested action. On a single-host
    system, the lone host must service the request or the device will not
    start. On a multi-host system, one host must elect to service the request
    of the device will not start.

14. The host sends a VS_HOST_ACTION.RSP message to the device to indicate the
    ability and willingness to service the request. The MSTATUS field is set to
    0x00 for affirmative and 0x01 for negative.

15. The bootloader receives the VS_HOST_ACTION.RSP from the host and inspects
    the MSTATUS field. On affirmative response, the bootloader stops
    broadcasting VS_HOST_ACTION.IND messages and waits indefinitely for the
    host to download the runtime firmware and parameters and start execution.

16. The host determines which firmware and parameter image to download. In some
    cases there may be no choice. In other cases, there may be a choice between
    default and custom images or between current and upgraded images. This is a
    principle design issue to consider.

17. The host downloads the firmware image to the device by sending
    VS_WR_MEM.REQ messages to the device and waiting for a VS_WR_MEM.CNF
    message from the device after each one. Each message contains an image
    segment and the segment memory offset, length and checksum. These values
    are used to monitor and manage download progress. If a transaction fails,
    the local host can detect it and should repeat it.

18. The host downloads the parameter block to the device by sending
    VS_WR_MEM.REQ messages to the device and waiting for a VS_WR_MEM.CNF
    message from the device after each one. Each message contains an image
    segment and the segment memory offset, length and checksum. These values
    are used to monitor and manage download progress. If a transaction fails,
    the local host can detect it and should repeat it.

19. The host starts runtime firmware execution by sending a VS_ST_MAC.REQ
    message to the device. The message contains the firmware load address,
    length, checksum and start address. These values are often obtained from an
    NVM file image header.

20. The bootloader receives the VS_ST_MAC.REQ from the host and validates the
    content.

21. The bootloader sends a VS_ST_MAC.CNF message to indicate the ability or
    willingness to start firmware execution.

22. The host receives the VS_ST_MAC.CNF message from the device, inspects the
    MSTATUS field and acts accordingly.

23. The bootloader starts runtime firmware execution. The firmware reads and
    validates the parameter block then assumes full control of the device. It
    can take several seconds for firmware start to be evident. Once the
    firmware starts, any future VS_HOST_ACTION messages will contain the unique
    hardware address for the device.

Boot from Host (AR7400)

The AR7400™ boot-from-host method downloads and executes a device configuration
applet then downloads runtime parameters and firmware from a local host and
starts firmware execution. This method is initiated by the Bootloader after
reset on a device having no flash memory, blank flash memory or corrupted flash
memory. The method requires Bootloader aware software running on the local host
in order to complete.

The AR7400™ boot-from-host method is similar to the INT6400™ boot-from-host
method but it uses the VS_WRITE_AND_EXECUTE message instead of the VS_WR_MEM
message write into SDRAM and start firmware execution. This elminates the need
for the VS_ST_MAC message. The VS_WR_MEM and VS_ST_MAC message types will no
longer be recognized by bootloaders after the QCA7420™ chipset.

The AR7400™ boot-from-host method works on AR6400™ and will continue to work on
QCA7420™ and planned successors. Customers should implement this boot-from-host
method now to avoid building obsolete products.

The AR7400™ does not have a unique hardware address until the firmware starts
and assigns one read from the PIB. Until that time, the Bootloader will only
acknowledge messages addressed to 00:B0:52:00:00:01. In addition, the
Bootloader does not know the hardware address of the local host and so it
addresses all VS_HOST_ACTION messages to FF:FF:FF:FF:FF:FF; however, these
messages are not transmitted over the powerline.

Figure 4.7.  Boot from Host (AR7400)


          AR7400                             LOCAL-HOST
        [01] |                                    |
        [02] |-------- VS_HOST_ACTION.IND ------->| [03]
        [05] |<------- VS_HOST_ACTION.RSP --------| [04]
             |                                    | [06]
             |<---- VS_WRITE_AND_EXECUTE.REQ -----| [07]
        [08] |----- VS_WRITE_AND_EXECUTE.CNF ---->|
             |<-----------------------------------| [09]
        [10] |----------------------------------->| [11]
        [12] |                                    |
        [13] |-------- VS_HOST_ACTION.IND ------->| [14]
        [16] |<------- VS_HOST_ACTION.RSP --------| [15]
             |                                    | [16]
             |<-VS_WRITE_AND_EXECUTE_APPLET.REQ --| [17]
        [18] |--VS_WRITE_AND_EXECUTE_APPLET.CNF ->|
             |<-----------------------------------| [19]
        [20] |----------------------------------->|
             |<-VS_WRITE_AND_EXECUTE_APPLET.REQ --| [21]
        [22] |--VS_WRITE_AND_EXECUTE_APPLET.CNF ->|
             |<-----------------------------------| [23]
        [24] |----------------------------------->|
        [25] |                                    |




 1. The bootloader automatically starts after device reset and attempts to read
    the runtime firmware image from flash memory, write it into SDRAM and start
    execution. If it succeeds then normal operation begins and no futher action
    is required. If it fails, for any reason, then the bootloader initiates the
    boot-from-host sequence.

 2. The bootloader broadcasts VS_HOST_ACTION.IND with HOST_ACTION_REQ set to
    0x04 to indicate that it is waiting to be configured. The bootloader
    continues to broadcast this message message every 750 milliseconds which
    differs from that of other chips.

 3. The local host receives the VS_HOST_ACTION.IND and inspects HOST_ACTION_REQ
    field to determine the required action. The local host must be programmed
    to listen and act appropriately.

 4. The local host sends a VS_HOST_ACTION.RSP message with MSTATUS set to 0 to
    indicate the start of sequence.

 5. The bootloader receives the VS_HOST_ACTION.RSP message, stops broadcasting
    VS_HOST_ACTION.IND messages and waits indefinitely for the local host to
    act.

 6. The local host retrieves the firmware chain and extracts the configuration
    applet image from the chain. The firmware chain may be stored on disk or in
    memory depending on how the local host is programmed.

 7. The local host sends a VS_WRITE_AND_EXECUTE.REQ message with FLAGS set to 2
    and ALLOWED_MEM_TYPES to 1 to download the applet in absolute address mode.
    Alternately, setting FLAGS to 0 and CURR_PART_OFFSET to 0 will download the
    applet in relative address mode. The TOTAL_LENGTH will be the applet image
    header IMAGELENGTH but CURR_PART_LENGTH cannot exceed 1400 bytes.

 8. The bootloader acknowledges each VS_WRITE_AND_EXECUTE.REQ message with a
    VS_WRITE_AND_EXECUTE.CNF message having MSTATUS set to 0.

 9. The local host continues to increment CURR_PART_OFFSET and download the
    configuration applet in 1400 byte blocks until the last block is reached.
    The local host then sets START_ADDR to the applet image header ENTRYPOINT,
    the CHECKSUM to the applet image header IMAGECHECKSUM and the execute bit
    in FLAGS to 1 in the last message frame.

10. The bootloader receives the last VS_WRITE_AND_EXECUTE.REQ message, confirms
    the configuration applet checksum then acknowledges with a
    VS_WRITE_AND_EXECUTE.CNF message having MSTATUS set to 0.

11. The local host exists the boot from host sequence and returns to listening
    mode.

12. The bootloader executes the configuration applet. The device hardware
    address is 00:B0:52:00:00:01 in this state.

13. The bootloader broadcasts a VS_HOST_ACTION.IND message with HOST_ACTION_REQ
    set to 0 to indicate that it is waiting for runtime parameters and
    firmware.

14. The local host receives a VS_HOST_ACTION.IND message and inspects the
    HOST_ACTION_REQ field to determine the required action. The local host must
    be programmed to listen and act appropriately.

15. The bootloader receives the VS_HOST_ACTION.RSP message, stops broadcasting
    VS_HOST_ACTION.IND messages and waits indefinitely for the local host to
    act.

16. The local host locates the parameter chain and firmware chain. The chains
    may be stored on disk or in memory depending on how the local host is
    programmed.

17. The local host sends a VS_WRITE_AND_EXECUTE.REQ message with FLAGS set to 2
    and ALLOWED_MEM_TYPES set to 1 to download parameters in absolute address
    mode. Alternately, setting FLAGS to 0 and CURR_PART_OFFSET to 0 will
    download parameters in relative address mode. The TOTAL_LENGTH will be the
    entire parameter file length but the CURR_PART_LENGTH cannot exceed 1400
    bytes.

18. The bootloader acknowledges each VS_WRITE_AND_EXECUTE.REQ message with a
    VS_WRITE_AND_EXECUTE.CNF message having MSTATUS set to 0.

19. The local host continues to CURR_PART_OFFSET and download the parameter
    chain in 1400 byte blocks until the last block is reached. The local host
    then sets the START_ADDR field to the parameter image header ENTRYPOINT,
    the CHECKSUM to the parameter image header IMAGECHECKSUM and the execute
    bit in FLAGS to 1 in the last message frame.

20. The bootloader receives the last VS_WRITE_AND_EXECUTE.REQ message, confirms
    the parameter chain checksum and acknowledges with a
    VS_WRITE_AND_EXECUTE.CNF message having MSTATUS set to 0.

21. The local host sends a VS_WRITE_AND_EXECUTE.REQ message with FLAGS set to 2
    and ALLOWED_MEM_TYPES to 1 to download firmware in absolute address mode.
    Alternately, setting FLAGS to 0 and CURR_PART_OFFSET to 0 will download
    firmware in relative address mode. The TOTAL_LENGTH will be the firmware
    image header IMAGELENGTH but the CURR_PART_LENGTH cannot exceed 1400 bytes.

22. The bootloader acknowledges each VS_WRITE_AND_EXECUTE.REQ message with a
    VS_WRITE_AND_EXECUTE.CNF message having the MSTATUS field set to 0.

23. The local host continues to increment CURR_PART_OFFSET and download the
    parameter chain in 1400 byte blocks until the last block is reached. The
    local host then sets START_ADDR to the parameter image header ENTRYPOINT,
    the CHECKSUM to the parameter image header IMAGECHECKSUM and the execute
    bit in FLAGS to 1 in the last message frame.

24. The bootloader receives the last VS_WRITE_AND_EXECUTE.REQ message, confirms
    the firmware chain checksum and acknowledges with a
    VS_WRITE_AND_EXECUTE.CNF message having the MSTATUS field set to 0.

25. The bootloader executes the runtime firmware and the device begins
    operation. The device hardware address will become that programmed into the
    parameter inforamtion block.

Boot from Host (AR7420)

The VS_WRITE_AND_EXECUTE message is now the only way to write runtime
parameters and firmware into volatile memory. The legacy VS_RD_MEM, VS_WR_MEM
and VS_ST_MAC are deprecated and will no longer be supported by the bootloader.
This means that some customers must re-write their applications to boot newer
powerline devices.

Figure 4.8.  Boot from Host (AR6410/AR7420)


          AR7420                             LOCAL-HOST
        [01] |                                    |
        [02] |-------- VS_HOST_ACTION.IND ------->| [03]
        [05] |<------- VS_HOST_ACTION.RSP --------| [04]
             |                                    | [06]
             |<---- VS_WRITE_AND_EXECUTE.REQ -----| [07]
        [08] |----- VS_WRITE_AND_EXECUTE.CNF ---->|
             |<-----------------------------------| [09]
        [10] |----------------------------------->| [11]
        [12] |                                    |
        [13] |-------- VS_HOST_ACTION.IND ------->| [14]
        [16] |<------- VS_HOST_ACTION.RSP --------| [15]
             |                                    | [16]
             |<-VS_WRITE_AND_EXECUTE_APPLET.REQ --| [17]
        [18] |--VS_WRITE_AND_EXECUTE_APPLET.CNF ->|
             |<-----------------------------------| [19]
        [20] |----------------------------------->|
             |<-VS_WRITE_AND_EXECUTE_APPLET.REQ --| [21]
        [22] |--VS_WRITE_AND_EXECUTE_APPLET.CNF ->|
             |<-----------------------------------| [23]
        [24] |----------------------------------->|
        [25] |                                    |




 1. The bootloader enters boot-from-host mode based on the hardware strapping
    or failure to load runtime firmware from flash memory. The device hardware
    address is 00:B0:52:00:00:01 in this state.

 2. The bootloader broadcasts a VS_HOST_ACTION.IND message with HOST_ACTION_REQ
    set to 4 to indicate that it is waiting to be configured. The bootloader
    will continue to broadcast the VS_HOST_ACTION.IND message every 750ms until
    it receives a VS_HOST_ACTION.RSP message from the local host. The BootROM
    does not know the local host hardware address at this stage so indications
    are broadcast, not addressed.

 3. The local host receives a VS_HOST_ACTION.IND message and inspects
    HOST_ACTION_REQ field to determine the required action. The local host must
    be programmed to listen and act appropriately. The first indcation requests
    device configuration.

 4. The local host sends a VS_HOST_ACTION.RSP message with MSTATUS set to 0 to
    indicate a willingness and ability to service the request.

 5. The bootloader receives the VS_HOST_ACTION.RSP message, stops broadcasting
    VS_HOST_ACTION.IND messages and waits indefinitely for the local host to
    act.

 6. The local host retrieves the firmware chain and extracts the configuration
    applet image from the chain. The firmware chain may be stored on disk or in
    memory depending on how the local host is programmed.

 7. The local host sends a VS_WRITE_AND_EXECUTE.REQ message with FLAGS set to
    2, ALLOWED_MEM_TYPES to 1, CURR_PART_OFFSET to the applet image header
    IMAGEADDRESS and CURR_PART_LENGTH to the applet image header IMAGELENGTH to
    download the applet in absolute address mode. Alternately, setting FLAGS to
    0 and CURR_PART_OFFSET to 0 will download the applet in relative address
    mode.

 8. The bootloader acknowledges each VS_WRITE_AND_EXECUTE.REQ message with a
    VS_WRITE_AND_EXECUTE.CNF message having MSTATUS set to 0.

 9. The local host continues to download the configuration applet in 1400 byte
    blocks until the last block is reached. The local host sets START_ADDR to
    the applet image header ENTRYPOINT, CHECKSUM to the applet image header
    IMAGECHECKSUM and the execute bit in FLAGS to 1.

10. The bootloader receives the last VS_WRITE_AND_EXECUTE.REQ message, confirms
    the configuration applet checksum then acknowledges with a
    VS_WRITE_AND_EXECUTE.CNF message having MSTATUS set to 0.

11. The local host exists the boot from host sequence and returns to listening
    mode.

12. The bootloader executes the configuration applet. The device hardware
    address is 00:B0:52:00:00:01 in this state.

13. The bootloader broadcasts a VS_HOST_ACTION.IND message with HOST_ACTION_REQ
    set to 0 to indicate that it is waiting for runtime parameters and
    firmware.

14. The local host receives a VS_HOST_ACTION.IND message and inspects the
    HOST_ACTION_REQ field to determine the required action. The local host must
    be programmed to listen and act appropriately.

15. The bootloader receives the VS_HOST_ACTION.RSP message, stops broadcasting
    VS_HOST_ACTION.IND messages and waits indefinitely for the local host to
    act.

16. The local host locates the parameter chain and firmware chain. The chains
    may be stored on disk or in memory depending on how the local host is
    programmed.

17. The local host sends a VS_WRITE_AND_EXECUTE.REQ message with FLAGS set to
    2, ALLOWED_MEM_TYPES set to 1, CURR_PART_OFFSET to the parameter image
    header IMAGEADDRESS and CURR_PART_LENGTH to the entire parameter image
    chain length to download parameters in absolute address mode. Alternately,
    setting FLAGS to 0 and CURR_PART_OFFSET to 0 will download parameters in
    relative address mode.

18. The bootloader acknowledges each VS_WRITE_AND_EXECUTE.REQ message with a
    VS_WRITE_AND_EXECUTE.CNF message having MSTATUS set to 0.

19. The local host continues to download the parameter chain in 1400 byte
    blocks until the last block is reached. The local host then sets the
    START_ADDR field to the parameter image header ENTRYPOINT, CHECKSUM to the
    parameter image header IMAGECHECKSUM and the execute bit in FLAGS to 1.

20. The bootloader receives the last VS_WRITE_AND_EXECUTE.REQ message, confirms
    the parameter chain checksum and acknowledges with a
    VS_WRITE_AND_EXECUTE.CNF message having MSTATUS set to 0.

21. The local host sends a VS_WRITE_AND_EXECUTE.REQ message with FLAGS set to
    2, ALLOWED_MEM_TYPES to 1, CURR_PART_OFFSET to the firmware image header
    IMAGEADDRESS and CURR_PART_LENGTH to the firmware image header IMAGELENGTH
    to download firmware in absolute address mode. Alternately, setting FLAGS
    to 0 and CURR_PART_OFFSET to 0 will download firmware in relative address
    mode.

22. The bootloader acknowledges each VS_WRITE_AND_EXECUTE.REQ message with a
    VS_WRITE_AND_EXECUTE.CNF message having the MSTATUS field set to 0.

23. The local host continues to download the parameter chain in 1400 byte
    blocks until the last block is reached. The local host then sets START_ADDR
    to the parameter image header ENTRYPOINT, CHECKSUM to the parameter image
    header IMAGECHECKSUM and the execute bit in FLAGS to 1.

24. The bootloader receives the last VS_WRITE_AND_EXECUTE.REQ message, confirms
    the firmware chain checksum and acknowledges with a
    VS_WRITE_AND_EXECUTE.CNF message having the MSTATUS field set to 0.

25. The bootloader executes the runtime firmware and the device begins
    operation. The device hardware address will become that programmed into the
    parameter inforamtion block.

At this point, runtime firmware is executing in volatile memory with runtime
parameters. If the power is reset at this point then all would be lost. If the
device has dedicated flash memory attached then we may want to write runtime
parameters and firmware to flash memory so that the device can boot from flash
in case of a power failure or reset.

Flash Memory (AR6410/AR7420)

The VS_MODULE_OPERATION message is now the only way of write flash memory. The
legacy message types VS_RD_MOD, VS_WR_MOD, VS_MOD_NVM and VS_PTS_NVM are
deprecated and will no longer be supported by runtime firmware. This means that
some customers must re-write their applications to flash newer powerline
devices.

Tip

The VS_MODULE_OPERATION message type has many formats and the structure differs
with each format. Readers should consult the QCA Firmware Technical Reference
Manual for a complete description.

A blank flash memory must first be programmed with a softloader module. The
module consists of a manifest, the executable softloader program image and a
flash memory map. The map is used to manage flash memory during initializations
and upgrades. The softloader module must be written into flash memory as a
separate module before parameter and firmware modules are written. After that,
parameter and firmware modules may be written and re-written without re-writing
the softloader module. Of course, the softloader module must be re-written if
flash memory is erased.

Figure 4.9.  Flashing the Softloader (AR7420)


   AR7420                                        LOCAL-HOST
 [02] |<- VS_MODULE_OPERATION.REQ (Start Session) ---| [01]
 [03] |-- VS_MODULE_OPERATION.CNF (Start Session) -->| [04]
      |                                              |
 [06] |<-- VS_MODULE_OPERATION.REQ (Write Module) ---| [05]
 [07] |--- VS_MODULE_OPERATION.CNF (Write Module) -->| [08]
      |<---------------------------------------------|
      |--------------------------------------------->|
      |                                              |
 [10] |<- VS_MODULE_OPERATION.REQ (Close Session) ---| [09]
 [11] |-- VS_MODULE_OPERATION.CNF (Close Session) -->| [12]




 1. The local host sends a VS_MODULE_OPERATION.REQ module write session request
    to register a session identifier and the module identifier, module length
    and module checksum of the softloader module. The softloader module
    identifier is 0x7003. The softloader module is the entire softloader chain
    including manifest, softloader image and flash memory layout.

 2. The device receives the request, validates the module identifier and
    preserves the module length and checksum until the module write session is
    closed. The local host has 30 minutes to complete registered module write
    operations and close the module write session.

 3. The device responds with VS_MODULE_OPERATION.CNF with MSTATUS set to 0, if
    things went well.

 4. The local host receives the confirmation and prepares to download the
    softloader module.

 5. The local host sends a VS_MODULE_OPERATION.REQ module write request
    containing the offset, length and content of the first portion of the
    module being downloaded.

 6. The device receives the request and write to a scrath region of flash
    memory awaiting session close.

 7. The device responds with VS_MODULE_OPERATION.CNF with MSTATUS set to 0 if
    things went well.

 8. The local host receives the confirmation and continues downloading the
    softloader in fragments using VS_MODULE_OPERATION write requests, advancing
    the offset and adjusting the length with each write.

 9. The local host send a VS_MODULE_OPERATION.REQ close module write session
    request having COMMIT_CODE bits 0 and 1 set. to indicate “Force Commit” and
    “Commit without reset”, respectively.

10. The device recevies the request, verifies the module length and checksum
    then transfers the module from scratch memory to it's final location in
    flash memory.

11. The device responds with VS_MODULE_OPERATION.CNF close module write session
    with MSTATUS set to 0 if things went well. If things did not go well then
    the local host must request a new write module session and start over.

Once the softloader module is written, the parameter and firmware modules may
be written in much the same way except that they must be written as a pair. The
parameter module must be downloaded first. The firmware module cannot be
committed to without a compatible parameter module.

When parameters and firmware are written together the User PIB, Factory PIB and
firmware are modified modified. The new User PIB is created by copying the old
User PIB over the new one. Consequently the only change comes from extra fields
found at the end of the new User PIB. The new Factory PIB becomes the new User
PIB with certain fields from the old User PIB preserved, such as the MAC, DAK
and so on.

Figure 4.10.  Flash Parameters and Firmware (AR7420)


       AR7420                                      LOCAL-HOST
    [02] |<- VS_MODULE_OPERATION.REQ (start session) ---| [01]
    [03] |-- VS_MODULE_OPERATION.CNF (start session) -->| [04]
         |                                              |
    [06] |<-- VS_MODULE_OPERATION.REQ (write module) ---| [05]
    [07] |--- VS_MODULE_OPERATION.CNF (write module) -->| [08]
         |<---------------------------------------------|
         |--------------------------------------------->|
         |                                              |
    [10] |<-- VS_MODULE_OPERATION.REQ (write module) ---| [09]
    [11] |--- VS_MODULE_OPERATION.CNF (write module) -->| [12]
         |<---------------------------------------------|
         |--------------------------------------------->|
         |                                              |
    [14] |<- VS_MODULE_OPERATION.REQ (commit modules) --| [13]
    [15] |-- VS_MODULE_OPERATION.CNF (commit modules) ->| [16]




 1. The local host sends a VS_MODULE_OPERATION.REQ module write session request
    to register the session identifier, module identifiers, module lengths and
    module checksums. In this case, the two modules are the runtime parameters
    and runtime firmware. The module identifiers are 0x7002 and 0x7003,
    respectively. The application running on the local must must locate these
    modules and determine their size and checksum.

 2. The device receives the request, validates the module identifier and
    preserves the module lengths and checksums until the module write session
    is closed. The local host has 30 minutes to complete registered module
    write operations and close the module write session.

 3. The device responds with VS_MODULE_OPERATION.CNF with MSTATUS set to 0, if
    things went well.

 4. The local host receives the confirmation and prepares to download the
    parameter module.

 5. The local host sends a VS_MODULE_OPERATION.REQ module write request
    containing the offset, length and content of the first portion of the
    module being downloaded.

 6. The device receives the request and write to a scratch region of flash
    memory awaiting write session close.

 7. The device responds with VS_MODULE_OPERATION.CNF with MSTATUS set to 0 if
    things went well.

 8. The local host receives the confirmation and continues downloading the
    parameter module in fragments using VS_MODULE_OPERATION write requests,
    advancing the offset and adjusting the length with each write.

 9. The local host receives the confirmation and prepares to download the
    firmware module.

10. The local host sends a VS_MODULE_OPERATION.REQ module write request
    containing the offset, length and content of the first portion of the
    module being downloaded.

11. The device receives the request and write to a scratch region of flash
    memory awaiting write session close.

12. The device responds with VS_MODULE_OPERATION.CNF with MSTATUS set to 0 if
    things went well.

13. The local host receives the confirmation and continues downloading the
    firmware module in fragments using VS_MODULE_OPERATION write requests,
    advancing the offset and adjusting the length with each write.

14. The local host send a VS_MODULE_OPERATION.REQ close module write session
    request having COMMIT_CODE bits 0 and 1 set. to indicate “force commit” and
    “commit without reset”, respectively.

15. The device receives the request, verifies the module length and checksum
    then transfers the module from scratch memory to it's final location in
    flash memory.

16. The device responds with VS_MODULE_OPERATION.CNF close module write session
    with MSTATUS set to 0 if things went well. If things did not go well then
    the local host must request a new write module session and start over.

At this point, the device is ready to boot from flash memory if the power fails
or the device resets.

Chapter 5.  Procedures

Table of Contents

Introduction
Select an Interface on Linux
Select an Interface on Windows
Identify a Device
Browse the Network
Forming a Network
Configuring a Device
Upgrading Firmware and PIB
Upgrading PIB Only
Starting a Device
Testing a Device
Programming NVRAM
Pairing UART Devices post PTS
Trouble-shooting Problems

Introduction

The Powerline Toolkit can perform all sorts of operations on Atheros powerline
devices. Many operations are simple and can be accomplished using one command.
Others are more complex and may require several commands. This section
demonstrates common console commands that you might want to use when
experimenting or working with Atheros powerline devices. Multi-command
procedures can be generalized and automated using any programming or scripting
language that can execute console commands.

Select an Interface on Linux

Linux network interfaces are referenced by name. Use Linux utility ifconfig to
determine the names of interfaces on your host. By default, Toolkit programs
communicate with powerline devices on interface eth1 but another interface can
be specified on the command line with the -i option:

Example 5.1.  Selecting another Interface on Linux

# int6k -i eth3 ...


In the previous example, int6k will send and receive frames on interface eth3
instead of the default interface. Having to specify the interface can become
become tedious when entering commands manually. An alternative method involves
setting environment variable PLC to your preferred Ethernet interfaces, as
follows:

Example 5.2.  Changing the Default Interface on Linux

# export PLC="eth2"


In the previous example, environment variable PLC is defined and exported,
making it available to all programs running under the current console session.
This command can be included in ~/.profile or /etc/profile or in /etc/
environment on Debian ™ and Ubuntu™ systems.

Example 5.3.  Finding Interfaces on Linux

# ifconfig
eth0      Link encap:Ethernet  HWaddr 00:60:97:05:97:0C
          inet addr:192.168.170.179  Bcast:192.168.170.255  Mask:255.255.255.0
          inet6 addr: fe80::260:97ff:fe05:970c/64 Scope:Link
          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1
          RX packets:52130758 errors:0 dropped:0 overruns:0 frame:0
          TX packets:59629414 errors:0 dropped:0 overruns:0 carrier:0
          collisions:0 txqueuelen:1000
          RX bytes:43781526 (41.7 MiB)  TX bytes:4226651392 (3.9 GiB)
          Interrupt:209 Base address:0xe000

eth1      Link encap:Ethernet  HWaddr 00:0F:EA:10:D5:1C
          inet addr:192.168.99.1  Bcast:192.168.99.255  Mask:255.255.255.0
          inet6 addr: fe80::20f:eaff:fe10:d51c/64 Scope:Link
          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1
          RX packets:68711621 errors:0 dropped:0 overruns:0 frame:0
          TX packets:70059644 errors:0 dropped:0 overruns:0 carrier:0
          collisions:0 txqueuelen:1000
          RX bytes:3449044517 (3.2 GiB)  TX bytes:1328494982 (1.2 GiB)
          Interrupt:217

lo        Link encap:Local Loopback
          inet addr:127.0.0.1  Mask:255.0.0.0
          inet6 addr: ::1/128 Scope:Host
          UP LOOPBACK RUNNING  MTU:16436  Metric:1
          RX packets:177789 errors:0 dropped:0 overruns:0 frame:0
          TX packets:177789 errors:0 dropped:0 overruns:0 carrier:0
          collisions:0 txqueuelen:0
          RX bytes:599522176 (571.7 MiB)  TX bytes:599522176 (571.7 MiB)


The previous example demonstrates the use of Linux ifconfig utility to identify
available network interfaces by name and MAC address.

If your computer has multiple Ethernet interface cards installed, you can
connect each card to a different Atheros powerline device and communicate with
each device, independently, from one console session (window) by specifying the
appropriate interface card with each command. It is also possible to open
multiple console sessions (windows), each having a unique enviroment, and
assign a different value for PLC in each enviroment.

Select an Interface on Windows

Winpcap references host network interfaces by number, not name. This means that
you must determine the proper interface number for the network adapter that you
plan to use. Use Toolkit pcapdevs utility will enumerate available host network
adapters by number, MAC address and description. By default, Toolkit programs
communicate with powerline devices on pcap interface 2 but another interface
can be specified on the command line with the -i option:

Example 5.4.  Selecting another Interface on Windows

# int6k -i 3 ...


In the previous example, int6k will send and receive frames using host
interface 3 instead of the default interface. Having to specify the interface
can become tedious when entering commands manually. Presently there is no way
to specify a default interface on WIndows platforms.

Example 5.5.  Finding Interfaces on Windows

# pcapdevs
 1 00:00:00:00:00:00 \Device\NPF_GenericDialupAdapter   (Adapter for generic dialup
 2 00:0E:2E:03:5F:B8 \Device\NPF_{4CFAABD5-C929-4942-914B-BDFE72B13611} (Realtek R
 3 00:C0:49:D5:CB:14 \Device\NPF_{73E0D2EF-6069-4831-B379-507025F2BDCD} (Realtek R
 4 00:0C:76:87:3E:3D \Device\NPF_{86B96905-3AA7-46F1-969A-6C23E3BBBA8B} (Broadcom


The previous example illustrates the use of Toolkit pcapdevs utility to
identify available network interfaces by interface number, MAC address and
description. The descriptions have been truncated in this example because they
are too long. Devices having MAC address 00:00:00:00:00:00 are unavailable.

Identify a Device

Before you start working with Atheros powerline devices, you should determine
the chipset and firmware revision because that will determine the types of
operations that can be performed and the order in which some operations should
be performed. The following example illustrates how to determine this
information.

Example 5.6.  Device Identification

# int6k -r
eth1 00:B0:52:00:00:01 Fetch Version Information
eth1 00:B0:52:DA:DA:23 INT6300A0 INT6000-MAC-3-0-3001-1081-LA-A NOT_UPGRADEABLE
eth1 00:B0:52:FE:87:2D INT6000A1 INT6000-SL-0-1-0110-200-2006-0415-BETA NOT_UPGRADEABLE


This example demonstrates several things.

First, the int6k -r option requests hardware and software revision information
from a device by sending an Atheros VS_SW_VER vendor-specific managerment
message and waiting for a response. Atheros vendor-specific management messages
are described in the Atheros HomePlug AV Firmware Technical Reference Manual.
It you do not have access to this document then many toolkit features may be
difficult to understand.

Since we did not specify an Ethernet interface on the command line, the default
interface was used. In this case, the default interface was eth1 and so we
observe that eth1 was used to both send requests and receive responses.

Since we did not specify a device address on the command line, the default
address was used. Device addresses are also known as MAC, “Ethernet” or
“hardware” addresses. They uniquely identify a device on a network. Unlike
Ethernet cards, powlerlines device do not have IP addresses.

The default device address for toolkit programs is 00:B0:52:00:00:01. This
address is the Local Management Address (LMA). All Atheros devices connected to
the local host will respond to this address and include their actual address in
the response. In the above example, two devices responded. This means that both
were connected directly to eth1, perhaps via a network hub. Observer that
device 00:B0:52:DA:DA:23 is an INT6300 and device 00:B0:52:FE:87:2D is an
INT6000. The first device is running Atheros firmware and the second device is
running the Atheros Softloader.

Example 5.7.  Inspecting Device Configuration

To find out more about device 00:B0:52:DA:DA:23 we might issue the following
command where option -I requests identity information stored in the device PIB.
In this case, we specified the device by MAC address to prevent other local
devices from responding. There is no harm in having both devices respond so we
could have specified both hardware addresses.

# int6k -I 00:B0:52:DA:DA:23
eth1 00:B0:52:DA:DA:23 Device Identity
eth1 00:B0:52:DA:DA:23 -------
        PIB 3-2 7864 bytes
        MAC 00:B0:52:DA:DA:23
        DAK 24:03:D7:84:09:A0:9A:78:8D:F6:82:75:AF:0D:0F:D8
        NMK 50:D3:E4:93:3F:85:5B:70:40:78:4D:F8:15:AA:8D:B7 (HomePlugAV)
        NID B0:F2:E6:95:66:6B:03
        NET Jupiter-23
        MFG Intergalactic Death Rays Inc.
        USR Rattin Tordo
        CCo Auto

Pay special attention to the MAC address after flashing NVRAM. Hardware address
00:B0:52:00:00:03 indicates the Default PIB used when no other PIB is
available. The Default PIB disables communication over powerline.

Pay special attention to the NMK when devices cannot communicate. Devices
having different NMK values will not form a network. Conversely, all devices
having the same NMK will form a network. This becomes important when
programming large numbers of devices. You must have an out-of-the-box
networking strategy that balances user convenience and network security.

The string next to the NMK indicates that password “HomePlugAV” was used to
generate that key. This is one of two default passwords and keys used by
Atheros. In some cases, it may be another clue that the device is using the
default PIB.


Browse the Network

A powerline network consists of one or more powerline devices that share a
common NMK. One device on the network is in charge of the network and known as
the Central Coordinator (CCo). All other devices on that network are known as
stations (STA). Each device maintains internal information about the network to
which it belongs. You can view that information at any time.

Example 5.8.  Display Network Information

# int6k  -mieth3
eth3 00:B0:52:00:00:01 Fetch Network Information
eth3 00:B0:52:00:00:BB Found 1 Network(s)

        network->NID = 77:23:0D:91:06:6E
        network->SNID = 6
        network->TEI = 1
        network->ROLE = 0x02 (CCO)
        network->CCO_DA = 00:B0:52:00:00:BB
        network->CCO_TEI = 1
        network->STATIONS = 1

                station->DA = 00:B0:52:00:00:AA
                station->TEI = 2
                station->BDA = FF:FF:FF:FF:FF:FF
                station->AvgPHYDR_TX = 0 mbps
                station->AvgPHYDR_RX = 0 mbps


The example above prompts the local device on interface eth3 for network
membership (-m) information. Device 00:B0:52:00:00:BB responded and reported
that it belongs to one powerline network. The first block of information
identifies the network CCo. The second block of information identifies a
network STA. This second block will repeat when multiple stations are present.
Each device on the network has a unique Terminal Equipment Identifier (TEI)
within the network. The average PHY rates show the data rates between the
reporting device and each STA. In this cases there has been no traffic.

Forming a Network

A powerline network is formed when two or more devices share a common Network
Membership Key (NMK). An NMK is always 16 bytes (32 hexadecimal digits) in
length and can have any value, including all zeros. Devices programmed with the
same NMK value can communicate while those programmed with different NMK values
cannot. Program int6k can be used to program a local or remote device with a
specific NMK value.

Example 5.9.  Setting the Network Membership Key

# int6k -M
eth1 00:B0:52:00:00:01 Set Local Network Membership Key
eth1 00:B0:52:BA:BA:56 Setting ...


This example programs the local device with the default NMK. Option -M sets the
network membership key with the default key value. The default key is used
because we omitted option -K and the local device is programmed because we
omitted the device MAC address.

One can quickly and easily create a default network by connecting each device,
in turn, to the local host and executing this command shown above. The devices
will then form a network when connected via the powerline. Although fast and
simple, this method is not very secure because the default NMK is used by many
Atheros tools and is well known.

There are cases where one wants to create separate, independent networks on the
powerline. This is accomplished by programming some devices with one NMK and
other devices with another NMK. In such cases we need to specify an NMK value.

Example 5.10.  Forming a Custom Network

# int6k -M -K 00:11:22:33:44:55:66:77:88:99:AA:BB:CC:DD:EE:FF
eth1 00:B0:52:00:00:01 Set Local Network Membership Key
eth1 00:B0:52:BA:BA:56 Setting ...

This example programs the local device NMK with the value
00:11:22:33:44:55:66:77:88:99:AA:BB:CC:DD:EE:FF. Option -K sets the default key
value used by option -M. The default device is programmed because we omitted a
target MAC address from the command line but we could have specified the local
device using the actual device MAC address or the Local Management Address
(LMA) of 00:B0:52:00:00:01 or the keyword local, like so ...

# int6k -M -K 00:11:22:33:44:55:66:77:88:99:AA:BB:CC:DD:EE:FF
# int6k -M -K 00:11:22:33:44:55:66:77:88:99:AA:BB:CC:DD:EE:FF 00:B0:52:BA:BE:56
# int6k -M -K 00:11:22:33:44:55:66:77:88:99:AA:BB:CC:DD:EE:FF local


Example 5.11.  Remote Network Configuration

Once a network has been established, one can change the NMK of remote devices
over the powerline but once the NMK on the remote device has changed, it is no
longer part of original network and can no longer be returned to the network in
the same way. Additionally, one cannot change the NMK on a remote device
without specifying the DAK of the device to be changed.

# int6k -M -K 00:11:22:33:44:55:66:77:88:99:AA:BB:CC:DD:EE:FF \
        -J 00:B0:52:BA:BE:57 \
        -D A7:8E:11:FB:6A:90:2C:CB:A7:8E:11:FB:6A:90:2C:CB
eth1 00:B0:52:00:00:01 Set Remote Network Membership Key
eth1 00:B0:52:BA:BA:56 Setting ...

This example sets the NMK on remote device via the local device. Option -J
specified the MAC address of the remote device. Option -D specified the DAK of
the remote device. The request is sent to the local device, because we omitted
the target MAC address, and the local device forwards our request to the remote
device. The request will fail if the remote device is not accessible or the
remote device DAK is incorrect.

This command is one of the more complicated int6k commands, requires lots of
typing and is consequently prone to typing errors. The order of command line
options is not important.


Configuring a Device

Device identity, capability and behavior are controlled by runtime parameters
stored in the device PIB. To change device identity, capability or behavior you
must alter a template PIB file, download it to the device and flash it into
NVRAM. A template PIB can come from several sources but an excellent souce is
the device, itself. Configuration changes then become a simple read, modify and
write back operation.

Example 5.12.  Read a PIB File

# int6k  -i eth2 -p old.pib local
eth2 00:B0:52:00:00:01 Read Parameters from Device
eth2 00:B0:52:00:00:BE Read.

This example reads the PIB from the local device and writes it to a file. The
toolkit has a growing number of programs designed to inspect and change
pibfiles in various ways. Program modpib is one program that can be used for
this purpose.


Example 5.13.  Modify a PIB File

# modpib old.pib -M 00:B0:52:00:BA:BE \
                 -N 00:11:22:33:44:55:66:77:88:99:AA:BB:CC:DD:EE:FF \
                 -D FF:EE:DD:CC:BB:AA:99:88:77:66:55:44:33:22:11:00 \
                 -S "Intergalactic Death Rays, Inc." \
                 -T "Global Spy Network" \
                 -U "Bedroom"


The example above edits identity parameters in PIB file, old.pib, recomputes
the internal checksum and re-writes the file. The network identity parameters
are MAC (-M), NMK (-N) and DAK (-D). The user identity parameters are MFG_HFID
(-S), NET_HFID (-T) and USR_HFID (-U). The PIB file is ready for download and
flash.

Program modpib is a safe way to edit a PIB file because it only change selected
parameters. Use program setpib to edit other parameters if required.

Example 5.14.  Save a PIB File

# int6k  -i eth2 -P old.pib -C pib
eth2 00:B0:52:00:00:01 Write Parameters to Device
eth2 00:B0:52:00:00:BE Written.


This example writes the modified PIB file, old.pib, to the local device and
commits it to NVRAM. Option -P writes the PIB file to the device instead of
reading it from the device. Option -C with argument pib commits only the PIB,
and not firmware, to NVRAM.

Upgrading Firmware and PIB

Eventually, you may want to upgrade (or downgrade) the runtime firmware stored
in NVRAM. To do this, you must locate a copy of the new .nvm file on the
Atheros FTP site and download it to your host. You must then download the file
to the device and ask the runtime firmware on the device to write the file to
NVRAM. Writing firmware to NVRAM is also called “flashing the device”. Program
int6k can be used for this purpose when runtime firmware is executing on the
device.

Program int6k instructs runtime firmware to write to NVRAM but the firmware
will behave differently depending on how it was loaded and started. The first
time NVRAM is written by runtime firmware, the Factory PIB is created in NVRAM.
The second time, the User PIB is created. Thereafter, the User PIB will be
re-written each time. This preserves original factory settings and permits
their restoration regardless of intervening parameter changes. This means that
you should make an effort to get things right the first time.

Example 5.15.  Upgrade Firmware and PIB

# int6k  -i eth2 -P ../firmware/new.pib -N ../firmware/new.nvm -F
eth2 00:B0:52:00:00:01 Write Firmware to Device
eth2 00:B0:52:00:00:BE Wrote ../firmware/new.nvm
eth2 00:B0:52:00:00:01 Write Parameters to Device
eth2 00:B0:52:00:00:BE Wrote ../firmware/new.pib
eth2 00:B0:52:00:00:01 Flash NVRAM
eth2 00:B0:52:00:00:BE Flashing ...
eth2 00:B0:52:00:00:BE Started INT6000-MAC-3-3-3325-00-2443-20080414-FINAL-B


This example downloads a PIB file (-P) and an NVM file (-N) to the device then
instructs the runtime firmware to write (or flash) (-F) both of them to NVRAM.
Option -F always writes both to NVRAM but option -C can be used to write only
one or the other or both.

Observe that options -P, -N and -F are all in uppercase. As a rule, uppercase
options modify the device and lowercase options do not. One notable exception
to this rule is -I which merely displays device identity.

Upgrading PIB Only

When flashing a PIB to the local device, the PIB DAK must match that of the
local device or you will get a “DAK Not Zero” error message. This message is
incorrect and should probably read “DAK Mismatch”. The following two toolkit
commands should prevent this error from occuring on Linux. The first command
reads the actual MAC (-A) and DAK (-D) from the device using program int6kid
and inserts them on the command lise as modpib arguments using options -M and
-D. We need not include the station MAC address on the int6k command line
because the device is local, but we could include it.

Example 5.16.  Upgrade local device PIB

 # modpib abc.pib -ieth1 -M $(int6kid -ieth1 -A) -D $(int6kid -ieth1 -D)
 # int6k -P abc.pib -C pib



When flashing a PIB to a remote device, the PIB DAK must be all zeros or you
will get a “DAK Not Zero” error message. This message occurs because the
HomePlug™ AV Specification does not permit a DAK to be transmitted over
powerline in any form. The following two toolkit commands should prevent this
error on Linux. We must include the device MAC on the command line when
invoking each program because the device is remote. Notice that symbol none can
be used as shorthand 00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00 when
specifying the DAK.

Example 5.17.  Upgrade remote PIB

 # modpib abc.pib -ieth1 -M $(int6kid -ieth1 -A 00B052BEEF03) -D none
 # int6k -P abc.pib -C2 00B052BEEF03



The MAC address stored in the PIB can have any value but it is good practice to
preserve the original value. This avoids the common mistake of flashing
multiple network stations with the same MAC address because the PIB was not
updated.

Starting a Device

Some device configurations have no flash memory to store runtime parameters and
firmware so the local host must store them until needed then write them into
device SDRAM and start execution. This is also needed when the flash memory is
blank or corrupted because the runtime firmware is the only way to write flash
memory. Programs int6kf, int6kboot, ampboot and plcboot are used to configure a
blank device then download runtime parameters and firmware and start execution.
They all perform the same basic function but in different ways.

Example 5.18.  Start Firmware on INT6000™

# int6kf -C abc.cfg -N abc.nvm -P abc.pib

Program int6kf can be used to download runtime firmware and parameters and
start execution on and INT6000™ chipset. The process involves downloading a
.cfg file using VS_SET_SDRAM, downloading a .nvm file using VS_WR_MEM,
downloading a .pib file using VS_WR_MEM then starting firmware execution using
VS_ST_MAC. See the int6kf man page for an explanation of the command line
options and arguments used here.


Example 5.19.  Start Firmware on INT6300™ and INT6400™

# int6kboot -N abc.nvm -P abc.pib

Program int6kboot can be used to download runtime firmware and parameters and
start execution on an INT6300™ or INT6400™ chipset. The process involves
downloading a .nvm file using VS_WR_MEM, downloading a .pib file using
VS_WR_MEM then starting firmware execution using VS_ST_MAC. No .cfg file is
needed or permitted with this application.


Example 5.20.  Start Firmware on AR7400™

# ampboot -N abc.nvm -P abc.pib

Program ampboot can be used to download runtime firmware and parameters and
start execution of runtime firmware on an INT6300™, INT6400™ or AR7400™
chipset. The process involves downloading a .pib file using VS_WR_MEM,
downloading a .nvm file using VS_WR_MEM then starting firmware execution using
VS_ST_MAC. A general purpose applet, stored in the .nvm file, configures SDRAM.
No .cfg file is needed or permitted with this application.


Example 5.21.  Start Firmware on AR7420™

# plcboot -N abc.nvm -P abc.pib

Program plcboot can be used to download runtime firmware and parameters and
start execution an INT6300™, INT6400™, AR7400™ or AR7420™ chipset. This program
detects the type of chipset and the image file format. The boot process varies
depending on the chipset that is detected and the image file format. For the
AR7420™ chipset, this process involves downloading a .pib and .nvm file using
only VS_WRITE_EXECUTE messages. For earlier chipsets, the process is as
described above.


Testing a Device

When the Bootloader is running, it is possible to perform systematic diagnostic
testing by downloading and executing a variety of small programs, called
“applets”. A collection of applets can be found in the toolkit Applets folder.
Applet manpages describe the purpose of each one. Some applets are more useful
than others. Start by reading the applets manpage.

Program int6ktest can be used to sequentially download and execute a series of
applets. Applets have evolved over time and some are more useful or informative
than others. Newer applets report progress and errors on the console. Older
applets report progress or errors by flashing the onboard LEDs. This means of
testing cannot be used after the flash memory has been programmed unless you
erase, corrupt or remove the flash.

# int6ktest -i eth4 connection.nvm memctl.nvm marchloop.nvm
eth4 00:B0:52:00:00:01 Write Memory (00000000:32)
eth4 00:B0:52:00:00:01 Wrote connection.nvm
eth4 00:B0:52:00:00:01 Start connection.nvm (0)
eth4 00:B0:52:00:00:01 Write Memory (00001000:664)
eth4 00:B0:52:00:00:01 Wrote connection.nvm
eth4 00:B0:52:00:00:01 Start connection.nvm (1)
eth4 00:B0:52:00:00:01 Write Memory (00000040:6076)
eth4 00:B0:52:00:00:01 Wrote memctl.nvm
eth4 00:B0:52:00:00:01 Start memctl.nvm (0)
eth4 00:B0:52:00:00:01 Write Memory (00001000:2212)
eth4 00:B0:52:00:00:01 Wrote marchloop.nvm
eth4 00:B0:52:00:00:01 Start marchloop.nvm (0)
eth4 00:B0:52:00:00:01 0x00 March2 test - Pass

This example uses program int6ktest to download and execute applets
connection.nvm, memctl.nvm and marchloop.nvm to the powerline device on host
interface “eth4”. The first applet checks circuit board connections to memory
and reports progress and errors by flashing onboard LEDs. The second configures
the SDRAM controller and exits without any indication. The third performs a
systematic test of SDRAM and reports progress and errors on the console. In
this case the test passed.

See programs amptest and plctest for updated versions of this program for use
with AR7400™ and QCA7420™ chipsets.

Programming NVRAM

int6kf and int6kboot

The INT6300™ and INT6400™ do not require a special SDRAM configuration file and
so program int6kboot may be used in place of int6kf which is described here.
The only real difference between the two programs is the presence or absence of
option -C on the command line.

The int6kf program can program a blank or corrupted NVRAM on the INT6300. The
process involves starting the runtime firmware as shown in the previous example
then downloading a .nvm file using a VS_WR_MOD message, downloading a .pib file
using another WR_WR_MOD message then writing both to NVRAM using a VS_MOD_NVM
message. An example int6kf command line is shown below. It is identical to the
one shown above except for the addition of the flash option at the end.

Example 5.22.  Flash NVRAM with int6kf

# int6kf -C abc.cfg -N abc.nvm -P abc.pib -F


The example above starts the firmware then uses it to program the NVRAM. This
was done in one step rather than two seperate steps as shown in the examples
before it. The only difference is that int6k needs to use the 'force flash'
option when using downloaded firmware to write NVRAM. The following example
accomplishes the same thing as the previous example but uses int6k to program
NVRAM. See the int6k man page for an explanation of the command line options
and arguments used here.

The int6kf program cannot program blank or corrupted NVRAM on the INT6000
unless the Softloader is running. Since the Softloader resides in NVRAM, the
NVRAM must be either pre-programmed before use or removed and externally
re-programmed if it corrupts.

Example 5.23.  Flash NVRAM with int6k

# int6kf -C abc.cfg -N abc.nvm -P abc.pib
# int6k -N abc.nvm -P abc.pib -FF


Pairing UART Devices post PTS

This procedure describes how to pair two UART-enabled powerline adapters once
they have been programmed, personalized and tested. This example assumes you
are using a Windows host and two powerline adapters having MAC addresses
00:B0:52:00:05:F9 and 00:B0:52:00:05:FA.

Start with the first device, 00:B0:52)(00:05:F9. Plug the host serial cable
into the RJ45 port on the device and plug the device into an AC power source.

Change to transparent mode using program int6kuart. Option -v displays outgoing
command and incoming serial responses. The “+++” is the serial data sent to the
device and the “OK” is the device response.

# int6kuart -s com3 -wv
+++
OK

Read the adapter PIB into a temporary file using program int6kuart. The
following command reads the PIB from serial device com3 and saves it to file
temp.pib on the host. You will see a series of dots appear on the console as
the PIB is read from the device. The filename used is not important.

# int6kuart -s com3 -p temp.pib
....................

Program the PIB file with the default destination address using program setpib.
The following command inserts the MAC address of the second device,
00B0520005FA, at fixed offset 0x2C8A in file temp.pib downloaded in the
previous step.

# setpib temp.pib 2C8A data 00B0520005FA

Write the modified PIB file back to the adapter and commit it to flash memory
using program int6kuart. The following command write file temp.pib to serial
device com3 then commits the PIB to flash memory. You will see a series of dots
appear on the console as the PIB is written to the device. The device will
reboot.

# int6kuart -s com3 -P temp.pib -C2
....................

Change the device to Transparent Mode using program int6kuart once the device
resets.

# inc6kuart -s com3 -wv
+++
OK

Verify that the destination MAC address is correct using program int6kuart.

# int6kuart -s com3 -d
00B0520005FA

Repeat this process on the second adapter, 00:B0:52:00:05:FA, using the MAC
address of the first device, 00:B0:52:00:05:F9, as the destination address.

Trouble-shooting Problems

The following steps may help determine why two devices cannot communicate via
ethernet over the powerline. They assume that you have successfully installed
the Powerline Toolkit but are having trouble forming a powerline network.

 1. On Linux, run program ifconfig to determine available interface names as
    described earlier. The default interface name is eth1 on Linux. You must
    use interface names, not numbers, on the Linux command line.

    On Windows, run program pcapdevs to determine available interface numbers
    as described earlier. The default interface number is 2 on Windows. You
    must use interface numbers, not names, on Windows command lines, even under
    Cygwin.

    In either case, Linux or Windows, if a powerline device is connected to any
    interface other than the default interface then you must specify the name
    or number on the command line each time you run int6k. In the following
    examples, we will use device numbers 3 and 4 to indicate two different
    interfaces on the same host.

 2. Make sure both devices respond to int6k -ri3 and int6k -ri4 as described
    earlier. They should each display the software revision information. If you
    get no response then check your connections and network configuration. If
    you see “Bootloader” then the connection is good but the firmware is not
    running. If the firmware versions are different then make them the same.

    You must have running firmware to continue and the firmware revisions
    should be the same.

 3. Make sure both devices respond to int6k -Ii3 then int6k -Ii4 as described
    earlier. They should display about 10 lines of information showing their
    MAC, DAK and NMK.

    If the MAC is 00:B0:52:00:00:01 then either the default Atheros PIB was
    stored in NVRAM or you downloaded and flashed the generic Atheros PIB
    without changing the MAC address beforehand.

    If the MAC is 00:B0:52:00:00:03 then either no PIB was stored in NVRAM or
    you downloaded and attempted to flashed an invalid PIB. The firmware will
    disable powerline communications in this case.

 4. If the devices have different NMKs they will not form a network.

    One way to form a network is to manually set the NMK on each device to a
    known value with int6k -Mi3 then int6k -Mi4. Each device will reset
    afterwards and may reset again when the other device is changed. Repeat
    Step 3 and confirm that both devices have the same NMK and that “
    (HomePlugAV)” appears next to the NMK.

    Another way to form a network is to physically press the push-button on
    each device for 2 to 3 seconds or simulate a push-button press on each
    device with int6k -B1 -i3 then int6k -B1 -i4. The devices should reset
    several times and then form a network.

 5. Make sure each device knows the other one is present on the network with
    int6k -mi3 then int6k -Mi4. Each device should show that a network exists
    and identify the other device as a station on that network. It may take up
    to 120 seconds for one device to find another and up to 5 minutes to
    recognise that the other device has left the network.

 6. Step 5 should also show the TX and RX PHY rates for each device. Ping each
    host Interface from the other several times to generate traffic. The PHY
    Rates should then be non-zero. We use efsu to generate traffic inside our
    own scripts. You may elect to use another method.

 7. Power down both devices then power them up. Wait about 20 seconds and
    confirm that you can ping in either direction.

Chapter 6.  Scripting

Table of Contents

Introduction
Linux Script Basics
Host Independence
Checking Device Connection
Random Device Identity
Actual Device Identity
Editing a PIB
Initialize a Device
Update a Device
Generating Powerline Traffic
Reading PHY Rates
User Interaction

Introduction

The Powerline Toolkit comes with a variety of example scripts in the scripts
folder. They have proven useful to Atheros engineers but may not satisfy your
specific needs. This chapter explains how some of these scripts work so that
you can modify them to do what you need to do. Most scripts covered in this
chapter are intended for a Powerline Workstation.

Atheros provides GNU bash scripts as examples and does not guarantee that they
are suitable in any or all situations. Futhermore, Atheros may not always
update them to reflect changes to toolkit programs. Toolkit command line syntax
may change from one release to the next and so Atheros cannot guarantee that
older scripts will work with newer programs. The scrips are small, simple and
well organized. Do not run them until you have read them and understand what
they do and how they work.

Sample scripts are available in the scripts folder. Some extremely useful ones
are flash.sh, upgrade.sh and traffic.sh. They all reference files hardware.sh
and firmware.sh.

Although Toolkit programs run under Windows their power is realized through
scripts. Scripting requires environmental support for sophisticated symbol
substitution and expansion. Most Linux shells are suitable but Microsoft DOS is
not. On Windows, consider using installing Cygwin and using their bash shell.
Scripting languages Tcl and Python are suitable alternatives. Another
alternative is to write small Windows programs that format and execute the DOS
shell commands you want.

Linux Script Basics

We summarize some scripting rules here for those who may not be familiar with
Linux scripting. If you do not understand the rules or the syntax or have
questions then you should consult Linux documentation available on the
internet.

On Linux, all commands typed in a console window are read and interpreted by a
command interpreter called a shell program. The are several shell programs
available for Linux but we use bash exclusively. If you elect to use a
different shell program, like csh, then you will probably need to modify our
scripts.

If you do not set execute permissions you must submit it to the shell for
execution. If you set execute permissions on a script file then you can execute
it directly by typing the filename. You can set execute permission on Linux
with the chmod utility as shown in the example below.

# bash script.sh
...
# chmod 0755 script.sh
# script.sh
...

The example above show how to run a script file using bash when it does not
have execute permissions set. It then shows how to set the execute permissions
and run it directly without using bash.

It is good practice to insert a bang-path on the first line of a script to
ensure is is executed by the correct shell program, regardless of the shell
used to open the script. It is possible to open a script with one shell and
have it execute under another shell.

#!/bin/bash

The next example shows an example bang-path. The first two characters inform
the shell that this file contains scripting commands. The remainder of the
bang-path line includes a program path with any options and arguments needed by
the program. The shell will invoke that program and pass the rest of the script
file to the program as standard input.

Symbols are defined with the symbol name then an equals sign then the
definition text. By convention, symbol names use uppercase letters. The
definition consists of all characters from the equals sign to the line end. If
a definition contains white space, enclose it in quotes so that it is treated
as one string when expanded. Symbol scope ends with the defining file unless it
is exported.

NIC=eth0
MAC=00:B0:52:00:12:34
MFG="Intergalactic Software Pirates, Inc."
...
echo NIC is ${NIC} MAC is ${MAC} MFG is ${MFG}

To reference a symbol, precede the variable name with a dollar sign. Atheros
scripts go one step further by enclosing the symbol name is braces. This
improves readability and simplifies global search-and-replace operations.

Host Independence

Different hosts may use interfaces for different purposes. For example, one
host might use eth0 for local network communications and eth1 for powerline
communications. Another host might do the opposite. A portability problem is
created when scripts use the literal interface names on the command line, as
illustrated below:

#!/bin/bash
int6k -i eth1 -r
int6k -i eth2 -r

The commands shown above will work on a host where eth1 and eth2 are used for
powerline communications but will not work on another host where eth1 or eth2
are configured differently. Editing scripts can become a chore when they
contain many interface references. One solution is the consistent use of
symbols. For example, the following example provides some degree of
portability.

#!/bin/bash

NIC1=eth1
NIC2=eth2

int6k -i ${NIC1} -r
int6k -i ${NIC2} -r

The commands shown above are an improvment because symbols NIC1 and NIC2 can be
edited once; however, if you frequently move many scripts from one host to
another then each script must be changed. That can also become a chore. A
better solution is to define the symbols NIC1 and NIC2 once in a single file
and then include the definitions in scripts that need them. For example, if we
created file hardware.sh like so ...

#!/bin/bash
# file: scripts/hardware.sh

NIC1=eth1
NIC2=eth2

... then we could include it in one or more other scripts, like so ...

. ../scripts/hardware.sh

int6k -i ${NIC1} -r
int6k -i ${NIC2} -r

On Linux, the . command causes the named file to be included in-line as though
it were part of the including file. This elminates the need to export symbol
definitions. A full discussion of Linux environment variable scope can be found
on the internet. The point is that each host should have it's own definitions
files stored in a common folder so that other scripts can include them and
reference them in a consistent manner.

Atheros example scripts include two definitions files: hardware.sh and
firmware.sh. File hardware.sh defines hardware related symbols as shown below
and file firmware.sh defines firmware and configuration filenames. They reside
in a scripts folder and relative path is used to access them. This has proven
to work well in most situations.

Example 6.1.  hardware.sh

You should create a hardware.sh file in a common folder on each host where you
want to execute toolkit scripts. In this way, a script created on one host can
be executed on another host without modification.

#!/bin/bash
# file: scripts/hardware.sh

NIC1=eth1
NIC2=eth2
MAC1=00:50:04:A5:D9:5A
MAC2=00:01:03:2B:03:67

DUT=eth1

File hardware.sh assigns specific values to symbols that are used in many of
the scripts found in the scripts folder. Some Atheros scripts uses all these
symbols and some do not. By convention, NIC1 and NIC2 name the Ethernet
interfaces connected to a Golden Node and Device Under Test. MAC1 and MAC2 are
the hardware addresses of NIC1 and NIC2, respectively. These symbols can be
referenced in scripts with references like ${NIC1} or ${MAC1}. Of course, you
could define other symbols here, as well. See the script under Device Upgrade
as one example of how file hardware.sh can be included in another script.

Some scripts, such as flash.sh and upgrade.sh, only operate on one device and
do not need to define both NIC1 and NIC2. By convention, these scripts
reference interface DUT only.


Example 6.2.  firmware.sh

You should create a firmware.sh file in a common folder on each host where you
want to execute toolkit scripts. In this way, a script created on one host can
be executed on another host without modification.

#!/bin/bash
# file: scripts/firmware.sh

CFG=sdram16mb.cfg
CFG=sdram64mb.cfg

PIB=v3.3.0.pib
NVM=v3.3.0-0-5-A-FINAL.nvm
NVM=v3.3.0-0-5-B-FINAL.nvm

File firmware.sh assigns specific filenames to symbols that are used in some of
the scripts found in the scripts folder. Some Atheros scripts use all of these
symbols and some do not. By convention, CFG defines the SDRAM configuration
file used to initialize an INT6000™ or INT6300™ device, PIB defines the
Parameter Information Block file to be used and NVM defines the firmware image
file to be used.

This file is especially useful when working with a specific version of
firmware. If there are multiple definitions for a symbol, the last definition
is the one that takes effect. At Atheros, this file often contains dozens of
definitions and we merely move or copy the ones we want to the end of the file.
Our custom scripts then operate on the same configuration, parameter and
firmware files until we reorder the definitions in firmware.sh.


Checking Device Connection

You may want to confirm that a device is actually connected to an Etherenet
interface before attempting to run a script. Program int6kwait can be used for
this purpose. We often print a brief message to alert the operator that there
is no connection or the device has no power applied.

int6kwait -xqsi ${NIC1}
if [ ${?} != 0 ]; then
        echo "Device is not connected"
        exit 1
fi

In the above example, we invoke int6kwait to poll the device connected to a
specific Ethernet interface (-i) until the firmware starts (-s). The program
will return a non-zero return value (-x) if the device does not start within a
given period of time. By default, the timeout period is 60 seconds. On return,
we check the return code then print an error message and exit the script on
timeout. Symbol NIC1 must be defined earlier in the script, possibly in
hardware.sh.

Random Device Identity

Some Atheros scripts need random MAC, DAK or NMK strings as arguments to
Toolkit programs. Program rkey can be used for this purpose. We demonstrate one
way to define symbols here and demonstrate how to use symbols later on.

DAK=$(rkey secret.key -D)
NMK=$(rkey secret.key -M)

The first statement, above, uses program rkey to read file secret.key and
compute a random DAK (-D). The ouput string is assigned to symbol DAK. The
second statement uses program rkey to read the file secret.key and compute a
random NMK (-M). The output is assigned to symbol NMK.

Actual Device Identity

Some scripts need actual MAC, DAK or NMK strings as arguments to Toolkit
programs. Program int6kid can be used for this purpose. We demonstrate one way
to define symbols here and demonstrate how to use them later on.

DAK=$(int6kid -Di ${NIC1})
NMK=$(int6kid -Mi ${NIC1})

The first statement, above, uses program int6kid to echo the DAK (-D) from the
device connected to Ethernet interface NIC1 and assign the output to symbol
DAK. The second statement uses program int6kid to echo the NMK (-M) of the
device connected to Ethernet interface NIC1 and assign the output to symbol
NMK.

Editing a PIB

Many scripts place a device in a known state by editing a PIB file and writing
it to the device before starting an operation. Program modpib can be used for
this purpose. It is safe because only certain values can be changed and, where
necessary, certain cross-parameter computations are performed automatically.

modpib -C 0 -M next -D ${DAK} -N ${NMK} ${PIB}
if [ ${?} != 0 ]; then
        exit 1
fi

The example above uses modpib to set the CCo state (-C), the MAC address (-M),
the DAK (-D) and the NMK (-N) in the defined PIB file. Argument 0 means “CCo
Auto” and argument next increments the MAC address. The DAK and NMK were
defined earlier in the script. Symbol PIB must be defined earlier in the
script, possibly in firmware.sh.

Program modpib will print an error message and return a non-zero value on
error. We test the return value and exit the script on error to avoid
subsequent errors. One could, of course, suppress normal output (-q) and print
your own error message using the Linux echo utility.

Initialize a Device

Initializing a device involves downloading memory configuration parameters,
runtime firmware and runtime parameters into SDRAM and then starting the
runtime firmware to make the device fully functional. Program int6kf can be
used for this purpose when the INT6000 Softloader or INT6300 Bootloader is
running. Additionally, program int6kf can be used to flash blank or corrupted
NVRAM once runtime firmware has started.

Device initialization is only necessary when a device that has no NVRAM or has
corrupted NVRAM or has a Softloader stored in NVRAM. It is only possible when
either the INT6000 Softloader or INT6300 Bootloader is running. See The Boot
Process for detailed information.

int6kf -i ${NIC1} -C ${CFG} -P ${PIB} -N ${NVM}
if [ ${?} != 0 ]; then
        exit 1
fi

The example above uses program int6kf to download an SDRAM configuration file (
-C), PIB file (-P) and NVM file (-N) then start firmware execution. Symbols
NIC1, CFG, PIB and NVM must be defined earlier in the script, perhaps in files
hardware.sh and firmware.sh.

Program int6kf returns a non-zero value on error. We can check the return code
and exit the script on error to avoid subsequent errors. We could, of course,
suppress normal output (-q) and print our own error message using the Linux
echo utility.

In some cases, we may want to flash a blank or corrupted NVRAM after the
runtime firmware has started. We could use program int6k for this purpose but
program int6kf can be used, as well. Essentially, it initializes the device (as
above) then downloads the PIB and NVM files again and flashes them into NVRAM.

int6kf -i ${NIC1} -C ${CFG} -P ${PIB} -N ${NVM} -FF
if [ ${?} != 0 ]; then
        exit 1
fi

The example above initializes a device with an SDRAM configuration file (-C),
PIB file (-P) and NVM file (-N) as before. Once the runtime firmware has
started, the PIB and NVM files are downloaded again and flashed (-FF) into
NVRAM.

The force-flash option (-FF) is needed in this case because runtime firmware
that has been written directly to SDRAM and started by the local host assumes
there is no NVRAM present to flash or there might be Softloader firmware stored
in NVRAM that must be protected from accidental flashing. Runtime firmware that
has been read from NVRAM need not make that assumption.

Update a Device

In some cases we want to replace the runtime firmware or runtime parameters
stored in NVRAM. Program int6k can be used for this purpose when runtime
firmware is running.

A device update may be necessary when new runtime firmware or new runtime
parameters or both must be programmed into NVRAM. It is only possible when
NVRAM is present and the runtime firmware is running.

int6k -i ${NIC1} -P ${PIB} -N ${NVM} -F
if [ ${?} != 0 ]; then
        exit 1
fi

The example above uses int6k to download a PIB file (-P) and NVM file (-N) then
flash NVRAM (-F). Symbol NIC1 must be defined earlier in the script, perhaps in
file hardware.sh. Symbols PIB and NVM must also be defined earlier in the
script, perhaps in file firmware.sh.

Program int6k returns a non-zero value on error. We can check the return code
and exit the script on error to avoid subsequent errors. We could, of course,
suppress normal output (-q) and print our own error message using the Linux
echo utility.

In some cases, you may want to preserve the current firmware on a device and
update only the PIB. Program int6k can be used for this purpose, as well.

int6k -i ${NIC1} -P ${PIB} -C 2
if [ ${?} != 0 ]; then
        exit 1
fi

The example above downloads a PIB file (-P) and commits (-C) the PIB only to
NVRAM. There are a variety of device flash scenarios and each requires some
varation on one of the examples shown here.

Generating Powerline Traffic

Once two devices associate, you must send data across the powerline in both
direction so that each device can compute a TX and RX PHY rate. One method is
to use the efsu program that comes with the Toolkit. The program is designed to
send free-form Ethernet frames for test and debug purposes but we can also use
it to send lots of junk frames in either direction.

FRAME=frame.hex
COUNT=1000
efsu -i ${NIC1} -hd ${MAC2} ${FRAME} -l ${COUNT}
efsu -i ${NIC2} -hd ${MAC1} ${FRAME} -l ${COUNT}
efsu -i ${NIC1} -hd ${MAC2} ${FRAME} -l ${COUNT}
efsu -i ${NIC2} -hd ${MAC1} ${FRAME} -l ${COUNT}

The example above uses efsu to send the generic Ethernet frame stored in file
frame.hex between the two Ethernet interfaces NIC1 and NIC2 (-i). In this
example, NIC1 and NIC2 are both installed in the host. We have efsu insert the
host source address in the OSA field (-h) and destination address in the ODA
field (-d) of each frame as it is sent. The entire operation sends the same
frame 1000 times (-l) in each direction, twice.

Other methods of generating bi-directional traffic can be used but this method
is simple, needs nothing other than the toolkit programs and permits easy
synchronization. Program efsu is designed to send custom Etherenet frames, not
measure or control data rates, but the toolkit includes open source program
ttcp which is designed to measure and control data rates.

Reading PHY Rates

Atheros powerline devices automatically compute their average PHY rate which
can be read and displayed. Average PHY rate is an indication of performance and
can be affected by attenuation and ambient powerline noise. Program int6krate
is designed to report the average PHY rate.

int6krate -xni ${NIC2}
if [ ${?} != 0 ]; then
        echo "Network did not converge"
        exit 1
fi

The example above uses int6krate to read and display the average TX and RX PHY
rates for the device connected to Ethernet interface NIC2. Option -n requests
PHY rates. Option -x exits with a status that can be tested in the subsequent
“if” statement. Output appears in fix-width columns to facilitate
post-processing. Other ways to obtain PHY rates are “int6k -m” and “int6kstat
-t”.

User Interaction

Scripts should be designed, whenever possible, to perform correctly without
user intervention but there are cases where user intervention is appropriate.
The following example illustrates one bash shell method that only requires user
input when default values are wrong.

MAC=00:B0:52:00:BA:BE
echo -n "MAC Address [${MAC}]: "; read
if [ ! -z ${REPLY} ]; then
        MAC="${REPLY}"
fi

First, we define symbol MAC with a default value. The Linux echo utility prints
a prompt on the console that includes the symbol value. The trailing newline is
suppressed (-n) so that text can be typed immediately after the prompt. The
echo command is terminated with semicolon (;) so that another command can be
included on the same line. The shell read statement waits for the user to type
something and press the enter key. The shell will assign the input to shell
variable REPLY. The value of REPLY is evaluated and used to redefine the symbol
only if the input was a non-zero length string.

MAC Address [00:B0:52:00:BA:BE]:

The user will see something like this. If the value is correct the user can
press the enter key to generate a zero length string. Otherwise, the user can
type the correct value before pressing the enter key.

Chapter 7.  Support Function Reference

Table of Contents

Introduction
Command Line Functions

    assist
    basespec
    bytespec
    checkfilename
    dataspec
    error
    expect
    getoptv
    ipv4spec
    ipv6spec
    lookup
    putoptv
    synonym
    uintspec
    version

Ethernet Functions

    channel
    closechannel
    openchannel
    readpacket
    sendpacket

Network Functions

    NetworkBridges
    NetworkDevices

Generic Functions

    binout
    checksum32
    checksum_32
    chrout
    decout
    endian
    fdchecksum32
    fdchecksum_32
    filepart
    hexdecode
    hexdump
    hexencode
    hexin
    hexout
    hexstring
    hexview
    memdecr
    memincr
    memout
    memswap
    strdecr
    strfbits
    strincr
    todigit
    typename

Message Debug Functions

    MMECode
    MMEMode
    MMEName
    MMEPeek

Key Generation Functions

    MACPasswords
    HPAVKeyDAK
    HPAVKeyNMK
    HPAVKeyNID
    HPAVKeyOut
    SHA256Block
    SHA256Fetch
    SHA256Ident
    SHA256Match
    SHA256Print
    SHA256Reset
    SHA256Write

XML Editing Functions

    xmledit
    xmlfree
    xmlnode
    xmlopen
    xmlscan
    xmlschema
    xmltree

Download Functions

    WriteExecuteApplet
    WriteExecuteApplet1
    WriteExecuteApplet2

Procrastination Functions

    WaitForAssoc
    WaitForAssoc1
    WaitForAssoc2
    WaitForReset
    WaitForStart

Traffic Functions

    CrossTraffic1
    CrossTraffic2
    LocalTraffic1
    LocalTraffic2
    NetworkTraffic1
    NetworkTraffic2
    Traffic1
    Traffic2

Introduction

The Powerline Toolkit includes many general-purpose or multi-purpose functions
that may appear in other Qualcomm Atheros applications or in third party
packages. Consequently, we describe them separately and store them in separate
folders withing the toolkit.

Command Line Functions

Command line functions are used by all toolkit programs. They are generic
functions but we include them in a special section because they collectively
co-operate to convert command line options and arguments into appropriate
binary representations and provide concise but meaningful feedback when that is
not possible.

assist

void assist ( char const *          name,
              char const *          type,
              const struct _code_   list [],
              size_t                size,
              FILE *                fp);

Show why a symbolic name was rejected by function lookup or similar functions.
Argument type contains a title for the class of names stored in list. This
function prints an error message on file stream fp showing the program name,
the type string, the symbolic name and all names stored in the list. The _code_
structure is declared in types.h. The function is declared in symbol.h and
defined in assist.c. Function expect is used to print list names.

basespec

uint64_t basespec ( char const *   string,
                    unsigned       base,
                    unsigned       size);

Return the unsigned integer equivalent of a numeric string. Print an error
message on stderr and exit the program with status 1 if a syntax error occurs
or the result exceeds the capacity of the requested integer size in bytes. If
base is 0, numeric values may be expressed in decimal, hexadecimal or binary
notation where hexadecimal values start with "0x" and binary values start with
"0b". When base is non-zero, the notation in string must conform to the
corresponding number base rules. Applications should cast the return value to
the appropriate data type prevent loss-of-data compiler warnings. This function
is typically used to convert and length-check integers entered as command line
arguments. The function is declared in number.h and defined in basespec.c.

Like function uintspec, this function both converts and range checks numeric
string values, but the minimum and maximum value are implicit in the size of
the integer. The minimum value is always 0 and the maximum value can be
computed by ((1 << size << 3) - 1).

bytespec

void bytespec ( char const *   string,
                void *         memory,
                size_t         extent);

Encode a memory region with the binary equivalent of a fixed-length hexadecimal
string. Print an error message on stderr and exit the program with status 1 if
a syntax error occurs or the number of octets does not equal extent.
Hexadecimal octets may be separated by colons for readability but colons are
not required. Empty octets are illegal. The function is declared in memory.h
and defined in bytespec.c.

This function is typically used to enter fixed-length data, like hardware
addresses and encryption keys, on the command line.

checkfilename

bool checkfilename (char const * filename);

Return logical true if the filename argument contains only letters, digits,
slashes, periods, underscores and hyphens. This function can be used to detect
cases where a user accidentally entered an Ethernet address in place of a
filename on the command line. Ethernet address strings are, as it happens, also
valid filenames. The function is declared in files.h and defined in
checkfilename.c.

dataspec

void dataspec ( char const *   string,
                void *         memory,
                size_t         extent);

Encode a memory region with the binary equivalent of a variable-length
hexadecimal string. Print an error message on stderr and exit the program with
the status 1 if a syntax error occurs or the number of octets exceeds extent.
The number of octets may, however, be less than extent. Unlike function
bytespec, hexadecimal octets may not be separated by colons. This function is
typically used to enter variable-length data from the command line. The
function is declared in memory.h and defined in dataspec.c.

error

void error ( int            exitcode,
             errno_t        number,
             char const *   format,
                            ...);

This function works like printf except that printed messages appear on stderr
and are prefixed with the program name and error information. If argument errno
is non-zero then messages are prefixed with the system error description. If
argument exitcode is non-zero then function error exits the program with value
exitcode after printing the message and does not return to the caller. The
function is declared in error.h and defined in error.c.

This function is used to print informative error messages on the console and
prevent program execution from proceeding when input is invalid or some error
condition exists.

expect

void expect ( const struct _code_   list [],
              size_t                size,
              FILE *                fp);

Display all names in argument list on file stream fp. This function is called
by runction assist to print the list of symbolic names but other function may
have use for it. The _code_ structure is declared in types.h. The function is
declared in symbol.h and defined in expect.c.

getoptv

int getoptv ( int            argc,
              char const *   argv [],
              char const *   optv []);

A custom version of the POSIX function getopt. It supports standard global
variables optind, opterr, optopt and optarg and the non-standard variable
optmin. It extracts the program name from argv[0] and sets global string
pointer program_name for use by functions alert, error and others. Options -?
and --help both display program information on stdout. Options -! and --version
both display program version information on stdout. String vector optv includes
both the standard argument optstring and usage text found in many programs. The
function is declared in getoptv.h and defined in getoptv.c.

ipv4spec

size_t ipv4spec ( char const *   string,
                  void *         memory);

Encode a 4-byte memory region with an IPv4 dotted-decimal string and return the
number of bytes encoded. Terminate the program with an error message and
exitcode of 1 on conversion error. The value returned by this function is
always 4 and memory is always encoded in network byte order. This function is
typically used to convert IPv4 strings entered as command line arguments. The
function is declared in memory.h and defined in ipv4spec.c.

Dotted-decimal format consists of decimal values in the range 0 through 255.
Each value represents one octet or 8-bit value. IPv4 addresses require 4 such
values separated by one decimal point. This function permits empty octets and
leading zeros within octets. For example, “...” is equivalent to “0.0.0.0” and
“127.0.000.001” is equivalent to “127.0.0.1”. The second example will encode
memory as follows { 0x7F, 0x00, 0x00, 0x01 } which is in network byte order, or
big endian.

ipv6spec

size_t ipv6spec ( char const *   string,
                  void *         memory);

Encode a 16-byte memory region with an IPv6 colon-separated hexadecimal quartet
string and return the number of bytes encoded. Terminate the program with an
error message and exitcode of 1 on conversion error. The value returned by this
function is always 16 and memory is always encoded in network byte order. This
function is typically used to convert IPv6 strings entered as command line
arguments. The function is declared in memory.h and defined in ipv6spec.c.

Colon-separated hexadecimal quartet notation consists of hexadecimal values in
the range 0 through FFFF. Each value represents a quartet or a 32-bit value.
IPv6 addresses require 8 quartets separated by one colon. By convention, an
empty quartet expands with enough zeros to right-justify the remainder of the
address. This function permits multiple empty quartets and leading zeros within
quartets. When multiple empty quartets appear, only the right-most occurance
expands to zeros. For example, “AA12::BB34::CC56::DD78” is equivalent to
“AA12:0000:BB34:0000:CC56:0000:0000:DD78” because only the right-most empty
field expands. This will encode memory as follows { 0xAA, 0x12, 0x00, 0x00,
0xBB, 0x34, 0x00, 0x00, 0xCC, 0x56, 0x00, 0x00, 0x00, 0x00, 0xDD, 0x78 } which
is in network byte order, or big-endian.

lookup

signed lookup ( char const *          name,
                const struct _code_   list [],
                size_t                size);

Lookup a symbolic name in a list and return an associated integer or -1 if the
name does not appear in the list. A typical use is the translation of symbolic
command line arguments to integer codes. For example, some Toolkit programs
assign symbolic names to field codes so that users can enter names instead of
numbers. This approach becomes more useful as the number of permitted codes
increases. The _code_ structure is declared in types.h. The function is
declared in symbol.h and defined in lookup.c.

This function offers two benefits: 1) multiple symbols can translate to one
code and 2) names can be changed or new names added without affecting program
logic. This function is similar to but different from function synonym which
returns a character string instead of an integer.

putoptv

void putoptv (char const * optv []);

Print program information on stdout. Program information is stored in string
vector optv. String indexes are defined in file putoptv.h. String optv[0] is
the POSIX standard argument optstring. This function is called by function
getoptv whenever option -? or --help is detected on the command line. There is
virtually no need to call this function directly. The function is declared in
putoptv.h and defined in putoptv.c.

synonym

char const * synonym ( char const *          string,
                       const struct _term_   list [],
                       size_t                size);

Lookup a symbolic name in a list and return an associated string or the
original string if the name does not appear in the list. A typical use is the
translation of symbolic command line arguments to their equivalent numeric
strings before encoding them. For example, many Toolkit programs convert the
command line argument “local” to “00:B0:52:00:00:01” before encoding the device
MAC address. The _term_ structure is declared in types.h. The function is
declared in symbol.h and defined in synonym.c.

This function is similar to but different from function lookup which returns an
integer instead of a character string.

uintspec

uint64_t uintspec ( char const *   string,
                    uint64_t       minimum,
                    uint64_t       maximum);

Return the unsigned integer equivalent of a numeric string. Print an error
message on stderr and exit the program with the value 1 when a syntax error
occurs or the result exceeds the specified minimum or maximum value. Numeric
values may be expressed in decimal, hexadecimal or binary notation where
hexadecimal values start with "0x" and binary values start with "0b".
Applications should cast the return value to the appropriate data type to avoid
loss-of-data warnings on some compilers. This function is typically used to
convert and range-check integer values entered as command-line arguments. The
function is declared in number.h and defined in uintspec.c.

version

void version (void);

Print package and program version information on stdout. This function is
called by function getoptv whenever option -! or --version is detected on the
command line. There is no need to call this function directly. The function is
declared in version.h and defined in version.c. Constants PACKAGE and VERSION
define the information that is displayed. They are defined in file version.h
and must be maintained by developers.

Ethernet Functions

The Powerline Toolkit supports raw Ethernet I/O on several popular operating
systems, including Linux™, Mac OS X™ and Microsoft Windows™. Other operating
systems will probably be added over time. These functions are found in the
ether folder.

Each operating system has a different raw Ethernet interface and so some
abstraction was needed to support the toolkit for all environments. Our
solution was the channel which is implemented like a FILE pointer but is used
like a file descriptor. All toolkit programs, with a few exceptions, perform
raw Ethernet I/O by opening a channel, reading and writing to it and then
closing it.

channel

The channel structure contains enough information to perform raw Ethernet I/O
in several common runtime environments; however, portions of the structure vary
depending on the environment. These differences are appled by compile time
constants that include required structure members and exclude others. The
common structure members are identified and described below. The others
elements are not discussed because they may change.

typedef struct __packed channel
{
        signed fd;
        signed ifindex;
        char const * ifname;
        uint8_t peer [ETHER_ADDR_LEN];
        uint8_t host [ETHER_ADDR_LEN];
        uint16_t type;

         ... <operating system dependent data> ...

        signed timeout;
        flag_t flags;
} CHANNEL;

.fd

    Socket file descriptor.

.ifindex

    Ethernet device index. The index only applies when the toolkit is compiled
    for LibPcap or WinPcap. This value is the same as that returned in the
    .ifr_ifindex member of the ifreq structure available on most operating
    systems.

.ifname

    The interface name. On Linux, ethernet names are typically “eth0”, “eth1”
    and so on. On Mac OS X, interface names are “en0”, “en1” and so on. This
    string is the same as that returned by the ifr_ifname member of the ifreq
    structure available on most operating systems.

.peer

    The Ethernet hardware address of some remote device. It is used to encode
    the ODA field of outgoing Ethernet frames and format some console messages.
    It is initialized to the Atheros Local Management Address,
    00:B0:52:00:00:01 for HomePlug AV applications. Application programs can,
    and often do, replace this value at runtime.

.host

    The Ethernet hardware address of the host computer. It is used to encode
    the OSA field of outgoing Ethernet frames and format some console messages.
    This address is initialized to the hardware address assigned to the
    interface by the host operating system. The value should not change.

.type

    The Ethernet type/length field. It is used to encode the MTYPE field of
    outgoing Ethernet frames. The values is initialized to 0x88E1 for HomePlug
    AV application and 0x887B for HomePlug 1.0 application. The value should
    not change.

.timeout

    A time interval. On Linux™ and Mac OS X™, it is the maximum time that the
    application will wait for a device to respond when a response is expected.
    With LibPcap™ and WinPcap™ it the mininum time the application will wait.
    It is initialized to 50 milliseconds which is a reasonable compromise but
    most toolkit programs allow the user to change this value.

.flags

    A bitmap where each bit enables a special behavior during channel open or
    close or packet read or write. Of general interest is the CHANNEL_VERBOSE
    bit which prints outgoing and incoming frames on stderr in hexadecimal dump
    format. The verbose feature is implemented in for all toolkit programs that
    perform raw Ethernet I/O and is helpful when debugging device behavior.

Since toolkit applications typically communicate with one powerline device at a
time, this structure is statically initialized in a stand-alone module that is
linked into each application. It is possible to dynamically initialize it, if
needed. The structure is declared in channel.h and statically defined in
channel.c.

closechannel

signed closechannel ( struct channel *   channel);

Close the Ethernet socket associated with a channel and free associated memory
and data structures. Return 0 on success. Return -1 on failure. This function
is declared in channel.h and defined in closechannel.c.

openchannel

signed openchannel ( struct channel *   channel,
                     uint16_t           protocol);

Open an Ethernet socket that supports the specified protocol and associate it
with the interface referenced by the channel structure .name member. Initialize
the interface as needed. The protocol effectively filters incoming frames for
the application.

Interface initialization differs significantly from environment to environment.
The socket descriptor is stored in the channel structure .fd member and the
interface hardware address is stored in the channel structure .host member.
Return 0 on success. Terminate the program with an error message on failure.
This function is declared in channel.h and defined in openchannel.c.

readpacket

signed readpacket ( struct channel *   channel,
                    void *             packet,
                    signed             length);

Read one Ethernet frame from the specified channel. The frame is written into
memory starting at address packet and is truncated to the specified length, if
necessary. Return the actual number of bytes read on success. Return 0 on
timeout. Return -1 on network error. This function behaves like the standard
library read function. The target memory region remains unchanged on timeout or
error. This function is declared in channel.h and defined in readpacket.c.

On systems using Berkeley Packet Filters, such as MacOS X, the ODA field is
automatically replaced on transmission to prevent Ethernet address spoofing.
This may not be true on other systems but the practice is becoming more common.

sendpacket

signed sendpacket ( struct channel *   channel,
                    void *             packet,
                    signed             length);

Write one Ethernet frame to the specified channel. The frame is read from
memory starting at address packet and ending at the specified length. Return
the actual number of bytes sent on success. Return 0 on timeout. Return -1 on
network error. The frame should be properly formatted as an ethernet frame and
must be at least 60 bytes long or it will not be sent. This function behaves
like the standard library write function. The source memory region is not
modified. This function is declared in channel.h and defined in sendpacket.c.

Network Functions

NetworkBridges

size_t NetworkBridges ( struct channel *   channel,
                        void *             memory,
                        size_t             extent);

Search a channel for local powerline devices (bridges) and store their Ethernet
hardware in consecutive memory locations. The memory extent is specified in
bytes. The number of devices found is returned as the function value, provided
enough space is available to store all addressed. Unlike function
NetworkDevices, the channel peer address is ignored.

We call local devices “bridges” because each serves as an Ethernet-to-Powerline
bridge for the local host.

Example 7.1.  Enumerating Local Devices

#include <net/if.h>
#include "../ether/channel.h"
extern struct channel channel;
uint8_t address [255][ETHER_ADDR_LEN];
size_t bridges = NetworkBridges (&channel, address, sizeof (address));
size_t bridge = 0;
while (bridge < bridges)
{
   binout (address [bridge], ETHER_ADDR_LEN, ':', stdout);
   putc ('\n', stdout);
}

The code segment shown above illustrates how to use function NetworkBridges to
identify all local devices. We do not need to set the channel peer because
NetworkBridges always uses the Atheros localcast address. Array address is
declared with two dimensions to simplify access to individual addresses on
return.


NetworkDevices

size_t NetworkDevices ( struct channel *   channel,
                        void *             memory,
                        size_t             extent);

Query a powerline device, specified by channel, for neighboring network devices
and store their Ethernet addresses in consecutive memory locations. The memory
extent is specified in bytes. The number of devices found is returned as the
function value, provided sufficient space is available to store all addresses.
Unlike function NetworkBridges, the channel peer address is identifies the
device to be queried.

Example 7.2.  Enumerating Network Devices

#include <net/if.h>
#include "../ether/channel.h"
extern struct channel channel;
uint8_t address [255][ETHER_ADDR_LEN];
size_t devices = NetworkDevices (&channel, address, sizeof (address));
size_t device = 0;
while (device < devices)
{
   binout (address [device], ETHER_ADDR_LEN, ':', stdout);
   putc ('\n';, stdout);
}

The code segment shown above illustrates how to use function NetworkDevices to
identify all devices on a specific network. You must set the channel peer
address before calling NetworkDevices. Array address is declared with two
dimensions to simplify access to individual addresses on return. If the channel
peer address is not the Ethernet broadcast or Atheros localcast address then
the first address returned will be the channel peer address.


Generic Functions

The functions in this chapter are generic and may have application beyond the
Powerline Toolkit. In some cases, these functions appear in other Atheros or
Open Source software packages. In a few cases, the Toolkit may include
complementary or supplementary support functions but only use one or two of
them. For example, functions memincr and memdecr are both included but memdecr
is not used.

binout

void binout ( void const *   memory,
              size_t         extent,
              char           c,
              char           e,
              FILE *         fp);

Print a memory region as a series of binary octets separated by character c and
terminated by character e. Normally, character c will be BIN_EXTENDER, defined
in file number.h, but it could be any character value. Normally, character e
will be a space or newline, but it could be any character value. A typical use
might be to print a register in readable format. For example, specifying c as
'-', e as ';' and extent as 4 would produce output looking something like
"10101010-1111111-00000000-11001100;" where each octet is expressed as a binary
integer. The function is declared in memory.h and defined in binout.c.

checksum32

unint32_t checksum32 ( const uint32_t   memory [],
                       size_t           extent,
                       uint32_t         checksum);

Return the 32 bit checksum of a memory region. The checksum is the one's
complement of the XOR of all 32 bit words in the region. Argument extent is the
region extent in 32 bit words. Argument checksum is the reference checksum. The
function will return the computed checksum when referencechecksum is 0 and will
return 0 if reference checksum equals the computed checksum. A typical use is
to validate PIB and NVM files or compute new checksums when these files are
created or modified. The function is declared in memory.h and defined in
checksum32.c.

This function is similar to checksum_32 but is used exclusively by API
functions. It may be deprecated at some point in the future.

checksum_32

unint32_t checksum_32 ( void const *   memory,
                        size_t         extent,
                        uint32_t       checksum);

Return the 32 bit checksum of a memory region. The checksum is the one's
complement of the XOR of all 32 bit words in the region. The region extent is
specified in bytes but it will be rounded down to the nearest multiple of 4
bytes. Argument checksum is the reference checksum. The function will return
the computed checksum when referencechecksum is 0 and will return 0 if
reference checksum equals the computed checksum. A typical use is to validate
PIB and NVM files or compute new checksums when these files are created or
modified. The function is declared in memory.h and defined in checksum_32.c.

This function is similar to function checksum32 however there is no need to
cast memory to uint32_t and there is no need to round extent down to a multiple
of 4 bytes before calling the function because both operations are performed
internally. Also, there is no unecessary endian manipulation of the checksum.
It is the prefered method of computing a checksum.

chrout

void chrout ( void const *   memory,
              size_t         extent,
              char           c,
              char           e,
              FILE *         fp);

Print a memory region as a string of printable ASCII characters terminated by
character e. Character c is printed in place of non-printable characters. The
string is terminated by character e. Normally, character c is '.' but it could
be any character value. Normally, character e is space or newline but it could
be any charcter value. A typical use might be to print a memory region that may
(or may not) contain an HFID or other printable text. The function is declared
in memory.h and defined in chrout.c.

decout

void decout ( void const *   memory,
              size_t         extent,
              char           c,
              char           e,
              FILE *         fp);

Print a memory region as a series of decimal octets separated by character c
and terminated by character e. Normally, character c will be DEC_EXTENDER,
defined in file number.h, but it could be any character value. Normally,
character e will be a space or newline but it could be any character value. A
typical use might be to print an IP address in readable format. For example,
specifying c as '.', character e as '/' and extent as 4 would produce output
looking something like "192.168.099.001/" where each octet is expressed as a
decimal integer. The function is declared in memory.h and defined in decout.c.

endian

void endian (void * memory, size_t extent);

Reverse the byte order of a memory region. It is a variable extent version of
functions like __bswap_16, __bswap_32 and __bswap_64. The function is declared
in memory.h and defined in endian.c.

fdchecksum32

unit32_t fdchecksum32 ( int        fd,
                        size_t     extent,
                        unit32_t   checksum);

Return the 32 bit checksum of a file region starting from the current file
position. The checksum is the one's complement of the XOR or of all 32 bit
words in the region. Argument extent must be specified in 32 bit words, not
bytes. Argument checksum is the reference checksum. The function will return
the computed checksum when referencechecksum is 0 and will return 0 if
reference checksum equals the computed checksum. A typical use is to validate
NVM files header by header or section by section. The function is declared in
memory.h and defined in fdchecksum32.c.

fdchecksum_32

unit32_t fdchecksum_32 ( int        fd,
                         size_t     extent,
                         unit32_t   checksum);

Return the 32 bit checksum of a file region starting from the current file
position. The checksum is the one's complement of the XOR or of all 32 bit
words in the region. Argument extent is specified in bytes but is rounded down
to the nearest multiple of 4 bytes. Argument checksum is the reference
checksum. The function will return the computed checksum when referencechecksum
is 0 and will return 0 if reference checksum equals the computed checksum. A
typical use is to validate NVM files header by header or section by section.
The function is declared in memory.h and defined in fdchecksum_32.c.

This function is similar to function fdchecksum32 but there is no need to round
extent down to the nearest multiple of 4 bytes before calling the function
because that is done internally. Also, there is no unecessary endian
manuipulation of the checksum.

filepart

char const * filepart ( char const *   pathname);

Return the address of the filename portion of a pathname string. The filename
portion is everything after the rightmost path separator. If a path separator
is not present then the address of the pathname string is returned. This
function is similar to the POSIX basename function but it returns an empty
string whenever the rightmost character is a path separator. The path separator
can be either slash ('/') or backslash ('\\'). The function is declared in
files.h and defined in filepart.c.

hexdecode

signed hexdecode ( void *       memory,
                   size_t       extent,
                   char const   buffer [],
                   size_t       extent);

Decode a memory region as a string of ASCII hexadecimal digits. Convert memory
until the buffer or memory exhausts and return the string extent. Allow three
(3) string characters for each memory byte to be decoded. The number of bytes
decoded will be the lesser of argument extent divided by 3 or argument extent.
The function is declared in memory.h and defined in hexdecode.c.

hexdump

void hexdump ( void const *   memory,
               size_t         offset,
               size_t         extent,
               FILE *         fp);

Print a full or partial memory region in hexadecimal format showing memory
offsets, hexadecimal byte values and ASCII character values. Argument memory
contains some memory region. Argument extent is the region extent. Argument
offset is the starting display location. Locations memory [offset] up to memory
[extent] are displayed, allowing a partial dump of the memory region. An offset
of 0 will display the entire region. The function is declared in memory.h and
defined in hexdump.c.

This function is similar to but different from function hexview .

hexencode

signed hexencode ( void *         memory,
                   size_t         extent,
                   char const *   string);

Encode a memory region with the binary equivalent of an ASCII hexadecimal
string. Return the number of bytes encoded or 0 on error. The value of errno is
set to EINVAL if the number of bytes encoded is less than extent or the entire
string cannot be converted due to illegal digits or excessive digits. Ignore
optional HEX_EXTENDER characters separating octets in argument string. Constant
HEX_EXTENDER is defined in file number.h. The function is declared in memory.h
and defined in hexencode.c.

hexin

ssize_t hexin ( void const *   memory,
                size_t         extent,
                FILE *         fp);

This function is similar to hexencode but it reads from file, instead of a
string and ignores non-hexadecimal text and comments within the input stream.
Incoming text is binary encoded and written to the specified memory region. The
actual number of bytes encoded is returned or -1 on error. See the efsu man
page for a thorough explanation of function behavior. The function is declared
in memory.h and defined in hexin.c.

hexout

void hexout ( void const *   memory,
              size_t         extent,
              char           c,
              char           e,
              FILE *         fp);

Print a memory region as a series of hexdecimal octets separated by character c
and termianted by character e. Normally, character c will be HEX_EXTENDER,
defined in file number.h, but it could be any character value. Normally,
character e will be a space or newline but it could be any character value. A
typical use might be to print a MAC or Ethernet address in readable format. For
example, specifying c as ':', character e as ',' and extent as 6 would produce
output looking something like "00:B0:52:DA:DA:01," where each octet is
expressed as a hexadecimal integer. The function is declared in memory.h and
defined in hexout.c.

hexstring

char * hexstring ( char           buffer [],
                   size_t         length,
                   void const *   memory,
                   size_t         extent);

Convert a memory region to a NUL terminated string and return the string
address. This function is identical to function hexdecode but it return the
string address instead of the number of characters decoded. The function is
declared in memory.h and defined in hexstring.c.

hexview

void hexview ( void const *   memory,
               size_t         offset,
               size_t         extent,
               FILE *         fp);

Print a partial memory region in hexadecimal format showing memory offsets,
hexadecimal byte values and ASCII character values. Argument memory contains
part of a larger memory region, much like a file window. Argument extent is the
window length. Argument offset is the relative offset of the window within the
region. Locations memory [0] up to but excluding memory [extent] are displayed
as a partial dump, providing a window into the region. The function is declared
in memory.h and defined in hexview.c.

This function is similar to but different from function hexdump.

memdecr

signed memdecr ( void *   memory,
                 size_t   extent);

Decrement a multi-byte memory region. Return 0 on success or -1 if all bytes
have decremented to 0x00. For example, { 0xFF, 0xFF, 0xFF } decrements to {
0xFF, 0xFF, 0xFE } and { 0xFF, 0x00, 0x00 } decrements to { 0xFE, 0xFF, 0xFF }.
A typical use is to iterate through a range if IP or MAC address values. The
function is declared in memory.h and defined in memdecr.c.

memincr

signed memincr ( void *   memory,
                 size_t   extent);

Increment a multi-byte memory region. Return 0 on success or -1 once all bytes
have been incremented to 0xFF. For example { 0x00, 0x00, 0x00 } increments to {
0x00, 0x00, 0x01 } and { 0x00, 0xFF, 0xFF } increments to { 0x01, 0x00, 0x00 }.
A typical use is to iterate through a range of IP or MAC address values. The
function is declared in memory.h and defined in memincr.c.

memout

void memout ( void const *   memory,
              size_t         extent,
              char const *   format,
              unsigned       group,
              signed         c,
              FILE *         fp);

Print a memory region as a series of octet groups wach separated by character
c. The group argument specifies the number of octets per group. The format
argument determines how each octet is displayed. Normally, character c will be
one of BIN_EXTENDER, DEC_EXTENDER or HEX_EXTENDER as defined in file number.h,
but it could be any character value. The function is declared in memory.h and
defined in memout.c.

memswap

void memswap ( void *   buffer1,
               void *   buffer2,
               size_t   length);

Exchange the contents of one buffer with that of another. No provision is made
for buffer overlap. No value is returned. A typical use might be to exchange
source and destination addresses in an ethernet packet. The function is
declared in memory.h and defined in memswap.c.

strdecr

signed strdecr ( void *   memory,
                 size_t   extent,
                 byte     min,
                 byte     max);

Decrement a multi-byte memory region using only ASCII character values in the
range min through max. Return 0 on success or -1 once all characters have been
decremented to the value of argument min. For example, if argument min is 'A'
and argument max is 'Z' then { 'A', 'B', 'C' } decrements to { 'A', 'B', 'B' }
and { 'B', 'Z', 'Z' } decrements to { 'A', 'A', 'A' }. A typical use is to
generate a sequence of distinct character strings to seed encryption key
functions. The function is declared in memory.h and defined in strdecr.c.

strfbits

size_t strfbits ( char const     buffer [],
                  size_t         length,
                  char const *   operands [],
                  char const *   operator,
                  unsigned       flagword);

Encode a buffer with an enumerated list of the operands associated with the
corresponding bits in flagword. separate enumerated operands with an operator
string. For example, given char const *operands [] = { "loop", "wait", "busy" }
and unsigned flagword = 0x05 then strfbits (buffer, length, operands, "|",
flagword) would encode buffer with "loop|busy". Observe that each bit set in
flagword appears in buffer as the corresponding string from operands. A typical
application for this function is the enumeration of flagword states. The
function is declared in format.h and defined in strfbits.c.

strincr

signed strincr ( void *   memory,
                 size_t   extent,
                 byte     min,
                 byte     max);

Increment a multi-byte memory region using only ASCII character values in the
range min through max. Return 0 on success or -1 once all characters have been
incremented to the value of argument max. For example, if argument min is 'A'
and argument max is 'Z' then { 'A', 'B', 'C' } increments to { 'A', 'B', 'D' }
and { 'A', 'Z', 'Z' } increments to { 'B', 'A', 'A' }. A typical use is to
generate a sequence of distinct character strings to seed encryption key
functions. The function is declared in memory.h and defined in strincr.c.

todigit

unsigned todigit (unsigned c);

Return the integer value of character c interpreted as digit in the base 36
number system. It is called by many encode functions to support number base
conversion. If the value of c is '0' through '9' then integer 0 through 9 is
returned. If the value of c is 'A' through 'Z' or 'a' through 'z' then integer
10 through 35 is returned. The function is declared in number.h and defined in
todigit.c.

typename

char const * typename ( const struct _type_   list [],
                        size_t                size,
                        type_t                type,
                        char const *          name);

Return the name associated with a message type by searching a list arranged in
ascending order by message type. Return argument name as the function value if
the message type is not present in the list. Data types struct _type_ and
type_t are defined in file types.h. A typical use might be to return the name
of message based on the message type. The function is declared in symbol.h and
defined in typename.c.

Message Debug Functions

Message debug functions are not needed for proper toolkit operation but they
can be useful during development, debugging and testing phases of product
development. They are specific to HomePlug AV messages only.

MMECode

char const * MMECode ( uint16_t   MMTYPE,
                       uint8_t    MSTATUS);

Return text that explains the status code for a given Atheros vendor-specific
management message. Argument MMTYPE is an unsigned integer in the range 0xA000
through 0xAFFF and must exactly match the MMTYPE of the message returning the
status code. For example, the CNF variant of a message is currently the only
variant that has an MSTATUS field and so other variants return a default
string. The function is declared in mme.h and defined in MMECode.c.

Inclusion of this function can increase application size by 3kb because the
text associated with all Atheros vendor-specific management messages and errors
are included whether needed or not. Conditional compilation statements are
provided internally to suppress the full table with a terse substitute.

Although the Bootloader and firmware share some common Vendor Specific
Management Messages, the two programs may return different codes for a given
message and error condition. Where there are conflicts, Bootloader codes take
precedence over firmware codes because it is unlikely that users will .issue
the same messages to a device running firmware.

MMEMode

char const * MMEMode (uint16_t MMTYPE);

Return the mode of a given management message type as a string. The mode is
determined by the two least significant bits of argument MMTYPE. The mode
string will be one of “REQ”, “CNF”, “IND” or “RSP”. The function is declared in
ihp.h and defined in MMEMode.c.

Most management messages have a request and a confirmation variant while a few
have an indication and a response variant. Requests originate from the host and
are acknolwedged by a confirmation from the device. Indications originate from
a device and are acknowledged by a response from the host.

MMEName

char const * MMEName (uint16_t MMTYPE);

Return the name associated with a given management message type. The name is
the mnemonic used to distinguish one message type from another in the HomePlug
AV Specification or Atheros Firwmare Technical Reference Manual. Argument
MMTYPE is an unsigned integer in the range 0x0000 through 0xAFFF. The request,
confirmation, indication and response variants of a management message will all
return the same message name. The function is declared in mme.h and defined in
MMEName.c.

MMEPeek

void MMEPeek ( void const *   memory,
               size_t         extent,
               FILE *         fp);

Prints an Atheros vendor-specific management message to stream fp in human
readable format. Argument buffer is the message address and argument extent is
the message extent in bytes. Output consists of a formatted header showing
decoded header. The function is declared in mme.h and defined in MMEPeek.c.

Key Generation Functions

Atheros applications use the SHA256 algorithm to compute unique HomePlug AV
keys, including the Device Access Key (DAK), Network Membership Key (NMK) and
Network Identifier (NID). The SHA256 algorithm is seeded, salted and rehashed
differently for each type of HomePlug AV key. A different function is used to
compute each type of HomePlug AV key but all of them call the SHA256 functions.
The SHA256 algorithm returns a 256 bit (32 byte) digest but only the upper 128
bits (16 bytes) are used for HomePlug AV keys.

Example 7.3.  SHA256 Digest Computation

The following code example illustrates how to generate, rehash and print an
SHA256 digest, or key, from a user-defined seed string and salt string. This
logic is typical of that used to generate HomePlug AV compliant keys. See the
HomePlug AV Specification for the specific rules used to generate each type of
key.

#include <stdio.h>

#include "../crypt/SHA256.h"

#include "../crypt/SHA256Reset.c"
#include "../crypt/SHA256Block.c"
#include "../crypt/SHA256Write.c"
#include "../crypt/SHA256Fetch.c"

struct sha256 sha256;
char * seed = "ForMeToKnowAndYouToFindOut";
char * salt = "X$z@p";
byte digest [SHA256_DIGEST_SIZE];
int i;

SHA256Reset (&sha256);
SHA256Write (&sha256, (byte *)(seed), strlen (seed));
SHA256Write (&sha256, (byte *)(salt), strlen (salt));
SHA256Fetch (&sha256, digest);

for (i = 0; i < 999; i++)
{
        SHA256Reset (&sha256);
        SHA256Write (&sha256, digest, sizeof (digest));
        SHA256Fetch (&sha256, digest);
}
for (i = 0;  i < 16; i++)
{
        printf ("%02x", digest [i]);
}
printf ("\n");

Above, we declare struct sha256 and initialize it using function SHA256Reset.
We then write a user-defined seed string (or password) followed by an optional
salt string to the digest using function SHA256Write. The resulting digest (or
key) is obtained by calling function SHA256Fetch. Constant SHA256_DIGEST_SIZE
is defined in SHA256.h. Although the digest is probably secure enough at this
point, we rehash it 999 times for good measure. We then print the first 16
bytes of the result because HomePlug AV keys are always 16 bytes long.


MACPasswords

void MACPasswords ( uint32_t   vendor,
                    uint32_t   device,
                    uint32_t   number,
                    unsigned   count,
                    unsigned   bunch,
                    unsigned   space,
                    flag_t     flags);

Print a range of device addresses and user passwords on stdout. The calling
application must split the starting device address into a three-byte OUI and
three-byte device number and pass them as the unsigned 32-bit integers vendor
and device, respectively. Argument device is the first device number in the
range and number is the final device number. Argument count is the number of
uppercase letters comprising a password. Passwords contain this many letters
but the letters are grouped for easy reading. Letter groups are separated by
hyphens. Argument bunch defines how many letters form each group. Argument
space is the character used to separate groups of letters. Argument flags
enables or disables function features such as insertion of a “used” flag for
use by the Atheros Production Test System or the omission of the device address
on output. The output of this function is similar to that produced by the DB
Builder utility distributed with the PTS. This function is declared in keys.h
and defined in MACPasswords.c.

HPAVKeyDAK

void HPAVKeyDAK ( byte         DAK [],
                  char const   string);

Encode buffer DAK with the Device Access Key (DAK) derived from the NUL
terminated string. The string is salted, hashed and re-hashed using the SHA256
algorithm. The DAK is always HPAVKEY_DAK_LEN bytes, defined in HPAVKey.h, so no
length argument is needed. See the HomePlug AV Specification for more
information. This function is declared in HPAVKey.h and defined in HPAVKeyDAK.c
.

HPAVKeyNMK

void HPAVKeyNMK ( byte         digest [],
                  char const   string);

Encode buffer NMK with the Network Membership Key (NMK) derived from the NUL
terminated string. The string is salted, hashed and re-hashed using the SHA256
algorithm. The DAK is always HPAVKEY_NMK_LEN bytes, as defined in HPAVKey.h, so
no length argument is needed. See the HomePlug AV Specification for more
information. This function is declared in HPAVKey.h and defined in HPAVKeyNMK.c
.

HPAVKeyNID

void HPAVKeyNID ( byte         NID [],
                  byte const   NMK [],
                  signed       level);

Encode buffer NID with the Network Identification Key (NID) derived from the
16-byte Network Membership Key (NMK). The NMK is hashed and re-hashed using the
SHA256 algorithm then encoded with the security level. The NID is always
HPAVKEY_NID_LEN bytes, as defined in HPAVKey.h, so no length argument is
needed. See the HomePlug AV Specification for more information. This function
is declared in HPAVKey.h and defined in HPAVKeyNID.c.

HPAVKeyOut

void HPAVKeyOut ( byte const     digest [],
                  size_t         length,
                  char const *   phrase,
                  flag_t         flags);

Decode and print up to length bytes from buffer digest on stdout. Print NUL
terminated phrase on the same line following the digest when bit
HPAVKEY_VERBOSE, defined in HPAVKey.h, is set in flags. This procedure prints
keys and phrases in a standard column-oriented format that other applications
can easily read and use. This function is declared in HPAVKey.h and defined in
HPAVKeyOut.c.

SHA256Block

void SHA256Block ( struct sha256 *   sha256,
                   void const *      memory);

Merge 64 bytes of memory into the current SHA256 digest. This function performs
the core computations required by the SHA256 algoithm. It is called by function
SHA256Fetch and so there is no reason to call this function directly. The
sha256 structure is defined in SHA256.h. The function is declared in SHA256.h
and defined in SHA256Block.c.

SHA256Fetch

void SHA256Fetch ( struct sha256 *   sha256,
                   byte              digest []);

Conclude SHA256 computation and transfer the result to the named 32-byte digest
then flush the sha256 structure. The digest is always 32 bytes long regardless
of the amount of information that has been written using function SHA256Write.
The sha256 structure is defined in SHA256.h. This function is declared in
SHA256.h and defined in SHA256Fetch.c.

Once this function is called, the sha256 structure is purged for security
reasons. You must call SHA256Reset again before starting another hash or
subsequent calls to this function or SHA256Write will have unpredictable
results. .

SHA256Ident

void SHA256Ident (int fd, byte digest []);

Compute the SHA256 digest from the content of a file. The digest serves as the
file “fingerprint” and can be used to identify identical content despite
filename changes. File descriptor fd is the subject file which must be
positioned to the start befor calling this function. Buffer digest will be
written with the computed 256-digest and must be SHA256_DIGEST_SIZE bytes long,
as defined in SHA256.h. This function is declared in SHA256.h and defined in
SHA256Ident.c.

SHA256Match

void SHA256Match ( int          fd,
                   byte const   digest []);

Search a registry file for a known SHA256 digest. Return true on success or
false on failure. File descriptor fd is the registry file which must be
positioned to the start before calling this function. Buffer digest contains
the known 256-bit digest and must be SHA256_DIGEST_SIZE bytes long, as defined
in SHA256.h. A registry file consists of 64-digit hexadecimal strings that
represent SHA256 digest values. Optional text may be appear between the digest
and newline to document digest significance. This function ignores such text.
This function is declared in SHA256.h and defined in SHA256Match.c.

SHA256Print

void SHA256Print ( byte const     digest [],
                   char const *   string);

Print an SHA256 digest and optional string on stdout. Buffer digest must be
SHA256_DIGEST_SIZE bytes long, as defined in SHA256.h, which results in 64
hexadecimal digits on output. Variable length string is NUL terminated but may
be NULL. If string is not NULL and is not empty then a space is inserted
between the digest and the string on output. This function may be used to print
SHA256 digests and optional strings in standard format, such as a registry
file. This function is declared in SHA256.h and defined in SHA256Print.c.

SHA256Reset

void SHA256Reset (struct sha256 * sha256);

Initialize a sha256 structure before computing a new SHA256 digest. This
function should be called once before calling SHA256Write for the first time
for a given digest. The sha256 structure is defined in SHA256.h. This function
is declared in SHA256.h and defined in SHA256Reset.c.

SHA256Write

void SHA256Write ( struct sha256 *   sha256,
                   void const *      memory,
                   size_t            extent);

Writes a region of memory to the current SHA256 digest contained in an sha256
structure. An application may call this function any number of times to
concatinate multiple memory regions before fetching the digest with function
SHA256Fetch. The sha256 structure is defined in SHA256.h. This function is
declared in SHA256.h and defined in SHA256Write.c.

XML Editing Functions

Atheros provides support for remote PIB management using XML instruction files.
The concept is based on an XML schema that defines the elements and attributes
needed to edit a PIB file. The schema is located in file piboffset.xsd. In
practice, this schema could be used to edit any buffer containing data but we
are only interested in editing PIB files here.

Users may create XML files that conform to the schema and specify the PIB
objects they want to change and how they want each to change. In brief, the
files specify an offset, a data length and a data value. A data value has type
dataString, dataHex or dataByte and may be a single data item or an array of
data items. Each XML file should include a reference to the Atheros schema and
be submitted to a validating XML parser, such as Internet Explorer or Firefox,
to ensure that file structure and syntax are correct before use. An example XML
file can be seen in piboffset.xml.

Editing involves the following steps. An example of these steps can be seen in
the pxe program source code and in function RdModWrPib2.c which is a component
of the int6k2 program.

 1. Obtain a copy of the PIB to be edited. This can be done by opening a PIB
    file and reading the entire file into memory or by requesting the PIB
    directly from an active Atheros powerline device. The PIB length can be
    determined from the PIB header.

 2. Open the XML file, generate an XML parse tree and close the file. This can
    be done by passing the filename to function xmlopen. It will perform all
    these steps and return the parse tree root node.

 3. Modify the PIB based to instructions stored in the parse tree. This is done
    by passing the parse tree, PIB buffer and PIB length to function xmledit.
    It will traverse the parse tree and apply changes to the buffer as defined
    in the parse tree.

 4. Discard the parse tree. This can be done by passing the parse tree to
    function xmlfree.

 5. Compute a new PIB checksum. This can be done by clearing the PIB checksum
    then passing the PIB buffer and PIB length to function checksum32 with a
    checksum value of 0.

 6. Write the PIB to file or transmit it over the network to an Atheros
    powerline device.

xmledit

signed xmledit ( struct node *   node,
                 void *          memory,
                 unsigned        extent);

Write data into memory based on the data offset and length defined in XML parse
tree, node. This function will not apply modifications having malformed
structure or having an invalid or illegal offset, length or data value. Use
function xmlschema to print the current schema. The function is declared in
nodes.h and defined in xmledit.c. The node structure is defined in nodes.h.

xmlfree

void xmlfree (struct node * node);

Release memory associated with an XML parse tree. The function is declared in
nodes.h and defined in xmlfree.c. The node structure is defined in nodes.h.

The text member if the parse tree root node points to memory allocated by
xmlscan to store the original XML string. The application must either
deallocate that memory before calling this function or store the text address
and deallocate that memory after calling this function; otherwise, memory leaks
will result.

xmlnode

struct node *xmlnode (struct node *node);

Create an empty node blow the specified node and return a pointer to it. A
typical application can be seen in function xmlscan.c. The function is declared
in nodes.h and defined in xmlnode.c. The node structure is defined in nodes.h.

xmlopen

struct node * xmlopen ( char const *   filename);

Open the named XML file, parse it and return the XML parse tree. The parse tree
contains, among other things, all XML elements, attributes and values specified
in the file. The function is declared in nodes.h and defined in xmlopen.c. The
node structure is defined in nodes.h.

The returned parse tree is ready to traverse using struct node members above,
below, prior and after. Each node has a line, type and test member. This
function calls function xmlscan to parse the file and generate the tree. The
parse tree can be inspected by passing the root node to function xmltree.

xmlscan

signed xmlscan  (struct node * node);

Scan the XML string attached to the specified node and create a parse tree
below it. Return 0 if parsing is successrul or -1 if not. The function is
declared in nodes.h and defined in xmlscan.c. The node structure is defined in
nodes.h.

The application must point the text member to a copy of the XML string before
calling this function because parsing is destructive and requires write access
to the string. The application can search and manipulate the tree on return.
The application should deallocate string memory before calling xmlfree.

Example 7.4.  XML Source File

The following is sample input to function xmlscan. The element and attribute
names shown are for illustration and were selected to that they can be easily
identified in the output. The parse tree from this file can be seen in the
example for function xmltree.

<?xml version="1.0" encoding="UTF-8" ?>
<xmlfile
        xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
        xsi:noNamespaceSchemaLocation="myschema.xsd">
        <element name="Element1">
                <attribute name="Attribute1">
                        1234567890
                        </attribute>
                <attribute name="Attribute2">
                        The quick brown fox jumped over the lazy dog.
                        </attribute>
                </element>
        <element name="Element2">
                <attribute name="Attribute1">
                        </attribute>
                <attribute name="Attribute2">
                        The quick brown
                        fox jumped over
                        the lazy dog.
                        </attribute>
                </element>
<!-- comments can go anywhere -->
        <element name="Element2">
                <attribute name="Attribute1"/>
                <attribute name="Attribute2">
                        value2
                        </attribute>
                </element>
        </xmlfile>


xmlschema

void xmlschema ();

Print an XML schema that supports function xmledit on stdout. This function has
no argument. The schema produced by this function is guaranteed to support the
parse logic implemented by function xmledit. Scheme element names are defined
as constants in nodes.h so that they can be referenced by applications that
create their own XML edit instructions. The function is declared in nodes.h and
defined in xmlschema.c.

The text member in the parse tree root node points to memory allocated by
xmlscan to store the original XML string. The application must either
deallocate that memory before calling this function or store the text address
and deallocate that memory after calling this function; otherwise, memory leaks
will result.

Example 7.5.  XML Edit Schema

<?xml version='1.0' encoding='UTF-8'?>
<xs:schema xmlns:xs='http://www.w3.org/2001/XMLSchema' elementFormDefault='qualified'>
        <xs:element name='pib'>
                <xs:complexType>
                        <xs:sequence>
                                <xs:element maxOccurs='unbounded' ref='object'/>
                                </xs:sequence>
                        </xs:complexType>
                </xs:element>
        <xs:element name='object'>
                <xs:complexType>
                        <xs:attribute name='name' use='required' type='xs:NCName'/>
                        <xs:sequence>
                                <xs:sequence>
                                        <xs:element ref='offset'/>
                                        <xs:element ref='length'/>
                                        </xs:sequence>
                                <xs:choice>
                                        <xs:element ref='array'/>
                                        <xs:element ref='dataString'/>
                                        <xs:element ref='dataByte'/>
                                        </xs:choice>
                                </xs:sequence>
                        </xs:complexType>
                </xs:element>
        <xs:element name='length' type='xs:positiveInteger'/>
        <xs:element name='offset' type='xs:hexBinary'/>
        <xs:element name='array'>
                <xs:complexType>
                        <xs:choice maxOccurs='unbounded'>
                                <xs:element ref='dataByte'/>
                                <xs:element ref='dataHex'/>
                                </xs:choice>
                        </xs:complexType>
                </xs:element>
        <xs:element name='dataString' type='xs:string'/>
        <xs:element name='dataHex' type='xs:hexBinary'/>
        <xs:element name='dataByte' type='xs:unsignedByte'/>
        </xs:schema>

The schema shown above was produced by function xmlschema. It is should be used
to validate XML edit instructions before submitting them to program pxe.


xmltree

void xmltree (struct node * node);

Print the XML parse tree on stdout. The function is declared in nodes.h and
defined in xmltree.c.

Example 7.6.  XML Parse Tree

The following is sample output from function xmltree. The XML source is shown
in the example for function xmlscan . The numbers appearing down the left
margin indicate the input line number from the XML source file parsed by
function xmlscan . The character codes indicate the node type and are defined
in nodes.h. The node structure is defined in nodes.h.

001 [?] [xml]
001 [ ]         [version]
001 [=]                 [1.0]
001 [ ]         [encoding]
001 [=]                 [UTF-8]
002 [<] [xmlfile]
002 [ ]         [xmlns:xsi]
002 [=]                 [http://www.w3.org/2001/XMLSchema-instance]
002 [ ]         [xsi:noNamespaceSchemaLocation]
002 [=]                 [myschema.xsd]
003 [<]         [element]
003 [ ]                 [name]
003 [=]                         [Element1]
004 [<]                 [attribute]
004 [ ]                         [name]
004 [=]                                 [Attribute1]
005 [>]                         [1234567890]
006 [/]                         [attribute]
007 [<]                 [attribute]
007 [ ]                         [name]
007 [=]                                 [Attribute2]
008 [>]                         [The quick brown fox jumped over the lazy dog.]
009 [/]                         [attribute]
010 [/]                 [element]
011 [<]         [element]
011 [ ]                 [name]
011 [=]                         [Element2]
012 [<]                 [attribute]
012 [ ]                         [name]
012 [=]                                 [Attribute1]
013 [/]                         [attribute]
014 [<]                 [attribute]
014 [ ]                         [name]
014 [=]                                 [Attribute2]
015 [>]                         [The quick brown fox jumped over the lazy dog.azy]
018 [/]                         [attribute]
019 [/]                 [element]
020 [!]         [-- comments can go anywhere --]
021 [<]         [element]
021 [ ]                 [name]
021 [=]                         [Element2]
022 [<]                 [attribute]
022 [ ]                         [name]
022 [=]                                 [Attribute1]
023 [<]                 [attribute]
023 [ ]                         [name]
023 [=]                                 [Attribute2]
024 [>]                         [value2]
025 [/]                         [attribute]
026 [/]                 [element]
027 [/]         [xmlfile]


Download Functions

Download function write applets, parameters and runtime firmware to device
SDRAM or NVRAM.

WriteExecuteApplet

signed WriteExecuteApplet ( struct plc *   plc,
                            void const *   header);

Write an NVM image directly into SDRAM using VS_WRITE_AND_EXECUTE messages.
This function calls either WriteExecuteApplet1 or WriteExecuteApplet2 based on
the NVM header version. The function is declared in plc.h and defined in
WriteExecuteApplet.c. The plc structure is defined in plc.h.

WriteExecuteApplet1

signed WriteExecuteApplet1 ( struct plc *           plc,
                             struct nvm_header1 *   header);

Write an NVM image directly into SDRAM using VS_WRITE_AND_EXECUTE messages.
This function is similar to WriteExecuteApplet2 but expects a structure
nvm_header1 pointer instead of a structure nvm_header2 pointer. The function is
declared in plc.h and defined in WriteExecuteApplet.c. Structure plc is defined
in file plc.h. Structure nvm_header1 is defined in file nvm.h.

WriteExecuteApplet2

signed WriteExecuteApplet2 ( struct plc *           plc,
                             struct nvm_header2 *   header);

Write an NVM image directly into SDRAM using VS_WRITE_AND_EXECUTE messages.
This function is similar to WriteExecuteApplet1 but expects a structure
nvm_header2 pointer instead of a structure nvm_header1 pointer. The function is
declared in plc.h and defined in WriteExecuteApplet.c. Structure plc is defined
in file plc.h. Structure nvm_header1 is defined in file nvm.h.

Procrastination Functions

Procrastinations functions wait for specific events to occur or fail to occur.

WaitForAssoc

signed WaitForAssoc (struct plc * plc);

Poll a powerline device using VS_NW_INFO messages until the device forms or
joins a network. The host ethernet interface, destination hardware address and
source hardware address are specified in structure plc. It calls either
WaitForAssoc1 or WaitForAssoc2 to procrastinate based on the hardwareID member
of structure plc. The function is declared in plc.h and defined in file
WaitForAssoc.c. Struct plc is declared in file plc.h and defined in file plc.c.

WaitForAssoc1

signed WaitForAssoc1 (struct plc * plc);

Poll a 200mbs powerline device using VS_NW_INFO version 0 messages until the
device joins or forms a network. The host ethernet interface, destination
hardware address and source hardware address are specified in structure plc.
The function is declared in file plc.h and defined in file WaitForAssoc1.c.
Struct plc is declared in file plc.h and defined in file plc.c.

WaitForAssoc2

signed WaitForAssoc2 (struct plc * plc);

Poll a 1000mbs powerline device using VS_NW_INFO version 1 messages until the
device joins or forms a network. The host ethernet interface, destination
hardware address and source hardware address are specified in structure plc.
Structure plc is declared in file plc.h and defined in file plc.c. The function
is declared in file plc.h and defined in file WaitForAssoc2.c.

WaitForReset

signed WaitForReset (struct plc * plc);

Poll a powerline device using VS_SW_VER messages until the device stops
responding. The host ethernet interface, destination hardware address and
source hardware address are specified in structure plc. Structure plc is
declared in file plc.h and define in file plc.c. The function is declared in
plc.h and defined in file WaitForReset.c.

WaitForStart

signed WaitForStart ( struct plc *   plc,
                      char           firmware,
                      size_t         length);

Poll a powerline device using VS_SW_VER messages until the device responds. The
host ethernet interface, destination hardware address and source hardware
address are specified in structure plc. Update the hardwareID member of the plc
structure. Return the firmware revision string contained in the confirmation
message. Structure plc is declared in file plc.h and defined in file plc.c. The
function is declared in file plc.h and defined in file WaitForStart.c.

Traffic Functions

Traffic functions generate powerline traffic in various ways. Some send traffic
direct from the host to each device while others use the VS_FR_LBK message to
echo Ethernet frames back to the sender.

CrossTraffic1

signed CrossTraffic1 (struct plc * plc);

Instruct a powerline device to send a generic Ethernet frame to another
powerline device for a fixed period of time in order to set the TX rate on the
source device and the RX rate on the destination device. The source and
destination address are specified in plc->MAC and plc->RDA, respectively, and
the duration is specified in plc->timeperiod. This function is similar to
function CrossTraffic2 but the source and destination addresses are reversed.
Structure plc is declared in file plc.h and defined in file plc.c. The function
is declared in plc.h and defined in file CrossTraffic1.c.

CrossTraffic2

signed CrossTraffic2 (struct plc * plc);

Instruct a powerline device to send a generic Ethernet frame to another
powerline device for a fixed period of time in order to set the TX rate on the
source device and the RX rate on the destination device. The source and
destination address are specified in plc->RDA and plc->MAC, respectively, and
the duration is specified in plc->timeperiod. This function is similar to
function CrossTraffic1 but the source and destination addresses are reversed.
Structure plc is declared in file plc.h and defined in file plc.c. The function
is declared in plc.h and defined in file CrossTraffic2.c.

LocalTraffic1

signed LocalTraffic1 (struct plc * plc);

Send a fixed number of generic frames from the local host a remote powerline
device in order to set the TX rate on the local powerline device and the RX
rate on the remote powerline device. The local and remote device address are
specified in plc->MAC and plc->RDA, respectively, and the count is specified in
plc->count. This function is similar to function LocalTraffic2 which instructs
a remote device to echo frames back to the local device. Structure plc is
declared in file plc.h and defined in file plc.c. The function is declared in
plc.h and defined in file LocalTraffic1.c.

LocalTraffic2

signed LocalTraffic2 (struct plc * plc);

Instruct a remote powerline device to echo generic Ethernet frames back to the
local host for a fixed period of time in order to set the TX rate on the remote
powerline device and the RX rate on the local powerline device. The local and
remote device address are specified in plc->MAC and plc->RDA, respectively, and
the count is specified in plc->count. This function is useful when there is no
easy way to send traffic from the remote host. This function complements
function LocalTraffic1 which send frames from the local device to a remote
device. Structure plc is declared in file plc.h and defined in file plc.c. The
function is declared in plc.h and defined in file LocalTraffic2.c.

NetworkTraffic1

signed NetworkTraffic1 (struct plc * plc);

This function is an alternative to function NetworkTraffic2 which uses Qualcomm
Version 1 management messages to determine network topology. Structure plc is
declared in file plc.h and defined in file plc.c. The function is declared in
plc.h and defined in file NetworkTraffic1.c.

This function use VS_SW_INFO and VS_NW_INFO messages to discover powerline
network topology then calls functions LocalTraffic1 and LocalTraffic2 to
generate traffic between the local powerline device and each remote powerline
device. Unlike function NetworkTraffic1, it does not generate traffic between
various remote devices.

NetworkTraffic2

signed NetworkTraffic2 (struct plc * plc);

This function is an alternative to function NetworkTraffic1 which uses Qualcomm
Version 0 management messages to determine network topology. Structure plc is
declared in file plc.h and defined in file plc.c. The function is declared in
plc.h and defined in file NetworkTraffic2.c.

Traffic1

signed Traffic1 (struct plc * plc);

This function is an alternative to function Traffic2 which uses Qualcomm
Version 1 management messages to determine network topology. Structure plc is
declared in file plc.h and defined in file plc.c. The function is declared in
plc.h and defined in file Traffic1.c.

This function use VS_SW_INFO and VS_NW_INFO messages to discover powerline
network topology then calls functions LocalTraffic1 and LocalTraffic2 to
generate traffic between the local powerline device and each remote powerline
device. Unlike function NetworkTraffic1, it does not generate traffic between
remote devices.

Traffic2

signed Traffic2 (struct plc * plc);

This function is an alternative to function Traffic1 which uses Qualcomm
Version 0 management messages to determine network topology. Structure plc is
declared in file plc.h and defined in file plc.c. The function is declared in
plc.h and defined in file Traffic2.c.

This function use VS_SW_INFO and VS_NW_INFO messages to discover powerline
network topology then calls functions LocalTraffic1 and LocalTraffic2 to
generate traffic between the local powerline device and each remote powerline
device. Unlike function NetworkTraffic2, it does not generate traffic between
remote devices.

Chapter 8.  Serial Drivers

Table of Contents

Introduction
Principles of Operation
SPI Serial Driver

    qcaspi_spi_thread
    qcaspi_qca7k_sync

Register Functions

    qcaspi_read_register
    qcaspi_write_register
    qcaspi_tx_cmd

Interrupt Functions

    disable_spi_interrupts
    enable_spi_interrupts
    qcaspi_intr_handler

Transmit Functions

    qcaspi_transmit
    qcaspi_tx_frame
    qcaspi_flush_txq

Receive Functions

    qcaspi_receive

DMA Functions

    qcaspi_dma_read_burst
    qcaspi_dma_read_legacy
    qcaspi_dma_write_burst
    qcaspi_dma_write_legacy

Support Functions

    QcaFrmCreateHeader
    QcaFrmCreateFooter
    QcaFrmFsmInit
    QcaFrmFsmDecode

Kernel Functions

    qcaspi_netdev_xmit
    qcaspi_netdev_tx_timeout
    qcaspi_netdev_uninit
    qcaspi_netdev_get_stats
    qcaspi_netdev_change_mtu
    qcaspi_netdev_set_mac_address
    qcaspi_netdev_close
    qcaspi_mod_exit

Introduction

Most Qualcomm Atheros PLC chipsets are Ethernet-to-Powerline bridges but the
QCA7000 is a Serial-to-Powerline bridge, ... with a big difference. The QCA7000
expects the host serial stream to be segmented into Ethernet frames where each
frame is encapsulated by a distinct serial header and trailer. This means the
host can format and transmit, or receive and decode, standard Ethernet 802.3
frames over an ordinary SPI or UART interface thereby enabling full Ethernet or
Internet protocol communications over powerline at low cost and low speed. The
enabling componenthere is an Ethernet-to-Serial driver that supports the SPI or
UART interface connected to the QCA7000. This section covers such a driver.

The example driver described here was written for the Freescale iMX28 board
support package running a custom Freescale Linux distribution. As such, we
believe that this driver is suitable for the iMX28 processor out of the box but
it could be adapted to other processors.

Principles of Operation

The basic unit of data transfer over MII and powerline is the IEEE 802.3
Ethernet frame. On output, the host must encapsulate each Ethernet frame as
shown below before serial transmission to the QCA7000. The QCA7000 strips off
the serial header and footer and forwards the frame over powerline.

Table 8.1.  SPI Transmit Frame

Allocate a 1528-byte buffer to accomodate the largest outgoing serial packet
and pad with NUL bytes. Write SOF, compute and write FL, copy the outgoing
frame then write EOF. Serially transmit FL + 12 buffer bytes to the QCA7000.

┌──────┬──────┬──────┬────────────────────────────────────────────────────────┐
│Offset│Length│Symbol│                      Description                       │
├──────┼──────┼──────┼────────────────────────────────────────────────────────┤
│0x0000│4     │SOF   │Start Of Frame. Must be 0xAAAAAAAA.                     │
├──────┼──────┼──────┼────────────────────────────────────────────────────────┤
│      │      │      │The Ethernet frame length in little endian format. The  │
│0x0004│2     │FL    │frame starts at offset 0x0008 here and includes all     │
│      │      │      │fields up to but excluding EOF. The minimum is 60. The  │
│      │      │      │maximum is 1518 if VLAN is omitted and 1522 if not.     │
├──────┼──────┼──────┼────────────────────────────────────────────────────────┤
│0x0006│2     │RSVD  │Must be 0x0000. Reserved to ensure 4-byte frame         │
│      │      │      │alignment.                                              │
├──────┼──────┼──────┼────────────────────────────────────────────────────────┤
│0x0008│6     │DA    │Destination address.                                    │
├──────┼──────┼──────┼────────────────────────────────────────────────────────┤
│      │      │      │Source address. This must not be the MAC address of the │
│      │      │      │powerline device. This must be the MAC address of the   │
│0x000E│6     │SA    │local host serial interface as assigned by the SP or    │
│      │      │      │UART driver. The PLC device and the associated host     │
│      │      │      │interface must have different MAC address.              │
├──────┼──────┼──────┼────────────────────────────────────────────────────────┤
│0x0014│4     │VLAN  │Virtual LAN tag. This field may be omitted.             │
├──────┼──────┼──────┼────────────────────────────────────────────────────────┤
│0x0018│2     │ET    │Ethertype. This field starts at offset 0x0014 if VLAN is│
│      │      │      │omitted.                                                │
├──────┼──────┼──────┼────────────────────────────────────────────────────────┤
│0x001A│42 to │BODY  │Frame body. This field starts at offset 0x0016 and      │
│      │1500  │      │ranges from 46 to 1500 bytes if VLAN is omitted.        │
├──────┼──────┼──────┼────────────────────────────────────────────────────────┤
│0x004A│      │      │End Of Frame. Must be 0x5555. This field starts at      │
│to    │4     │EOF   │offset 0x0008 plus FL.                                  │
│0x05F8│      │      │                                                        │
└──────┴──────┴──────┴────────────────────────────────────────────────────────┘


Table 8.2.  SPI Receive Frame

The SPI read frame occurs in response to a read interrupt generated by the
QCA7000. The host must acknowledge a read interrupt and service it by reading
and acting on QCA7000 SPI register values. For incoming frames, the host reads
the 32-bit overall packet length reported by the QCA7000 then read that many
bytes, stripping off the serial header and footer and forwarding the Ethernet
frame to the host.

Allocate a 1532-byte buffer to accomodate the largest incoming serial packet.
Read LEN to determine the size of the incoming serial packet. Read LEN bytes
into the buffer. Beware that LEN is a multiple of 4-bytes so there may be a few
trailing NUL bytes in buffer.

┌──────┬──────┬──────┬────────────────────────────────────────────────────────┐
│Offset│Length│Symbol│                      Description                       │
├──────┼──────┼──────┼────────────────────────────────────────────────────────┤
│0x0000│4     │LEN   │Hardware generated packet length. This field is only    │
│      │      │      │generated for SPI packets, not the UART packets.        │
├──────┼──────┼──────┼────────────────────────────────────────────────────────┤
│0x0004│4     │SOF   │Start Of Frame. Must be 0xAAAAAAAA.                     │
├──────┼──────┼──────┼────────────────────────────────────────────────────────┤
│      │      │      │Ethernet frame length in little endian format. The frame│
│0x0008│2     │FL    │starts at offset 0x000C here and includes all fields up │
│      │      │      │to but excluding EOF. The minimum length is 60. The     │
│      │      │      │maximum is 1518 if VLAN is omitted and 1522 if not.     │
├──────┼──────┼──────┼────────────────────────────────────────────────────────┤
│0x000A│2     │RSVD  │Must be 0x0000. Reserved to ensure 4-byte frame         │
│      │      │      │alignment.                                              │
├──────┼──────┼──────┼────────────────────────────────────────────────────────┤
│0x000C│6     │DA    │Destination address.                                    │
├──────┼──────┼──────┼────────────────────────────────────────────────────────┤
│      │      │      │Source address. This must not be the MAC address of the │
│      │      │      │powerline device. This must be the MAC address of the   │
│0x0012│6     │SA    │local host serial interface as assigned by the SP or    │
│      │      │      │UART driver. The PLC device and the associated host     │
│      │      │      │interface must have different MAC address.              │
├──────┼──────┼──────┼────────────────────────────────────────────────────────┤
│0x0018│4     │VLAN  │Virtual LAN tag. This field may be omitted.             │
├──────┼──────┼──────┼────────────────────────────────────────────────────────┤
│0x001C│2     │ET    │Ethertype. This field starts offset 0x0018 if VLAN is   │
│      │      │      │omitted.                                                │
├──────┼──────┼──────┼────────────────────────────────────────────────────────┤
│0x001E│42 to │BODY  │Frame body. This field starts at offset 0x001A and      │
│      │1500  │      │ranges from 46 to 1500 bytes if VLAN is omitted.        │
├──────┼──────┼──────┼────────────────────────────────────────────────────────┤
│0x004A│      │      │End Of Frame. Must be 0x5555. This field starts at      │
│to    │4     │EOF   │offset 0x000C plus FL.                                  │
│0x05F8│      │      │                                                        │
└──────┴──────┴──────┴────────────────────────────────────────────────────────┘


SPI Serial Driver

qcaspi_spi_thread

static int qcaspi_spi_thread ( char void *   data);

Manages synchronization with the exteranl QCA7000. Handles interrupts fomr the
external QCA7000. Transmits frames for the transmit queue to the QCA7000.

qcaspi_qca7k_sync

void qca_qca7k_sync ( char struct qcaspi *   qca,
                      int                    event);

Keeps track of the current synchonization state.

Register Functions

qcaspi_read_register

uint16_t qcaspi_read_register ( struct qcaspi *   qca,
                                uint16_t          reg);

Reads a QCA7000 register and returns register content.

qcaspi_write_register

void qcaspi_write_register ( struct qcaspi *   qca,
                             uint16_t          reg,
                             uint16_t          value);

Write a value into a QCA7000 register.

qcaspi_tx_cmd

int qcaspi_tx_cmd ( struct qcaspi *   qca,
                    uint16_t          cmd);

Transmit a 16-bit command to the QCA7000. This is currently used when
performing a legacy DMA read or write.

Interrupt Functions

disable_spi_interrupts

uint32_t disable_spi_interrupts ( struct qcaspi *   qca);

Disables interrupts by writing 0 to the QCA7000 INTR_ENABLE register.

enable_spi_interrupts

uint32_t enable_spi_interrupts ( struct qcaspi *   qca,
                                 uint32_t          intr_enable);

Enables interrupts specified by writing to the QCA7000 INTR_ENABLE register and
returns the previous register value.

qcaspi_intr_handler

static irqreturn_t qcaspi_intr_handler ( int      irq,
                                         void *   data);

Called to service interrupts on rising edge of the QCA7000 interrupt line.

Transmit Functions

qcaspi_transmit

int qcaspi_transmit (struct qcaspi * qca);

Transmit as many frames as possible from the transmit queue.

qcaspi_tx_frame

int qcaspi_tx_frame ( struct qcaspi *    qca,
                      struct sk_buff *   skb);

Transmit a single socket buffer over the SPI interface.

qcaspi_flush_txq

void qcaspi_flush_txq (struct qcaspi * qca);

Flush the transmit queue. Typically called when a synchronization issue is
detected between the SPI master (host) and SPI slave (QCA7000).

Receive Functions

qcaspi_receive

int qcaspi_receive (struct qcaspi * qca);

Reads the QCA7000 read buffer bytes register and reads all available data from
the QCA7000. Calls function to parse out the individual Ethernet frames and
passes them to the Linux kernel protocol stack.

DMA Functions

qcaspi_dma_read_burst

uint32_t qcaspi_dma_read_burst ( struct qcaspi *   qca,
                                 uint8_t *         buffer,
                                 uint32_t          length);

Performs QCA7000 DMA burst read.

qcaspi_dma_read_legacy

uint32_t qcaspi_dma_read_legacy ( struct qcaspi *   qca,
                                  uint8_t *         buffer,
                                  uint32_t          length);

Performs QCA7000 DMA legacy read.

qcaspi_dma_write_burst

uint32_t qcaspi_dma_write_burst ( struct qcaspi *   qca,
                                  uint8_t *         buffer,
                                  uint32_t          length);

Called by qcaspi_tx_frame to peform a DMA burst write instead of a legacy
write.

qcaspi_dma_write_legacy

uint32_t qcaspi_dma_write_legacy ( struct qcaspi *   qca,
                                   uint8_t *         buffer,
                                   uint32_t          length);

Called by qcaspi_tx_frame to peform a DMA legacy write instead of a burst
write.

Support Functions

QcaFrmCreateHeader

uint32_t QcaFrmCreateHeader ( uint8_t *   buffer,
                              uint16_t    length);

Encode buffer with the required SPI header and overall frame length.

QcaFrmCreateFooter

uint32_t QcaFrmCreateFooter ( uint8_t *   buffer);

Encode buffer with the required SPI footer.

QcaFrmFsmInit

void QcaFrmFsmInit (QcaFrmHdl * frmHdl);

Initialize the state machine used to decode the incoming QCA7000 byte stream.

QcaFrmFsmDecode

uint32_t QcaFrmFsmDecode ( QcaFrmHdl *   frmHdl,
                           uint8_t *     buffer,
                           uint16_t      length,
                           uint8_t       bytevalue);

Feeds incoming bytes into the state machine and breaks the stream into
individual frames. Frames are passed to the Linux kernel.

Kernel Functions

qcaspi_netdev_xmit

int qcaspi_netdev_xmit ( struct sk_buff *      skb,
                         struct net_device *   device);

Called by the Linux kernel append outgoing frames to the transmit queue.

qcaspi_netdev_tx_timeout

void qcaspi_netdev_tx_timeout ( struct net_device *   device);

Called by the Linux kernel after the transmit queue has been stopped for an
extended period of time.

qcaspi_netdev_uninit

static void qcaspi_netdev_uninit ( struct net_device *   device);

Called when function unregister_netdev is called. For the QCA7000 driver,
function qcaspi_mod_exit calls function unregister_netdev.

qcaspi_netdev_get_stats

struct net_device_stats * qcaspi_netdev_get_stats struct net_device *  device);
 (                                                 

Returns transmit, receive and error statistics associated with the net device.
These are the statistics displayed by ifconfig.

qcaspi_netdev_change_mtu

int qcaspi_netdev_change_mtu ( struct net_device *   device,
                               int                   new_mtu);

Changes the serial interface MTU size.

qcaspi_netdev_set_mac_address

static int qcaspi_netdev_set_mac_address ( struct net_device *   device,
                                           void *                memory);

Sets the serial interface MAC address. Called by ifconfig whenever user types
ifconfig qca0 hw ether xx:xx:xx:xx:xx:xx.

qcaspi_netdev_close

int qcaspi_netdev_close ( struct net_device *   device);

Called by ifconfig to disable the network interface.

qcaspi_mod_exit

static void qcaspi_mod_exit (void);

Called by the kernel to shutdown the driver module.

0
