<?xml version='1.0' encoding='iso-8859-1'?>
<!doctype html public '-//W3C//DTD XHTML 1.0 Strict//EN' 'http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd'>
<html xmlns='http://www.w3c.org/1999/xhtml' lang='en-us'>
	<head>
		<title>
			psgen_util.c
			</title>
		<meta http-equiv='content-type' content='text/html;iso-8859-1'/>
		<meta name='generator' content='Motley Tools 1.8.2'/>
		<meta name='author' content='cmaier@cmassoc.net'/>
		<meta name='robots' content='noindex,nofollow'/>
		<link href='toolkit.css' rel='stylesheet' type='text/css'/>
		</head>
	<body>
		<div class='headerlink'>
			[<a href='psgen.c.html' title=' psgen.c '>PREV</a>]
			[<a href='toolkit.html' title=' Index '>HOME</a>]
			[<a href='psgraph.c.html' title=' psgraph.c '>NEXT</a>]
			</div>
<pre>
/*====================================================================*
 *   
 *   Copyright (c) 2011, Atheros Communications Inc.
 *   
 *   Permission to use, copy, modify, and/or distribute this software 
 *   for any purpose with or without fee is hereby granted, provided 
 *   that the above copyright notice and this permission notice appear 
 *   in all copies.
 *   
 *   THE SOFTWARE IS PROVIDED &quot;AS IS&quot; AND THE AUTHOR DISCLAIMS ALL 
 *   WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED 
 *   WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL  
 *   THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR 
 *   CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM 
 *   LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, 
 *   NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN 
 *   CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 *   
 *--------------------------------------------------------------------*/

/*====================================================================*
 *
 *   psgen_util.c - helpers for the psgen program
 *
 *   This software and documentation is the property of Atheros 
 *   Corporation, Ocala, Florida. It is provided 'as is' without 
 *   expressed or implied warranty of any kind to anyone for any 
 *   reason. Atheros assumes no responsibility or liability for 
 *   errors or omissions in the software or documentation and 
 *   reserves the right to make changes without notification. 
 *   
 *   Atheros customers may modify and distribute the software 
 *   without obligation to Atheros. Since use of this software 
 *   is optional, users shall bear sole responsibility and 
 *   liability for any consequences of it's use. 
 *
 *.  Qualcomm Atheros HomePlug AV Powerline Toolkit
 *:  Published 2009-2011 by Qualcomm Atheros. ALL RIGHTS RESERVED
 *;  For demonstration and evaluation only. Not for production use
 *
 *   Contributor(s):
 *	Nathaniel Houghton &lt;nathaniel.houghton@qualcomm.com&gt;
 *
 *--------------------------------------------------------------------*/

#ifndef PSGEN_UTIL_SOURCE
#define PSGEN_UTIL_SOURCE

/*====================================================================*
 *   system header files;
 *--------------------------------------------------------------------*/

#include &lt;ctype.h&gt;
#include &lt;stdio.h&gt;
#include &lt;unistd.h&gt;

/*====================================================================*
 *   custom header files;
 *--------------------------------------------------------------------*/

#include &quot;../tools/files.h&quot;
#include &quot;../tools/error.h&quot;
#include &quot;../nda/psgen.h&quot;
#include &quot;../pib/pib.h&quot;

/*
 * Read a double in from string s, scaling with a suffix;
 *
 * Returns pointer character where parsing stopped.
 */

const char * strtodouble (const char *s, double *d) 

{
	const char *p;
	int sign = 1;
	double div;
	div = 0;
	*d = 0;
	p = s;
	if (*p == '-') 
	{
		sign = -1;
		++p;
	}
	else if (*p == '+') 
	{
		sign = 1;
		++p;
	}
	while (*p != '\0') 
	{
		if (isdigit (*p)) 
		{
			if (div == 0) 
			{
				*d = *d * 10 + (*p - '0');
			}
			else 
			{
				*d = *d + (*p - '0') / div;
				div *= 10;
			}
		}
		else if (*p == '.' &amp;&amp; div == 0) 
		{
			div = 10;
		}
		else 
		{
			break;
		}
		++p;
	}
	*d *= sign;
	switch (*p) 
	{
	case 'M':
		*d *= 1000000;
		++p;
		break;
	case 'K':
	case 'k':
		*d *= 1000;
		++p;
		break;
	}
	return p;
}

uint32_t freq_to_index (double freq, struct device_spec *d) 

{
	return rint ((freq * 40.96 / 1000000.0) - 74.0);
}

double index_to_freq (uint32_t index, struct device_spec *d) 

{
	return 1000000 * (index + 74.0) / 40.96;
}

double ps_to_amp (uint32_t ps, struct device_spec *d) 

{
	return 20 * log10 (ps / (double) d-&gt;prescaler_unity);
}

uint32_t amp_to_ps (double amp, struct device_spec *d) 

{
	double val = rint (pow (10.0, amp / 20.0) * d-&gt;prescaler_unity);
	if (val &gt; d-&gt;prescaler_max) return d-&gt;prescaler_max + 1;
	return (uint32_t) val;
}

uint32_t lynx_freq_to_index (double freq, struct device_spec *d) 

{
	return rint ((freq / 24400 - 74.0) / 2);
}

double lynx_index_to_freq (uint32_t index, struct device_spec *d) 

{
	return (index * 2 + 74.0) * 24400;
}

uint32_t panther_freq_to_index (double freq, struct device_spec *d) 

{
	return rint (((freq / 24400) - 74.0) / 2);
}

double panther_index_to_freq (uint32_t index, struct device_spec *d) 

{
	return (index * 2 + 74.0) * 24400;
}

int create_trace_fsl3 (struct fsl3_file *fsl3_file, struct trace *trace) 

{
	int i;
	int j;
	const char *p;
	for (i = 0; i &lt; fsl3_file-&gt;item_count; ++i) 
	{
		if (!strcasecmp (fsl3_file-&gt;item [i].name, &quot;Values&quot;)) 
		{
			fsl3_file-&gt;trace_start = i + 1;
			fsl3_file-&gt;trace_end = fsl3_file-&gt;trace_start + atoi (fsl3_file-&gt;item [i].value) - 1;
			if (fsl3_file-&gt;trace_end &gt; fsl3_file-&gt;item_count) 
			{
				error (1, 0, &quot;trace extends beyond end of file&quot;);
			}
			break;
		}
	}
	if (i == fsl3_file-&gt;item_count) 
	{
		error (1, 0, &quot;no trace data found in input file&quot;);
	}
	memset (trace, 0, sizeof (*trace));
	trace-&gt;count = fsl3_file-&gt;trace_end - fsl3_file-&gt;trace_start + 1;
	trace-&gt;freq = calloc (trace-&gt;count, sizeof (*trace-&gt;freq));
	if (trace-&gt;freq == NULL) 
	{
		error (1, 0, &quot;could not allocate memory for trace frequency data&quot;);
	}
	trace-&gt;value = calloc (trace-&gt;count, sizeof (*trace-&gt;value));
	if (trace-&gt;value == NULL) 
	{
		error (1, 0, &quot;could not allocate memory for trace value data&quot;);
	}
	for (i = 0, j = fsl3_file-&gt;trace_start; i &lt; trace-&gt;count; ++i, ++j) 
	{
		p = strtodouble (fsl3_file-&gt;item [j].name, &amp;trace-&gt;freq [i]);
		if (*p != '\0') 
		{
			error (1, 0, &quot;invalid frequency value in input: %s&quot;, fsl3_file-&gt;item [j].name);
		}
		p = strtodouble (fsl3_file-&gt;item [j].value, &amp;trace-&gt;value [i]);
		if (*p != '\0') 
		{
			error (1, 0, &quot;invalid amplitude value in input: %s&quot;, fsl3_file-&gt;item [j].value);
		}
	}
	return 0;
}

int load_fsl3 (const char *path, struct fsl3_file *fsl3_file) 

{
	int c;
	off_t fsize;
	char *data;
	char *p;
	char *start;
	int count;
	FILE *fp;
	fp = fopen (path, &quot;r&quot;);
	if (fp == NULL) 
	{
		error (1, 0, &quot;could not open %s&quot;, path);
	}
	memset (fsl3_file, 0, sizeof (*fsl3_file));
	if (fseek (fp, 0, SEEK_END) == -1) 
	{
		error (1, errno, &quot;failed to load input file&quot;);
	}
	fsize = ftell (fp);
	if (fseek (fp, 0, SEEK_SET) == -1) 
	{
		error (1, errno, &quot;failed to load input file&quot;);
	}
	if (fsize == 0) 
	{
		error (1, 0, &quot;input file is empty&quot;);
	}
	data = malloc (fsize);
	if (data == NULL) 
	{
		error (1, errno, &quot;failed to load input file&quot;);
	}
	p = data;
	while ((c = fgetc (fp)) != EOF) 
	{
		if (c == '\n') 
		{
			++fsl3_file-&gt;item_count;
		}
		*p = c;
		++p;
	}
	fclose (fp);
	fsl3_file-&gt;item = calloc (fsl3_file-&gt;item_count, sizeof (struct fsl3_item));
	if (fsl3_file-&gt;item == NULL) 
	{
		free (data);
		error (1, errno, &quot;failed to load input file&quot;);
	}
	p = data;
	count = 0;
	while (count &lt; fsl3_file-&gt;item_count) 
	{

/* collect name */

		start = p;
		while (*p != ';' &amp;&amp; *p != '\n') 
		{
			++p;
		}
		if (*p == '\n') 
		{
			error (1, errno, &quot;unexpected end of line %d&quot;, count + 1);
		}
		*p = '\0';
		++p;
		fsl3_file-&gt;item [count].name = start;

/* collect value */

		start = p;
		while (*p != ';' &amp;&amp; *p != '\n') 
		{
			++p;
		}
		if (*p == '\n') 
		{
			error (1, errno, &quot;unexpected end of line %d&quot;, count + 1);
		}
		*p = '\0';
		++p;
		fsl3_file-&gt;item [count].value = start;

/* collect unit */

		start = p;
		while (*p != ';' &amp;&amp; *p != '\n') 
		{
			++p;
		}
		if (*p == ';') 
		{
			error (1, errno, &quot;unexpected item on line %d&quot;, count + 1);
		}
		*p = '\0';
		++p;
		fsl3_file-&gt;item [count].unit = start;
		++count;
	}
	return 0;
}

void free_fsl3_file (struct fsl3_file *fsl3_file) 

{
	free (fsl3_file-&gt;item [0].name);
	free (fsl3_file-&gt;item);
}

void free_tweaks (struct tweak *t) 

{
	if (t == NULL) 
	{
		return;
	}
	free_tweaks (t-&gt;next);
	free (t);
}

void free_dev_config (struct dev_config *dconf) 

{
	free (dconf-&gt;prescaler);
	free (dconf);
}

int parse_tweak (struct tweak *t, const char *s) 

{
	const char *p;
	p = s;
	p = strtodouble (p, &amp;t-&gt;sf);
	if (*p != ',') 
	{
		error (1, 0, &quot;error in tweak starting at %s&quot;, p);
	}
	++p;
	p = strtodouble (p, &amp;t-&gt;ef);
	if (*p != ',') 
	{
		error (1, 0, &quot;error in tweak starting at %s&quot;, p);
	}
	++p;
	p = strtodouble (p, &amp;t-&gt;sv);
	if (*p != ',') 
	{
		error (1, 0, &quot;error in tweak starting at %s&quot;, p);
	}
	++p;
	p = strtodouble (p, &amp;t-&gt;ev);
	if (*p != '\0') 
	{
		error (1, 0, &quot;error in tweak starting at %s&quot;, p);
	}
	return 0;
}

int create_trace_copy (struct trace *dst, struct trace *src) 

{
	memcpy (dst, src, sizeof (*dst));
	dst-&gt;freq = calloc (dst-&gt;count, sizeof (*dst-&gt;freq));
	if (dst-&gt;freq == NULL) 
	{
		return -1;
	}
	dst-&gt;value = calloc (dst-&gt;count, sizeof (*dst-&gt;value));
	if (dst-&gt;value == NULL) 
	{
		free (dst-&gt;freq);
		return -1;
	}
	memcpy (dst-&gt;freq, src-&gt;freq, dst-&gt;count * sizeof (*dst-&gt;freq));
	memcpy (dst-&gt;value, src-&gt;value, dst-&gt;count * sizeof (*dst-&gt;value));
	return 0;
}

int reshape_trace (struct trace *dst, struct trace *src, struct device_spec *dspec) 

{
	int i;
	dst-&gt;count = dspec-&gt;prescaler_count;
	dst-&gt;freq = calloc (dst-&gt;count, sizeof (*dst-&gt;freq));
	if (dst-&gt;freq == NULL) 
	{
		return -1;
	}
	dst-&gt;value = calloc (dst-&gt;count, sizeof (*dst-&gt;value));
	if (dst-&gt;value == NULL) 
	{
		free (dst-&gt;freq);
		return -1;
	}
	for (i = 0; i &lt; dst-&gt;count; ++i) 
	{
		dst-&gt;freq [i] = dspec-&gt;index_to_freq (i, dspec);
		dst-&gt;value [i] = estimate_trace_value (src, dst-&gt;freq [i]);
	}
	return 0;
}

void free_trace_data (struct trace *t) 

{
	free (t-&gt;freq);
	free (t-&gt;value);
	memset (t, 0, sizeof (*t));
}

/*
 * Perform a binary search on the trace data and return
 * an index close to the requested frequency (+/-1).
 */

int find_trace_index (struct trace *t, double freq) 

{
	int min;
	int max;
	int cur;
	if (t-&gt;count == 0) 
	{
		return -1;
	}
	min = 0;
	max = t-&gt;count - 1;
	if (freq &lt; t-&gt;freq [min] || freq &gt; t-&gt;freq [max]) 
	{
		return -1;
	}
	while (min &lt; max) 
	{
		cur = (min + max) / 2;
		if (t-&gt;freq [cur] &gt; freq) 
		{
			max = cur - 1;
		}
		else if (t-&gt;freq [cur] &lt; freq) 
		{
			min = cur + 1;
		}
		else 
		{
			return cur;
		}
	}
	return min;
}

double estimate_trace_value (struct trace *t, double freq) 

{
	int freq_index;
	double ret;
	double slope;
	freq_index = find_trace_index (t, freq);
	if (freq_index == -1) 
	{
		error (1, 0, &quot;could not find trace value for frequency %f&quot;, freq);
	}
	if (t-&gt;freq [freq_index] &gt; freq) 
	{
		slope = (t-&gt;value [freq_index] - t-&gt;value [freq_index - 1]) / (t-&gt;freq [freq_index] - t-&gt;freq [freq_index - 1]);
		ret = t-&gt;value [freq_index - 1] + slope * (freq - t-&gt;freq [freq_index - 1]);
	}
	else if (t-&gt;freq [freq_index] &lt; freq) 
	{
		slope = (t-&gt;value [freq_index + 1] - t-&gt;value [freq_index]) / (t-&gt;freq [freq_index + 1] - t-&gt;freq [freq_index]);
		ret = t-&gt;value [freq_index] + slope * (freq - t-&gt;freq [freq_index]);
	}
	else 
	{
		ret = t-&gt;value [freq_index];
	}
	return ret;
}

int apply_tweak (struct trace *trace, struct tweak *tweak, int mode) 

{
	int index_sf;
	int index_ef;
	int i;
	double slope;
	index_sf = find_trace_index (trace, tweak-&gt;sf);
	if (index_sf == -1) 
	{
		error (1, 0, &quot;could not find trace frequency %f&quot;, tweak-&gt;sf);
	}
	index_ef = find_trace_index (trace, tweak-&gt;ef);
	if (index_ef == -1) 
	{
		error (1, 0, &quot;could not find trace frequency %f&quot;, tweak-&gt;ef);
	}
	slope = (tweak-&gt;ev - tweak-&gt;sv) / (index_ef - index_sf);
	switch (mode) 
	{
	case TWEAK_ABSOLUTE:
		for (i = index_sf; i &lt;= index_ef; ++i) 
		{
			trace-&gt;value [i] = tweak-&gt;sv + slope * (i - index_sf);
		}
		break;
	case TWEAK_RELATIVE:
		for (i = index_sf; i &lt;= index_ef; ++i) 
		{
			trace-&gt;value [i] += tweak-&gt;sv + slope * (i - index_sf);
		}
		break;
	default:
		return -1;
	}
	return 0;
}

struct dev_config * generate_config (struct trace *tr_old, struct trace *tr_new, struct device_spec *dspec, int gain_adj) 

{
	unsigned i;
	double old_val;
	double new_val;
	double diff;
	uint32_t ps_val;
	struct dev_config *dconf;
	dconf = malloc (sizeof (*dconf));
	if (dconf == NULL) 
	{
		error (0, 0, &quot;could not allocate memory&quot;);
		return NULL;
	}
	dconf-&gt;prescaler = calloc (sizeof (dconf-&gt;prescaler), dspec-&gt;prescaler_count);
	if (dconf-&gt;prescaler == NULL) 
	{
		error (0, 0, &quot;could not allocate memory&quot;);
		free (dconf);
		return NULL;
	}
	dconf-&gt;dspec = dspec;
	dconf-&gt;gain_adj = gain_adj;
	dconf-&gt;truncated = 0;
	dconf-&gt;average = 0;
	for (i = 0; i &lt; dspec-&gt;prescaler_count; ++i) 
	{
		old_val = estimate_trace_value (tr_old, dspec-&gt;index_to_freq (i, dspec));
		new_val = estimate_trace_value (tr_new, dspec-&gt;index_to_freq (i, dspec)) - dconf-&gt;gain_adj;
		diff = new_val - old_val;
		ps_val = dspec-&gt;amp_to_ps (diff, dspec);
		if (ps_val &gt; dspec-&gt;prescaler_max) 
		{
			ps_val = dspec-&gt;prescaler_max;
			++dconf-&gt;truncated;
		}
		dconf-&gt;prescaler [i] = ps_val;
		dconf-&gt;average += ps_val;
	}
	dconf-&gt;average /= dspec-&gt;prescaler_count;
	return dconf;
}

int print_config (struct dev_config *dconf) 

{
	unsigned i;
	for (i = 0; i &lt; dconf-&gt;dspec-&gt;prescaler_count; ++i) 
	{
		printf (&quot;%08d %08x\n&quot;, i, dconf-&gt;prescaler [i]);
	}
	printf (&quot;# average is %f\n&quot;, dconf-&gt;average);
	printf (&quot;# %d carriers truncated\n&quot;, dconf-&gt;truncated);
	printf (&quot;# PIB output power adjust: %d\n&quot;, dconf-&gt;gain_adj);
	return 0;
}

#define GAIN_ENABLE_OFFSET_6400 0x1F6E

int set_tx_gain_6400 (struct _file_ *pib, int gain) 

{
	uint8_t gain_value;
	uint8_t gain_enable;
	if (lseek (pib-&gt;file, GAIN_ENABLE_OFFSET_6400, SEEK_SET) != GAIN_ENABLE_OFFSET_6400) 
	{
		return -1;
	}
	switch (gain) 
	{
	case -6:
		gain_value = 0x05;
		break;
	case -4:
		gain_value = 0x03;
		break;
	case -2:
		gain_value = 0x01;
		break;
	case 0:
		gain_value = 0x00;
		break;
	case 2:
	case 4:
	case 6:
		gain_value = gain;
		break;
	default:
		error (0, 0, &quot;invalid gain value&quot;);
		return -1;
	}
	if (gain_value == 0) 
	{
		gain_enable = 0;
	}
	else 
	{
		gain_enable = 1;
	}
	if (write (pib-&gt;file, &amp;gain_enable, sizeof (gain_enable)) != 1) 
	{
		error (1, errno, &quot;could not enable output power level adjustment&quot;);
	}
	if (write (pib-&gt;file, &amp;gain_value, sizeof (gain_value)) != 1) 
	{
		error (1, errno, &quot;could set output power level adjustment&quot;);
	}
	return 0;
}

int update_pib (const char *path, struct dev_config *dconf) 

{
	struct _file_ pib;
	pib.name = path;
	pib.file = open (path, O_BINARY | O_RDWR);
	if (pib.file == -1) 
	{
		error (1, 0, &quot;could not open PIB file %s for updating&quot;, path);
	}
	if (pibfile1 (&amp;pib)) 
	{
		error (1, 0, &quot;invalid PIB file&quot;);
	}
	if (psin (&amp;pib, dconf)) 
	{
		error (1, 0, &quot;could not update PIB&quot;);
	}
	if (piblock (&amp;pib)) 
	{
		error (1, 0, &quot;could not lock PIB&quot;);
	}
	if (dconf-&gt;dspec-&gt;set_tx_gain != NULL) 
	{
		if (dconf-&gt;dspec-&gt;set_tx_gain (&amp;pib, dconf-&gt;gain_adj) == -1) 
		{
			error (1, 0, &quot;could not update TX gain&quot;);
		}
	}
	if (piblock (&amp;pib)) 
	{
		error (1, 0, &quot;could not lock PIB&quot;);
	}
	close (pib.file);
	printf (&quot;# average is %f\n&quot;, dconf-&gt;average);
	printf (&quot;# %d carriers truncated\n&quot;, dconf-&gt;truncated);
	printf (&quot;# PIB output power adjust: %d\n&quot;, dconf-&gt;gain_adj);
	return 0;
}

int ar7x00_psin (struct _file_ *pib, uint32_t value, uint32_t index) 

{
	off_t offset = AMP_PRESCALER_OFFSET + (index * 10 / 8);
	uint8_t bit_offset = (index * 10) % 8;
	uint16_t tmp;
	if (lseek (pib-&gt;file, offset, SEEK_SET) != offset) 
	{
		return -1;
	}
	if (read (pib-&gt;file, &amp;tmp, sizeof (tmp)) != sizeof (tmp)) 
	{
		return -1;
	}
	if (lseek (pib-&gt;file, offset, SEEK_SET) != offset) 
	{
		return -1;
	}
	value &amp;= 0x03FF;
	tmp = LE16TOH (tmp);
	tmp &amp;= ~(0x03FF &lt;&lt; bit_offset);
	tmp |= value &lt;&lt; bit_offset;
	tmp = HTOLE16 (tmp);
	if (write (pib-&gt;file, &amp;tmp, sizeof (tmp)) != sizeof (tmp)) 
	{
		return -1;
	}
	return 0;
}

#define AMP_CARRIERS 2880
#define INT_CARRIERS 1155

int psin (struct _file_ *pib, struct dev_config *dconf) 

{
	uint32_t value;
	unsigned limit;
	unsigned i;
	limit = pibscalers (pib);
	if ((limit != INT_CARRIERS) &amp;&amp; (limit != AMP_CARRIERS)) 
	{
		error (1, 0, &quot;Don't understand this PIB's prescaler format&quot;);
	}
	if (limit == INT_CARRIERS) 
	{
		if (lseek (pib-&gt;file, INT_PRESCALER_OFFSET, SEEK_SET) != INT_PRESCALER_OFFSET) 
		{
			error (1, errno, &quot;Can't seek %s&quot;, pib-&gt;name);
		}
	}
	if (dconf-&gt;dspec-&gt;prescaler_count != limit) 
	{
		error (1, 0, &quot;PIB file type does not match device target type&quot;);
	}
	for (i = 0; i &lt; limit; ++i) 
	{
		value = dconf-&gt;prescaler [i];
		if (limit == INT_CARRIERS) 
		{
			if (write (pib-&gt;file, &amp;value, sizeof (value)) != sizeof (value)) 
			{
				error (1, errno, &quot;Can't save %s&quot;, pib-&gt;name);
			}
		}
		else if (limit == AMP_CARRIERS) 
		{
			if (value &amp; ~0x03FF) 
			{
				error (1, errno, &quot;Position %d has invalid prescaler value&quot;, i);
			}
			if (ar7x00_psin (pib, value, i)) 
			{
				error (1, errno, &quot;Can't update %s&quot;, pib-&gt;name);
			}
		}
	}
	return 0;
}

int check_tx_gain_6400 (int gain_adj) 

{
	if ((gain_adj &amp; 1) || gain_adj &lt; -6 || gain_adj &gt; 6) 
	{
		error (1, 0, &quot;invalid gain adjustment, must be one of -6, -4, -2, 0, 2, 4, 6&quot;);
		return -1;
	}
	return 0;
}

#ifdef WIN32

double rint (double x) 

{
	return floor (x + 0.5);
}

#endif

#endif


</pre>
		<div class='footerlink'>
			[<a href='psgen.c.html' title=' psgen.c '>PREV</a>]
			[<a href='toolkit.html' title=' Index '>HOME</a>]
			[<a href='psgraph.c.html' title=' psgraph.c '>NEXT</a>]
			</div>
		</body>
	</html>
